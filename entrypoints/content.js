import ApiService from '../core/services/ApiService.js';
import BookmarkWordsService from '../core/services/BookmarkWordsService.js';
import ApiConfig from '../core/config/apiConfig.js';

export default defineContentScript({
  matches: ['<all_urls>'],
  
  async main() {
    // Add global debugging functions immediately
    window.debugExtension = {
      checkStorage: () => {
        console.log('[DEBUG] Checking all possible storage locations...');
        // Check if we can find any content in the page
        const allElements = document.querySelectorAll('*');
        console.log('[DEBUG] Total elements on page:', allElements.length);
        
        // Look for any elements that might contain content
        const contentElements = document.querySelectorAll('[class*="content"], [id*="content"], [class*="topic"], [id*="topic"]');
        console.log('[DEBUG] Content-related elements found:', contentElements.length);
        contentElements.forEach((el, i) => {
          if (i < 10) { // Only log first 10
            console.log(`[DEBUG] Element ${i}:`, el.className, el.id);
          }
        });
      }
    };
    
    console.log('[DEBUG] Global debug functions added to window.debugExtension');
    
    /**
     * Safely query element by data attribute
     * This avoids CSS selector syntax errors when attribute value contains quotes or special characters
     * @param {string} selector - Base CSS selector (e.g., '.vocab-magic-meaning-spinner-container' or '[data-text-key]')
     * @param {string} attributeName - The data attribute name (e.g., 'data-text-key' or 'data-text-highlight')
     * @param {string} attributeValue - The attribute value to match
     * @param {Element} root - Root element to search within (default: document)
     * @returns {Element|null} The matching element or null
     */
    const safeQueryByDataAttribute = (selector, attributeName, attributeValue, root = document) => {
      if (!attributeValue) return null;
      
      // Use filtering method to avoid CSS selector syntax errors with quotes or special characters
      // Query all matching elements and filter by exact attribute value
      const allElements = root.querySelectorAll(selector);
      for (const element of allElements) {
        if (element.getAttribute(attributeName) === attributeValue) {
          return element;
        }
      }
      return null;
    };
    
    /**
     * Safely query element by data-text-key attribute (convenience wrapper)
     * @param {string} selector - Base CSS selector
     * @param {string} textKey - The data-text-key value to match
     * @param {Element} root - Root element to search within (default: document)
     * @returns {Element|null} The matching element or null
     */
    const safeQueryByDataTextKey = (selector, textKey, root = document) => {
      return safeQueryByDataAttribute(selector, 'data-text-key', textKey, root);
    };
    
    // Make helper functions globally accessible for use outside main() scope
    window.safeQueryByDataAttribute = safeQueryByDataAttribute;
    window.safeQueryByDataTextKey = safeQueryByDataTextKey;
    
    
    // Global storage key for extension state
    const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
    
    // Page text content variable - initially null
    let pageTextContent = null;
    
    // Make pageTextContent accessible globally for ChatDialog
    window.pageTextContent = pageTextContent;
    
    // Global variables for page summary (persist across dialog open/close)
    window.pageSummary = null;
    window.pageSummaryPossibleQuestions = null;
    
    // Global language variable - fetched from chrome.storage.local (shared across all tabs and domains)
    // Initialize language variable - will be loaded from global storage
    let language = 'WEBSITE_LANGUAGE';
    
    // Load saved language from global storage on initialization
    getSavedLanguage().then((savedLanguage) => {
      language = savedLanguage || 'WEBSITE_LANGUAGE';
      window.language = language;
    }).catch((error) => {
      console.warn('[Content Script] Error loading saved language on init:', error);
      // Set default value on error
      window.language = 'WEBSITE_LANGUAGE';
    });
    
    /**
     * Handle OAuth callback after redirect
     * Checks URL for OAuth parameters, extracts id_token, calls login API, and performs post-login actions
     */
    async function handleOAuthCallback() {
      try {
        const currentUrl = window.location.href;
        const url = new URL(currentUrl);
        
        let idToken = null;
        let returnedState = null;
        
        // Check hash fragment (common in OAuth implicit flow)
        if (url.hash) {
          const hashParams = new URLSearchParams(url.hash.substring(1));
          idToken = hashParams.get('id_token');
          returnedState = hashParams.get('state');
        }
        
        // Check query params as fallback
        if (!idToken) {
          idToken = url.searchParams.get('id_token');
          returnedState = url.searchParams.get('state');
        }
        
        // If no id_token found, this is not an OAuth callback
        if (!idToken) {
          return;
        }
        
        console.log('[OAuthCallback] OAuth callback detected in URL');
        
        // Check for errors in callback
        const error = url.searchParams.get('error') || (url.hash ? new URLSearchParams(url.hash.substring(1)).get('error') : null);
        if (error) {
          const errorDesc = url.searchParams.get('error_description') || (url.hash ? new URLSearchParams(url.hash.substring(1)).get('error_description') : null);
          chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
          console.error('[OAuthCallback] OAuth error:', error, errorDesc);
          
          // Show error banner if available
          if (typeof ErrorBanner !== 'undefined') {
            await ErrorBanner.show(`OAuth error: ${error}${errorDesc ? ' - ' + errorDesc : ''}`);
          }
          
          // Clean up URL
          const cleanUrl = url.origin + url.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          return;
        }
        
        // Verify state
        const stored = await chrome.storage.local.get(['oauth_state']);
        if (stored.oauth_state && stored.oauth_state !== returnedState) {
          chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
          console.error('[OAuthCallback] OAuth state mismatch - possible security issue');
          
          // Show error banner if available
          if (typeof ErrorBanner !== 'undefined') {
            await ErrorBanner.show('OAuth state mismatch - possible security issue');
          }
          
          // Clean up URL
          const cleanUrl = url.origin + url.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          return;
        }
        
        // Clean up stored state
        await chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
        
        console.log('[OAuthCallback] Calling login API with id_token...');
        
        // Import AuthService dynamically
        const { default: AuthService } = await import('../core/services/AuthService.js');
        
        // Call backend API with id_token
        const result = await AuthService.login(idToken);
        
        if (result.success && result.data) {
          // Log the structure before storing
          console.log('[OAuthCallback] Login API response data structure:', JSON.stringify(result.data, null, 2));
          console.log('[OAuthCallback] AccessToken in response:', result.data.accessToken || result.data.access_token ? 'FOUND' : 'NOT FOUND');
          console.log('[OAuthCallback] RefreshToken in response:', result.data.refreshToken ? 'FOUND' : 'NOT FOUND');
          console.log('[OAuthCallback] RefreshTokenExpiresAt in response:', result.data.refreshTokenExpiresAt ? 'FOUND' : 'NOT FOUND');
          
          // Store user account data directly - NO wrapping, NO nesting
          // Store result.data directly as the value for xplaino_userAccountData key
          const dataToStore = result.data; // Direct assignment, no transformation
          await chrome.storage.local.set({ 'xplaino_userAccountData': dataToStore });
          
          // Extract access token from response
          const accessToken = result.data.accessToken || result.data.access_token;
          
          // Store access token in ApiService memory
          if (accessToken) {
            const { default: ApiService } = await import('../core/services/ApiService.js');
            ApiService.setAccessToken(accessToken);
            console.log('[OAuthCallback] Access token stored in ApiService memory');
          }
          
          // Extract refreshToken and refreshTokenExpiresAt from response body
          const refreshToken = result.data.refreshToken;
          const refreshTokenExpiresAt = result.data.refreshTokenExpiresAt;
          
          if (refreshToken) {
            console.log('[OAuthCallback] ✓ RefreshToken found in response body (length:', refreshToken.length, ')');
          } else {
            console.warn('[OAuthCallback] ⚠ RefreshToken not found in response body');
          }
          
          if (refreshTokenExpiresAt) {
            console.log('[OAuthCallback] ✓ RefreshTokenExpiresAt found in response body:', refreshTokenExpiresAt);
          } else {
            console.warn('[OAuthCallback] ⚠ RefreshTokenExpiresAt not found in response body');
          }
          
          // Store exact login API response in xplaino-user-auth-info for access token retrieval
          // The response body already contains refreshToken and refreshTokenExpiresAt
          const authInfoToStore = {
            ...dataToStore
          };
          
          await chrome.storage.local.set({ 'xplaino-user-auth-info': authInfoToStore });
          console.log('[OAuthCallback] Stored login response in xplaino-user-auth-info');
          
          // Validate: Read back immediately to verify structure
          const verifyResult = await chrome.storage.local.get(['xplaino_userAccountData']);
          const storedData = verifyResult['xplaino_userAccountData'];
          console.log('[OAuthCallback] Verification - Stored data structure:', JSON.stringify(storedData, null, 2));
          console.log('[OAuthCallback] Verification - AccessToken accessible:', storedData?.accessToken || storedData?.access_token ? 'YES' : 'NO');
          if (storedData?.accessToken) {
            console.log('[OAuthCallback] Verification - AccessToken value (first 20 chars):', storedData.accessToken.substring(0, 20) + '...');
          } else if (storedData?.access_token) {
            console.log('[OAuthCallback] Verification - AccessToken value (first 20 chars):', storedData.access_token.substring(0, 20) + '...');
          }
          
          // Validate xplaino-user-auth-info storage
          const authInfoResult = await chrome.storage.local.get(['xplaino-user-auth-info']);
          const authInfoData = authInfoResult['xplaino-user-auth-info'];
          console.log('[OAuthCallback] Verification - xplaino-user-auth-info stored:', authInfoData ? 'YES' : 'NO');
          if (authInfoData?.accessToken) {
            console.log('[OAuthCallback] Verification - AccessToken in xplaino-user-auth-info (first 20 chars):', authInfoData.accessToken.substring(0, 20) + '...');
          }
          if (authInfoData?.refreshToken) {
            console.log('[OAuthCallback] Verification - RefreshToken in xplaino-user-auth-info (length):', authInfoData.refreshToken.length);
          }
          if (authInfoData?.refreshTokenExpiresAt) {
            console.log('[OAuthCallback] Verification - RefreshTokenExpiresAt in xplaino-user-auth-info:', authInfoData.refreshTokenExpiresAt);
          }
          
          console.log('[OAuthCallback] Sign-in successful');
          
          // Hide any error banners
          if (typeof ErrorBanner !== 'undefined') {
            ErrorBanner.hide();
          }
          
          // Hide login modal if it's open
          if (typeof LoginModal !== 'undefined') {
            LoginModal.hide();
          }
          
          // Dispatch event to notify other parts of the extension
          window.dispatchEvent(new CustomEvent('user-logged-in', {
            detail: result.data
          }));
          
          // Clean up URL by removing OAuth parameters
          // Remove hash fragment if it contains OAuth params
          let cleanUrl = url.origin + url.pathname;
          
          // Clean up query params
          if (url.search) {
            const searchParams = new URLSearchParams(url.search);
            searchParams.delete('id_token');
            searchParams.delete('state');
            const cleanSearch = searchParams.toString();
            if (cleanSearch) {
              cleanUrl += '?' + cleanSearch;
            }
          }
          
          window.history.replaceState({}, document.title, cleanUrl);
          
          console.log('[OAuthCallback] OAuth callback handled successfully');
        } else {
          throw new Error(result.error || 'Login failed');
        }
      } catch (error) {
        console.error('[OAuthCallback] Error handling OAuth callback:', error);
        
        // Show error banner if available
        if (typeof ErrorBanner !== 'undefined') {
          await ErrorBanner.show(error.message || 'Sign-in failed');
        }
        
        // Clean up URL
        try {
          const url = new URL(window.location.href);
          const cleanUrl = url.origin + url.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
        } catch (e) {
          console.warn('[OAuthCallback] Could not clean up URL:', e);
        }
        
        // Ensure cleanup on error
        await chrome.storage.local.remove(['oauth_state', 'oauth_nonce']).catch(() => {});
      }
    }
    
    // Load access token from storage on initialization
    (async () => {
      try {
        const { default: ApiService } = await import('../core/services/ApiService.js');
        await ApiService.loadAccessTokenFromStorage();
      } catch (error) {
        console.warn('[Content Script] Error loading access token on initialization:', error);
      }
    })();
    
    // Handle OAuth callback early in initialization
    handleOAuthCallback();
    
    // Comprehensive languages list with native names
    const TOP_LANGUAGES = [
      'English', // English
      'Español', // Spanish
      'Français', // French
      'Deutsch', // German
      'Italiano', // Italian
      'Português', // Portuguese
      'Русский', // Russian
      '中文', // Chinese (Simplified)
      '日本語', // Japanese
      '한국어', // Korean
      'العربية', // Arabic
      'हिन्दी', // Hindi
      'Nederlands', // Dutch
      'Türkçe', // Turkish
      'Polski', // Polish
      'Svenska', // Swedish
      'Norsk', // Norwegian
      'Dansk', // Danish
      'Suomi', // Finnish
      'Ελληνικά', // Greek
      'Čeština', // Czech
      'Magyar', // Hungarian
      'Română', // Romanian
      'Български', // Bulgarian
      'Hrvatski', // Croatian
      'Srpski', // Serbian
      'Slovenčina', // Slovak
      'Slovenščina', // Slovenian
      'Українська', // Ukrainian
      'עברית', // Hebrew
      'فارسی', // Persian/Farsi
      'اردو', // Urdu
      'বাংলা', // Bengali
      'தமிழ்', // Tamil
      'తెలుగు', // Telugu
      'मराठी', // Marathi
      'ગુજરાતી', // Gujarati
      'ಕನ್ನಡ', // Kannada
      'മലയാളം', // Malayalam
      'ਪੰਜਾਬੀ', // Punjabi
      'ଓଡ଼ିଆ', // Odia
      'नेपाली', // Nepali
      'සිංහල', // Sinhala
      'ไทย', // Thai
      'Tiếng Việt', // Vietnamese
      'Bahasa Indonesia', // Indonesian
      'Bahasa Melayu', // Malay
      'Filipino', // Filipino
      'Tagalog', // Tagalog
      'မြန်မာ', // Burmese
      'ភាសាខ្មែរ', // Khmer
      'Lao', // Lao
      'Монгол', // Mongolian
      'ქართული', // Georgian
      'Հայերեն', // Armenian
      'Azərbaycan', // Azerbaijani
      'Қазақ', // Kazakh
      'Oʻzbek', // Uzbek
      'Кыргызча', // Kyrgyz
      'Türkmen', // Turkmen
      'Afrikaans', // Afrikaans
      'Kiswahili', // Swahili
      'Yorùbá', // Yoruba
      'Hausa', // Hausa
      'Igbo', // Igbo
      'Zulu', // Zulu
      'Xhosa', // Xhosa
      'Amharic', // Amharic
      'አማርኛ', // Amharic (Ethiopic)
      'Somali', // Somali
      'Kinyarwanda', // Kinyarwanda
      'Luganda', // Luganda
      'Shona', // Shona
      'Malagasy', // Malagasy
      'Maltese', // Maltese
      'Íslenska', // Icelandic
      'Gaeilge', // Irish
      'Cymraeg', // Welsh
      'Brezhoneg', // Breton
      'Català', // Catalan
      'Galego', // Galician
      'Euskara', // Basque
      'Latviešu', // Latvian
      'Lietuvių', // Lithuanian
      'Eesti', // Estonian
      'Shqip', // Albanian
      'Македонски', // Macedonian
      'Bosanski', // Bosnian
      'Esperanto', // Esperanto
      'Interlingua', // Interlingua
      'Lingua Latina', // Latin
      'Klingon', // Klingon (for fun)
      'Toki Pona' // Toki Pona
    ];
    
    /**
     * Show language selection modal if language is 'none'
     */
    /**
     * Get the global language storage key (shared across all tabs and domains)
     * @returns {string} The storage key
     */
    function getLanguageStorageKey() {
      return 'language';
    }
    
    /**
     * Get the saved language preference (global, shared across all tabs and domains)
     * @returns {Promise<string>} The saved language or 'WEBSITE_LANGUAGE' if not found
     */
    async function getSavedLanguage() {
      try {
        const storageKey = getLanguageStorageKey();
        const result = await chrome.storage.local.get([storageKey]);
        // Return 'WEBSITE_LANGUAGE' as default, but keep backward compatibility with 'none'
        return result[storageKey] || 'WEBSITE_LANGUAGE';
      } catch (error) {
        console.warn('[Language Selection] Error getting saved language:', error);
        return 'WEBSITE_LANGUAGE';
      }
    }
    
    /**
     * Save the language preference (global, shared across all tabs and domains)
     * @param {string} language - The language to save
     * @returns {Promise<void>}
     */
    async function saveLanguage(language) {
      try {
        const storageKey = getLanguageStorageKey();
        await chrome.storage.local.set({ [storageKey]: language });
        console.log('[Language Selection] Language saved globally:', language);
      } catch (error) {
        console.error('[Language Selection] Error saving language:', error);
      }
    }
    
    function showLanguageSelectionModal() {
      // Remove existing modal if any
      const existingModal = document.getElementById('prefered-language-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      // Hide close button when modal opens
      hideCloseButton();
      
      // Blur ask-about-page button and banner when modal is visible
      blurAskAboutPageButton();
      blurBanner();
      
      // Create overlay (transparent, non-blocking - similar to chat dialog)
      const overlay = document.createElement('div');
      overlay.id = 'prefered-language-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        z-index: 2147483647;
        display: flex;
        justify-content: flex-end;
        align-items: flex-start;
        pointer-events: auto;
        opacity: 1;
        isolation: isolate;
      `;
      
      // Blur chat dialog when preferred-language modal is open
      const chatDialog = document.getElementById('vocab-chat-dialog');
      if (chatDialog) {
        chatDialog.style.filter = 'blur(4px)';
        chatDialog.style.opacity = '0.6';
        chatDialog.style.transition = 'filter 0.3s ease, opacity 0.3s ease';
      }
      
      // Function to close modal with slide-out animation (going outside the page to the right)
      function closeModalWithAnimation() {
        // Slide out to the right and fade out modal
        modal.style.transform = 'translateX(100%)';
        modal.style.opacity = '0';
        
        // Notify popup to show settings button when modal is closed
        try {
          chrome.runtime.sendMessage({
            type: 'LANGUAGE_MODAL_CLOSED'
          }).catch(() => {
            // Popup might not be open, ignore error
          });
        } catch (error) {
          // Ignore if popup is not available
        }
        
        // Remove overlay after animation completes (match 0.4s animation duration)
        setTimeout(() => {
          overlay.remove();
          // Remove dropdown list from body when modal closes
          if (dropdownList && dropdownList.parentNode) {
            dropdownList.remove();
          }
          // Restore ask-about-page button and banner after modal is closed
          restoreAskAboutPageButton();
          restoreBanner();
          // Show close button when modal is closed
          showCloseButton();
          // Restore chat dialog (remove blur)
          const chatDialog = document.getElementById('vocab-chat-dialog');
          if (chatDialog) {
            chatDialog.style.filter = '';
            chatDialog.style.opacity = '';
          }
        }, 400);
      }
      
      // Create modal container (small dimensions, aligned with close button top)
      const modal = document.createElement('div');
      modal.id = 'prefered-language-modal';
      modal.style.cssText = `
        background-color: white !important;
        border-radius: 30px 0 0 30px;
        padding: 20px;
        max-width: 400px;
        width: auto;
        min-width: 300px;
        height: auto;
        max-height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
        gap: 0;
        box-shadow: -10px 0 40px rgba(149, 39, 245, 0.3), -5px 0 20px rgba(149, 39, 245, 0.2);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        position: fixed;
        top: 78px;
        right: 0;
        transform: translateX(100%);
        opacity: 0;
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
        will-change: transform, opacity;
        overflow-y: visible;
        overflow-x: visible;
        pointer-events: auto;
        z-index: 2147483648;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        font-size: 16px !important;
        line-height: 1.5 !important;
        color: #000 !important;
      `;
      
      // Prevent double-click and text selection on modal
      modal.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      modal.addEventListener('selectstart', (e) => {
        e.preventDefault();
        return false;
      });
      
      modal.addEventListener('mousedown', (e) => {
        // Allow input field to work normally
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
          return true;
        }
        // Prevent text selection for other elements
        if (window.getSelection) {
          window.getSelection().removeAllRanges();
        }
      });
      
      // First container: Heading (positioned lower than minimize button)
      const headingContainer = document.createElement('div');
      headingContainer.style.cssText = `
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 8px;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        margin-top: 20px;
        margin-bottom: 30px;
        padding-bottom: 20px;
      `;
      
      // Settings heading
      const brandingHeading = document.createElement('h2');
      brandingHeading.style.cssText = `
        margin: 0 !important;
        font-size: 28px !important;
        font-weight: 600 !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        color: #9527F5 !important;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        pointer-events: none;
        display: flex !important;
        align-items: center;
        justify-content: center;
        gap: 8px;
        text-shadow: none !important;
        background: transparent !important;
        opacity: 1 !important;
        visibility: visible !important;
      `;
      brandingHeading.textContent = 'Settings';
      
      // Subheading
      const subHeading = document.createElement('p');
      subHeading.textContent = 'Choose your native language';
      subHeading.style.cssText = `
        margin: 0 !important;
        margin-bottom: 8px !important;
        font-size: 16px !important;
        font-weight: 400 !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        color: #000000 !important;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        pointer-events: none;
        text-shadow: none !important;
        background: transparent !important;
        opacity: 1 !important;
        visibility: visible !important;
      `;
      
      // Prevent double-click on headings
      brandingHeading.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      subHeading.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      headingContainer.appendChild(brandingHeading);
      
      // Second container: Tabs with sliding indicator
      const tabsContainer = document.createElement('div');
      tabsContainer.style.cssText = `
        position: relative;
        display: flex;
        gap: 10px;
        border-radius: 10px;
        background-color: #f5f5f5;
        padding: 4px;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      
      // Sliding indicator background
      const slidingIndicator = document.createElement('div');
      slidingIndicator.id = 'vocab-language-sliding-indicator';
      slidingIndicator.style.cssText = `
        position: absolute;
        top: 4px;
        left: 4px;
        height: calc(100% - 8px);
        background-color: #9333ea;
        border-radius: 10px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1;
      `;
      
      const customTab = document.createElement('button');
      customTab.textContent = 'Fixed';
      customTab.id = 'vocab-language-custom-tab';
      customTab.style.cssText = `
        flex: 1;
        padding: 12px 20px;
        border: none;
        background-color: transparent;
        color: white;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        position: relative;
        z-index: 2;
        transition: color 0.3s;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      
      // Prevent double-click on tabs
      customTab.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      const websiteTab = document.createElement('button');
      websiteTab.textContent = 'Dynamic';
      websiteTab.id = 'vocab-language-website-tab';
      websiteTab.style.cssText = `
        flex: 1;
        padding: 12px 20px;
        border: none;
        background-color: transparent;
        color: #666;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        position: relative;
        z-index: 2;
        transition: color 0.3s;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      
      // Prevent double-click on tabs
      websiteTab.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      // Function to update sliding indicator position
      function updateSlidingIndicator(targetTab) {
        // Use offsetLeft for relative positioning within the container
        const leftOffset = targetTab.offsetLeft;
        const tabWidth = targetTab.offsetWidth;
        
        slidingIndicator.style.width = `${tabWidth}px`;
        slidingIndicator.style.transform = `translateX(${leftOffset}px)`;
      }
      
      // Initialize sliding indicator position for custom tab
      // Use requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        updateSlidingIndicator(customTab);
      });
      
      // Tab content container
      const tabContentContainer = document.createElement('div');
      tabContentContainer.id = 'vocab-language-tab-content';
      tabContentContainer.style.cssText = `
        display: flex;
        justify-content: center;
        align-items: center;
        height: 150px;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      
      // Custom tab content
      const customTabContent = document.createElement('div');
      customTabContent.id = 'vocab-language-custom-content';
      customTabContent.style.cssText = `
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      
      // Preferred language text (green text above input)
      const preferredLanguageText = document.createElement('div');
      preferredLanguageText.id = 'vocab-preferred-language-text';
      preferredLanguageText.style.cssText = `
        width: 100%;
        text-align: center;
        color: #16a34a;
        font-size: 14px;
        margin-bottom: 12px;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      
      // Function to update preferred language text
      function updatePreferredLanguageText(lang) {
        if (lang && lang.trim() !== '') {
          preferredLanguageText.innerHTML = `Your preferred language is: <strong>"${lang}"</strong>`;
        } else {
          preferredLanguageText.innerHTML = '';
        }
      }
      
      // Dropdown container
      const dropdownContainer = document.createElement('div');
      dropdownContainer.style.cssText = `
        width: 80%;
        position: relative;
        z-index: 1;
      `;
      
      // Dropdown input (readonly - click only, no typing)
      const dropdownInput = document.createElement('input');
      dropdownInput.type = 'text';
      dropdownInput.id = 'vocab-language-dropdown-input';
      dropdownInput.placeholder = 'Click to select a language...';
      dropdownInput.readOnly = true;
      dropdownInput.style.cssText = `
        width: 100%;
        padding: 12px 45px 12px 16px;
        border: 2px solid #e5e5e5;
        border-radius: 8px;
        font-size: 16px !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        font-weight: 400 !important;
        box-sizing: border-box;
        outline: none;
        transition: border-color 0.2s;
        background-color: white !important;
        color: black !important;
        text-shadow: none !important;
        cursor: pointer;
      `;
      // Prevent text selection in input field
      dropdownInput.style.userSelect = 'none';
      dropdownInput.style.webkitUserSelect = 'none';
      
      // Force white background and black text using setProperty for stronger enforcement
      dropdownInput.style.setProperty('background-color', 'white', 'important');
      dropdownInput.style.setProperty('color', 'black', 'important');
      dropdownInput.style.setProperty('background', 'white', 'important');
      
      // Dropdown icon (inside input box)
      const dropdownIcon = document.createElement('div');
      dropdownIcon.id = 'vocab-language-dropdown-icon';
      dropdownIcon.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M5 7.5L10 12.5L15 7.5" stroke="#666" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      dropdownIcon.style.cssText = `
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        transition: transform 0.2s;
        z-index: 2;
      `;
      
      // Track keyboard navigation
      let selectedIndex = -1;
      let filteredLanguages = [];
      
      // Dropdown list (positioned with highest z-index to appear above modal)
      const dropdownList = document.createElement('div');
      dropdownList.id = 'vocab-language-dropdown-list';
      dropdownList.style.cssText = `
        position: fixed !important;
        background-color: white !important;
        border-left: 2px solid #e5e5e5;
        border-right: 2px solid #e5e5e5;
        border-top: none;
        border-bottom: 2px solid #e5e5e5;
        border-radius: 0 0 8px 8px;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 2147483649 !important;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        isolation: isolate;
        font-size: 16px !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        font-weight: 400 !important;
        line-height: 1.5 !important;
      `;
      
      // Prevent double-click and text selection on dropdown list
      dropdownList.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      dropdownList.addEventListener('selectstart', (e) => {
        e.preventDefault();
        return false;
      });
      
      // Website language tab content
      const websiteTabContent = document.createElement('div');
      websiteTabContent.id = 'vocab-language-website-content';
      websiteTabContent.style.cssText = `
        width: 100%;
        display: none;
        flex-direction: column;
        gap: 15px;
        align-items: center;
        text-align: center;
        color: #666;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        height: 100%;
        justify-content: center;
        font-size: 18px;
      `;
      websiteTabContent.textContent = 'Explanations will be in the language that is used in the webpage';
      
      // Prevent double-click and text selection on website tab content
      websiteTabContent.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      websiteTabContent.addEventListener('selectstart', (e) => {
        e.preventDefault();
        return false;
      });
      
      // Track active tab
      let activeTab = 'fixed'; // Default to fixed tab
      
      // Tab click handlers with smooth sliding animation
      customTab.addEventListener('click', () => {
        activeTab = 'fixed';
        updateSlidingIndicator(customTab);
        customTab.style.color = 'white';
        websiteTab.style.color = '#666';
        customTabContent.style.display = 'flex';
        websiteTabContent.style.display = 'none';
        // Update button state when switching tabs
        updateButtonState();
      });
      
      websiteTab.addEventListener('click', () => {
        activeTab = 'dynamic';
        updateSlidingIndicator(websiteTab);
        websiteTab.style.color = 'white';
        customTab.style.color = '#666';
        customTabContent.style.display = 'none';
        websiteTabContent.style.display = 'flex';
        // Update button state when switching tabs
        updateButtonState();
      });
      
      // Function to select language from dropdown (auto-saves)
      async function selectLanguage(lang) {
        // If "As per website" is selected, save as 'WEBSITE_LANGUAGE' for API
        const languageToSave = lang === 'As per website' ? 'WEBSITE_LANGUAGE' : lang;
        dropdownInput.value = lang;
        dropdownList.style.display = 'none';
        selectedIndex = -1;
        // Reset dropdown icon rotation
        dropdownIcon.style.transform = 'translateY(-50%) rotate(0deg)';
        
        // Auto-save language preference
        await saveLanguage(languageToSave);
        language = languageToSave;
        window.language = languageToSave;
        console.log('[Language Selection] Language auto-saved:', languageToSave);
        
        // Close modal after saving
        closeModalWithAnimation();
      }
      
      // Function to highlight selected item
      function highlightItem(index) {
        const items = dropdownList.querySelectorAll('div');
        items.forEach((item, i) => {
          if (i === index) {
            item.style.backgroundColor = '#e9d5ff';
            item.style.color = '#9333ea';
            // Scroll into view
            item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          } else {
            item.style.setProperty('background-color', 'white', 'important');
            item.style.setProperty('color', 'black', 'important');
          }
        });
      }
      
      // Populate dropdown list
      function populateDropdownList(filter = '') {
        dropdownList.innerHTML = '';
        filteredLanguages = [];
        selectedIndex = -1;
        
        // Always add "As per website" as first option
        const AS_PER_WEBSITE = 'As per website';
        
        // Since input is readonly, filter is not used for typing
        // Always show "As per website" + all languages
        let filtered = [AS_PER_WEBSITE, ...TOP_LANGUAGES];
        
        // Store filtered languages for keyboard navigation
        filteredLanguages = [...filtered];
        
        // Add filtered languages (no need to check for new language since input is readonly)
        filtered.forEach((lang, index) => {
          const item = document.createElement('div');
          item.textContent = lang;
          item.setAttribute('data-index', index);
          item.style.cssText = `
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            background-color: white !important;
            color: black !important;
            font-size: 16px !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
            font-weight: 400 !important;
            line-height: 1.5 !important;
          `;
          // Force white background and black text using setProperty for stronger enforcement
          item.style.setProperty('background-color', 'white', 'important');
          item.style.setProperty('color', 'black', 'important');
          item.style.setProperty('font-size', '16px', 'important');
          item.style.setProperty('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif', 'important');
          item.style.setProperty('font-weight', '400', 'important');
          item.style.setProperty('line-height', '1.5', 'important');
          item.addEventListener('mouseenter', () => {
            // Reset all highlights
            const items = dropdownList.querySelectorAll('div');
            items.forEach(i => {
              i.style.setProperty('background-color', 'white', 'important');
              i.style.setProperty('color', 'black', 'important');
            });
            item.style.backgroundColor = '#e9d5ff';
            item.style.color = '#9333ea';
            selectedIndex = index;
          });
          item.addEventListener('mouseleave', () => {
            if (selectedIndex !== index) {
              item.style.setProperty('background-color', 'white', 'important');
              item.style.setProperty('color', 'black', 'important');
            }
          });
          item.addEventListener('click', () => {
            selectLanguage(lang);
          });
          // Prevent double-click and text selection
          item.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
          });
          item.addEventListener('selectstart', (e) => {
            e.preventDefault();
            return false;
          });
          dropdownList.appendChild(item);
        });
      }
      
      // Function to update button based on tab and language
      function updateButtonState() {
        const hasLanguage = dropdownInput.value.trim() !== '';
        
        if (activeTab === 'fixed') {
          // Fixed tab - always show button since "As per website" is a valid selection
            saveButton.style.display = 'block';
            saveButton.textContent = 'Save and Close';
            saveButton.style.backgroundColor = '#9333ea';
            saveButton.style.color = 'white';
            saveButton.style.border = 'none';
        } else {
          // Dynamic tab = "Save and Close" with solid purple background
          saveButton.style.display = 'block';
          saveButton.textContent = 'Save and Close';
          saveButton.style.backgroundColor = '#9333ea';
          saveButton.style.color = 'white';
          saveButton.style.border = 'none';
        }
      }
      
      // Keyboard navigation handler
      dropdownInput.addEventListener('keydown', (e) => {
        if (!dropdownList.style.display || dropdownList.style.display === 'none') {
          return;
        }
        
        const items = dropdownList.querySelectorAll('div');
        if (items.length === 0) return;
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedIndex = (selectedIndex + 1) % items.length;
          highlightItem(selectedIndex);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedIndex = selectedIndex <= 0 ? items.length - 1 : selectedIndex - 1;
          highlightItem(selectedIndex);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedIndex >= 0 && selectedIndex < filteredLanguages.length) {
            selectLanguage(filteredLanguages[selectedIndex]);
          }
        } else if (e.key === 'Escape') {
          dropdownList.style.display = 'none';
          selectedIndex = -1;
          // Reset dropdown icon rotation
          dropdownIcon.style.transform = 'translateY(-50%) rotate(0deg)';
        }
      });
      
      // Function to update dropdown position (for fixed positioning)
      function updateDropdownPosition() {
        const inputRect = dropdownInput.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const dropdownHeight = 300; // max-height of dropdown
        const spaceBelow = viewportHeight - inputRect.bottom;
        const spaceAbove = inputRect.top;
        
        dropdownList.style.left = `${inputRect.left}px`;
        dropdownList.style.width = `${inputRect.width}px`;
        
        // If there's not enough space below, show dropdown above the input
        if (spaceBelow < dropdownHeight && spaceAbove > spaceBelow) {
          dropdownList.style.top = `${inputRect.top - Math.min(dropdownHeight, spaceAbove)}px`;
          dropdownList.style.maxHeight = `${Math.min(dropdownHeight, spaceAbove - 10)}px`;
          dropdownList.style.borderRadius = '8px 8px 0 0';
          dropdownList.style.borderTop = '2px solid #e5e5e5';
          dropdownList.style.borderBottom = 'none';
        } else {
          dropdownList.style.top = `${inputRect.bottom}px`;
          dropdownList.style.maxHeight = `${Math.min(dropdownHeight, spaceBelow - 10)}px`;
          dropdownList.style.borderRadius = '0 0 8px 8px';
          dropdownList.style.borderTop = 'none';
          dropdownList.style.borderBottom = '2px solid #e5e5e5';
        }
      }
      
      // Dropdown input handlers
      // Click handler to open dropdown (since input is readonly)
      dropdownInput.addEventListener('click', () => {
        dropdownInput.style.borderColor = '#9333ea';
        const currentValue = dropdownInput.value;
        populateDropdownList(currentValue);
        updateDropdownPosition();
        dropdownList.style.display = 'block';
        selectedIndex = -1;
        // Rotate dropdown icon
        dropdownIcon.style.transform = 'translateY(-50%) rotate(180deg)';
      });
      
      dropdownInput.addEventListener('focus', () => {
        dropdownInput.style.borderColor = '#9333ea';
        const currentValue = dropdownInput.value;
        populateDropdownList(currentValue);
        updateDropdownPosition();
        dropdownList.style.display = 'block';
        selectedIndex = -1;
        // Rotate dropdown icon
        dropdownIcon.style.transform = 'translateY(-50%) rotate(180deg)';
      });
      
      dropdownInput.addEventListener('blur', () => {
        dropdownInput.style.borderColor = '#e5e5e5';
        // Delay hiding to allow click events
        setTimeout(() => {
          dropdownList.style.display = 'none';
          selectedIndex = -1;
          // Reset dropdown icon rotation
          dropdownIcon.style.transform = 'translateY(-50%) rotate(0deg)';
        }, 200);
      });
      
      // Remove input event handler since field is readonly
      // Users can only select from dropdown list
      
      // Close dropdown when clicking outside
      let clickHandler = (e) => {
        if (!dropdownContainer.contains(e.target) && !dropdownList.contains(e.target)) {
          dropdownList.style.display = 'none';
        }
      };
      document.addEventListener('click', clickHandler);
      
      // Update dropdown position on scroll/resize
      window.addEventListener('scroll', updateDropdownPosition, true);
      window.addEventListener('resize', updateDropdownPosition);
      
      // Initial population - show all languages
      populateDropdownList('');
      
      // Set default value to "As per website"
      dropdownInput.value = 'As per website';
      
      dropdownContainer.appendChild(dropdownInput);
      dropdownContainer.appendChild(dropdownIcon);
      // Append dropdown list to overlay (as sibling of modal) for proper z-index stacking
      // This ensures it appears above the modal despite the overlay's isolation context
      customTabContent.appendChild(preferredLanguageText);
      customTabContent.appendChild(dropdownContainer);
      
      tabsContainer.appendChild(slidingIndicator);
      tabsContainer.appendChild(customTab);
      tabsContainer.appendChild(websiteTab);
      tabContentContainer.appendChild(customTabContent);
      tabContentContainer.appendChild(websiteTabContent);
      
      // Third container: Save and Close button
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      `;
      const saveButton = document.createElement('button');
      saveButton.textContent = 'Save and Close';
      saveButton.style.cssText = `
        padding: 14px 32px;
        background-color: #9333ea;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        display: none;
      `;
      
      // Prevent double-click on save button
      saveButton.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      saveButton.addEventListener('mouseenter', () => {
        // Only change background on hover if it's a solid purple button
        if (saveButton.style.backgroundColor === 'rgb(147, 51, 234)' || saveButton.style.backgroundColor === '#9333ea') {
          saveButton.style.backgroundColor = '#7e22ce';
        }
      });
      saveButton.addEventListener('mouseleave', () => {
        // Restore original background
        updateButtonState();
      });
      saveButton.addEventListener('click', async () => {
        let selectedLanguage = 'WEBSITE_LANGUAGE';
        
        // Check which tab is active
        if (activeTab === 'fixed') {
          // Fixed tab is selected
          const inputValue = dropdownInput.value.trim();
          // If "As per website" is selected, save as 'WEBSITE_LANGUAGE'
          selectedLanguage = inputValue === 'As per website' ? 'WEBSITE_LANGUAGE' : (inputValue || 'WEBSITE_LANGUAGE');
        } else {
          // Dynamic tab is selected - save as "dynamic" to global storage
          selectedLanguage = 'dynamic';
        }
        
        // Save language preference to global storage (shared across all tabs and domains)
        await saveLanguage(selectedLanguage);
        
        language = selectedLanguage;
        window.language = selectedLanguage;
        
        // Close modal with animation
        closeModalWithAnimation();
        
        // Show ask-about-page button again after modal is closed
        // Check extension state and show button if enabled
        chrome.storage.local.get([GLOBAL_STORAGE_KEY]).then((result) => {
          const isEnabled = result[GLOBAL_STORAGE_KEY] ?? true; // Default to true if not set
          if (isEnabled) {
            showCloseButton();
          }
        });
        
        console.log('[Language Selection] Language saved:', selectedLanguage);
      });
      
      // Initialize button state
      updateButtonState();
      buttonContainer.appendChild(saveButton);
      
      // Assemble modal (only heading and dropdown, no tabs or buttons)
      modal.appendChild(headingContainer);
      // Add dropdown directly to modal (from customTabContent)
      const dropdownWrapper = document.createElement('div');
      dropdownWrapper.style.cssText = `
        width: calc(100% - 40px);
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        justify-content: center;
        margin-top: 0;
        margin-left: 20px;
        margin-right: 20px;
        margin-bottom: 20px;
      `;
      dropdownWrapper.appendChild(subHeading);
      dropdownWrapper.appendChild(dropdownContainer);
      modal.appendChild(dropdownWrapper);
      
      overlay.appendChild(modal);
      // Append dropdown list to overlay as sibling of modal for proper z-index stacking
      // This ensures it appears above the modal within the same stacking context
      overlay.appendChild(dropdownList);
      document.body.appendChild(overlay);
      
      // Force a reflow to ensure the modal is positioned before animation starts
      void overlay.offsetWidth;
      
      // Close modal when clicking outside (on overlay)
      overlay.addEventListener('click', (e) => {
        // Only close if clicking directly on overlay, not on modal
        if (e.target === overlay) {
          closeModalWithAnimation();
        }
      });
      
      // Prevent modal clicks from closing
      modal.addEventListener('click', (e) => {
        e.stopPropagation();
      });
      
      // Trigger slide-in animation from right
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          overlay.style.opacity = '1';
          modal.style.transform = 'translateX(0)';
          modal.style.opacity = '1';
        });
      });
      
      // Load saved language for current domain and populate the input
      getSavedLanguage().then((savedLanguage) => {
        if (savedLanguage && savedLanguage !== 'WEBSITE_LANGUAGE' && savedLanguage !== 'none' && savedLanguage !== 'dynamic') {
          // Populate input with saved language
          dropdownInput.value = savedLanguage;
        } else if (savedLanguage === 'WEBSITE_LANGUAGE' || savedLanguage === 'none') {
          // Show "As per website" when saved language is 'WEBSITE_LANGUAGE' or 'none' (for backward compatibility)
          dropdownInput.value = 'As per website';
        } else if (savedLanguage === 'dynamic') {
          // Switch to Dynamic tab if dynamic is selected
          activeTab = 'dynamic';
          websiteTab.style.color = 'white';
          customTab.style.color = '#666';
          customTabContent.style.display = 'none';
          websiteTabContent.style.display = 'flex';
          // Update sliding indicator position
          requestAnimationFrame(() => {
            updateSlidingIndicator(websiteTab);
          });
        }
      }).catch((error) => {
        console.warn('[Language Selection] Error loading saved language:', error);
      });
      
      // Update button state after loading saved language
      updateButtonState();
      
      // Notify popup to hide settings button when modal is open
      try {
        chrome.runtime.sendMessage({
          type: 'LANGUAGE_MODAL_OPENED'
        }).catch(() => {
          // Popup might not be open, ignore error
        });
      } catch (error) {
        // Ignore if popup is not available
      }
      
      // Close on overlay click (outside modal)
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          // Don't close on overlay click - require save button
        }
      });
    }
    
    // Step 1: First check if Chrome extension is enabled
    /**
     * Show enable extension dialog (similar to preferred-language-modal)
     * This dialog appears when extension is disabled from power button
     */
    function showEnableExtensionDialog() {
      // Remove existing dialog if any
      const existingDialog = document.getElementById('enable-extension-dialog');
      if (existingDialog) {
        existingDialog.remove();
      }
      
      // Remove existing overlay if any
      const existingOverlay = document.getElementById('enable-extension-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      // Create overlay (transparent, non-blocking)
      const overlay = document.createElement('div');
      overlay.id = 'enable-extension-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        z-index: 2147483647;
        display: flex;
        justify-content: flex-end;
        align-items: flex-start;
        pointer-events: auto;
        opacity: 1;
        isolation: isolate;
      `;
      
      // Function to close dialog
      function closeDialog() {
        dialog.style.transform = 'translateX(100%)';
        dialog.style.opacity = '0';
        
        setTimeout(() => {
          overlay.remove();
        }, 400);
      }
      
      // Create dialog container (similar to preferred-language-modal)
      const dialog = document.createElement('div');
      dialog.id = 'enable-extension-dialog';
      dialog.style.cssText = `
        background-color: white !important;
        border-radius: 30px;
        padding: 40px;
        max-width: 400px;
        width: auto;
        min-width: 300px;
        height: auto;
        max-height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: -10px 0 40px rgba(149, 39, 245, 0.3), -5px 0 20px rgba(149, 39, 245, 0.2);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        position: fixed;
        top: 23px;
        right: 20px;
        transform: translateX(100%);
        opacity: 0;
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
        will-change: transform, opacity;
        overflow-y: visible;
        overflow-x: visible;
        pointer-events: auto;
        z-index: 2147483648;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        font-size: 16px !important;
        line-height: 1.5 !important;
        color: #000 !important;
      `;
      
      // Create arrow pointing upward (to home-options-container) - centered
      const arrowContainer = document.createElement('div');
      arrowContainer.style.cssText = `
        position: absolute;
        top: -20px;
        left: 50%;
        transform: translateX(-50%);
        width: 0px;
        height: 0px;
        border-left: 15px solid transparent;
        border-right: 15px solid transparent;
        border-bottom: 20px solid white;
        filter: drop-shadow(rgba(149, 39, 245, 0.2) 0px -2px 4px);
      `;
      dialog.appendChild(arrowContainer);
      
      // Heading
      const heading = document.createElement('h2');
      heading.style.cssText = `
        margin: 0 !important;
        font-size: 24px !important;
        font-weight: 600 !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        color: #9527F5 !important;
        user-select: none;
        text-align: center;
      `;
      heading.textContent = 'Extension Disabled';
      dialog.appendChild(heading);
      
      // Message with animated upward arrow
      const message = document.createElement('p');
      message.style.cssText = `
        margin: 0 !important;
        font-size: 16px !important;
        font-weight: 400 !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        color: #000000 !important;
        text-align: center;
        line-height: 1.5;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      `;
      
      // Create animated upward arrow icon
      const arrowIcon = document.createElement('span');
      arrowIcon.style.cssText = `
        display: inline-flex;
        align-items: center;
        justify-content: center;
        animation: arrowBounce 1.5s ease-in-out infinite;
      `;
      
      // Add CSS animation for arrow bounce
      if (!document.getElementById('enable-extension-arrow-animation')) {
        const style = document.createElement('style');
        style.id = 'enable-extension-arrow-animation';
        style.textContent = `
          @keyframes arrowBounce {
            0%, 100% {
              transform: translateY(0);
            }
            50% {
              transform: translateY(-8px);
            }
          }
        `;
        document.head.appendChild(style);
      }
      
      arrowIcon.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 4L12 20M12 4L6 10M12 4L18 10" stroke="#9527F5" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      
      const messageText = document.createTextNode('Here on the top you can enable the extension');
      message.appendChild(arrowIcon);
      message.appendChild(messageText);
      dialog.appendChild(message);
      
      // Close button (X icon)
      const closeButton = document.createElement('button');
      closeButton.style.cssText = `
        position: absolute;
        top: 15px;
        right: 15px;
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s;
        padding: 0;
      `;
      closeButton.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M18 6L6 18M6 6L18 18" stroke="#666" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      closeButton.addEventListener('click', closeDialog);
      closeButton.addEventListener('mouseenter', () => {
        closeButton.style.backgroundColor = '#f0f0f0';
      });
      closeButton.addEventListener('mouseleave', () => {
        closeButton.style.backgroundColor = 'transparent';
      });
      dialog.appendChild(closeButton);
      
      // Append dialog to overlay
      overlay.appendChild(dialog);
      
      // Append overlay to body
      document.body.appendChild(overlay);
      
      // Trigger slide-in animation
      setTimeout(() => {
        dialog.style.transform = 'translateX(0)';
        dialog.style.opacity = '1';
      }, 10);
      
      // Close on overlay click (outside dialog)
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeDialog();
        }
      });
    }
    
    /**
     * Hide enable extension dialog
     */
    function hideEnableExtensionDialog() {
      const dialog = document.getElementById('enable-extension-dialog');
      const overlay = document.getElementById('enable-extension-overlay');
      
      if (dialog) {
        dialog.style.transform = 'translateX(100%)';
        dialog.style.opacity = '0';
      }
      
      if (overlay) {
        setTimeout(() => {
          overlay.remove();
        }, 400);
      }
    }
    
    // Step 2: If enabled, check preferred language from global storage
    // Step 3: Only show modal if extension is enabled AND language is not defined (none or dynamic)
    chrome.storage.local.get([GLOBAL_STORAGE_KEY]).then((result) => {
      const isEnabled = result[GLOBAL_STORAGE_KEY] ?? true; // Default to true if not set
      
      // If extension is disabled, don't show modal
      if (!isEnabled) {
        console.log('[Content Script] Extension is disabled, not showing language modal');
        return;
      }
      
      // Extension is enabled, now check preferred language
      getSavedLanguage().then((savedLanguage) => {
        // Set the language variable but don't automatically show modal on page load
        // Modal should only be shown when user explicitly requests it (e.g., via close button or settings)
        // Convert 'none' to 'WEBSITE_LANGUAGE' for backward compatibility
        const normalizedLanguage = (savedLanguage === 'none') ? 'WEBSITE_LANGUAGE' : savedLanguage;
        language = normalizedLanguage;
        window.language = normalizedLanguage;
        console.log('[Content Script] Language loaded:', normalizedLanguage);
      }).catch((error) => {
        console.error('[Content Script] Error checking saved language:', error);
        // Set default value on error
        language = 'WEBSITE_LANGUAGE';
        window.language = 'WEBSITE_LANGUAGE';
      });
    }).catch((error) => {
      console.error('[Content Script] Error checking extension state:', error);
      // If there's an error checking state, don't show modal to be safe
    });
    
    /**
     * Fetch page text content in a separate thread
     */
    async function fetchPageTextContent() {
      try {
        console.log('[Content Script] Starting to fetch page text content...');
        
        // Use a web worker or setTimeout to run in a separate thread
        // For simplicity, we'll use setTimeout with 0 delay to run after current execution
        await new Promise(resolve => setTimeout(resolve, 0));
        
        // Get all text content from the page
        const pageText = document.body.innerText || document.body.textContent || '';
        
        // Store as JSON
        pageTextContent = JSON.stringify({
          text: pageText,
          timestamp: new Date().toISOString(),
          url: window.location.href,
          title: document.title
        });
        
        // Update global reference
        window.pageTextContent = pageTextContent;
        
        console.log('[Content Script] Page text content fetched and stored. Length:', pageText.length);
        console.log('[Content Script] pageTextContent variable:', pageTextContent);
        
        // Check if extension is enabled before showing the button
        const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
        const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
        const isEnabled = result[GLOBAL_STORAGE_KEY] ?? true; // Default to true if not set
        
        // Only show the button if extension is enabled
        if (isEnabled) {
          showCloseButton();
        } else {
          console.log('[Content Script] Extension is disabled, not showing home options button');
        }
      } catch (error) {
        console.error('[Content Script] Error fetching page text content:', error);
      }
    }
    
    
    /**
     * Show close button
     */
    function showCloseButton() {
      const button = document.getElementById('home-options-btn');
      if (!button) {
        return;
      }
      
      const container = button.closest('.home-options-container');
      if (container) {
        container.style.display = 'flex';
        // Force a reflow to ensure display is set before adding visible class
        void container.offsetHeight;
        container.classList.add('home-options-container-visible');
      button.style.opacity = '0.95';
      }
      
      console.log('[Content Script] Home options button shown');
    }
    
    /**
     * Hide close button
     */
    function hideCloseButton() {
      const button = document.getElementById('home-options-btn');
      if (!button) {
        return;
      }
      
      const container = button.closest('.home-options-container');
      if (container) {
        container.classList.remove('home-options-container-visible');
        // Wait for animation to complete before hiding
        setTimeout(() => {
          if (container && !container.classList.contains('home-options-container-visible')) {
            container.style.display = 'none';
          }
        }, 400); // Match animation duration
      }
      
      console.log('[Content Script] Home options button hidden');
    }
    
    /**
     * Blur ask-about-page button (make it non-accessible while modal is visible)
     */
    function blurAskAboutPageButton() {
      const button = document.getElementById('vocab-ask-about-page-btn');
      if (!button) {
        return;
      }
      
      // Store original state if not already stored
      if (!button.dataset.originalFilter) {
        button.dataset.originalFilter = button.style.filter || 'none';
        button.dataset.originalPointerEvents = button.style.pointerEvents || '';
      }
      
      // Apply blur and make non-accessible
      button.style.filter = 'blur(4px)';
      button.style.pointerEvents = 'none';
      button.style.opacity = '0.5';
    }
    
    /**
     * Restore ask-about-page button (remove blur when modal is closed)
     */
    function restoreAskAboutPageButton() {
      const button = document.getElementById('vocab-ask-about-page-btn');
      if (!button) {
        return;
      }
      
      // Restore original state
      if (button.dataset.originalFilter) {
        button.style.filter = button.dataset.originalFilter === 'none' ? '' : button.dataset.originalFilter;
        button.style.pointerEvents = button.dataset.originalPointerEvents || '';
        button.style.opacity = '';
        delete button.dataset.originalFilter;
        delete button.dataset.originalPointerEvents;
      }
    }
    
    /**
     * Blur banner (when modal is open)
     */
    function blurBanner() {
      const banner = BannerModule.bannerContainer;
      if (!banner) {
        return;
      }
      
      // Store original state if not already stored
      if (!banner.dataset.originalFilter) {
        banner.dataset.originalFilter = banner.style.filter || 'none';
        banner.dataset.originalPointerEvents = banner.style.pointerEvents || '';
        banner.dataset.originalOpacity = banner.style.opacity || '';
      }
      
      // Apply blur and make non-accessible
      banner.style.filter = 'blur(4px)';
      banner.style.pointerEvents = 'none';
      banner.style.opacity = '0.5';
    }
    
    /**
     * Restore banner (remove blur when modal is closed)
     */
    function restoreBanner() {
      const banner = BannerModule.bannerContainer;
      if (!banner) {
        return;
      }
      
      // Restore original state
      if (banner.dataset.originalFilter) {
        banner.style.filter = banner.dataset.originalFilter === 'none' ? '' : banner.dataset.originalFilter;
        banner.style.pointerEvents = banner.dataset.originalPointerEvents || '';
        banner.style.opacity = banner.dataset.originalOpacity || '';
        
        // Remove stored original state
        delete banner.dataset.originalFilter;
        delete banner.dataset.originalPointerEvents;
        delete banner.dataset.originalOpacity;
      }
    }
    
    
    /**
     * Create circular X button below ask-about-page button
     */
    function createCloseButton() {
      // Check if button already exists
      if (document.getElementById('home-options-btn')) {
        return;
      }
      
      // Function to actually create and append the button
      const createButton = async () => {
        // Check if button already exists (might have been created by another call)
        if (document.getElementById('home-options-btn')) {
          return;
        }
        
        // Create container for button and menu
        const container = document.createElement('div');
        container.className = 'home-options-container';
        
        // Create button element
        const button = document.createElement('button');
        button.id = 'home-options-btn';
        button.className = 'home-options-btn';
        button.setAttribute('aria-label', 'Home Options');
        
        // Initially hide the container (will be shown when extension is enabled)
        container.style.display = 'none';
        
        // Load logo white SVG from assets
        try {
          const svgUrl = chrome.runtime.getURL('assets/logo_white.svg');
          const response = await fetch(svgUrl);
          const svgContent = await response.text();
          button.innerHTML = svgContent;
          // Add class to the SVG element for styling
          const svgElement = button.querySelector('svg');
          if (svgElement) {
            svgElement.classList.add('home-options-gear-icon');
            // Set explicit width and height for proper sizing
            svgElement.setAttribute('width', '16');
            svgElement.setAttribute('height', '16');
          }
        } catch (error) {
          console.error('[Content Script] Failed to load logo white SVG:', error);
          // Fallback to inline SVG if file loading fails
          button.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="home-options-gear-icon">
              <defs>
                <mask id="ringMaskFallback">
                  <rect width="24" height="24" fill="white"/>
                  <ellipse cx="13.5" cy="13" rx="5.5" ry="4" transform="rotate(-12 13.5 13)" fill="black"/>
                </mask>
              </defs>
              <circle cx="11.5" cy="10.5" r="9.5" fill="white" mask="url(#ringMaskFallback)"/>
            </svg>
          `;
        }
        
        // Create hover menu
        const menu = document.createElement('div');
        menu.className = 'home-options-menu';
        
        // Track mouse state
        let isMouseInside = false;
        
        // Function to update active state based on menu visibility and mouse position
        const updateActiveState = () => {
          const isVisible = menu.classList.contains('home-options-menu-visible');
          
          if (isVisible || isMouseInside) {
            container.classList.add('home-options-container-active');
          } else {
            container.classList.remove('home-options-container-active');
          }
        };
        
        // Function to close menu
        const closeMenu = () => {
          menu.classList.remove('home-options-menu-visible');
          updateActiveState();
        };
        
        // Create Summarise button - uses same handler as ask-about-page button
        const summariseBtn = document.createElement('button');
        summariseBtn.className = 'home-options-menu-item';
        summariseBtn.id = 'home-options-summarise-btn';
        summariseBtn.innerHTML = `
          <svg fill="white" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 52 52" enable-background="new 0 0 52 52" xml:space="preserve">
            <g>
              <g>
                <g>
                  <path d="M48.5,2h-45C2.7,2,2,2.7,2,3.5v5C2,9.3,2.7,10,3.5,10h45c0.8,0,1.5-0.7,1.5-1.5v-5C50,2.7,49.3,2,48.5,2z"/>
                </g>
              </g>
              <g>
                <g>
                  <path d="M48.5,14h-35c-0.8,0-1.5,0.7-1.5,1.5v3c0,0.8,0.7,1.5,1.5,1.5h35c0.8,0,1.5-0.7,1.5-1.5v-3C50,14.7,49.3,14,48.5,14z"/>
                </g>
              </g>
              <g>
                <g>
                  <path d="M48.5,34h-35c-0.8,0-1.5,0.7-1.5,1.5v3c0,0.8,0.7,1.5,1.5,1.5h35c0.8,0,1.5-0.7,1.5-1.5v-3C50,34.7,49.3,34,48.5,34z"/>
                </g>
              </g>
              <g>
                <g>
                  <path d="M48.5,44h-39C8.7,44,8,43.3,8,42.5v-7C8,34.7,7.3,34,6.5,34h-3C2.7,34,2,34.7,2,35.5v13C2,49.3,2.7,50,3.5,50h3H8h40.5c0.8,0,1.5-0.7,1.5-1.5v-3C50,44.7,49.3,44,48.5,44z"/>
                </g>
              </g>
              <g>
                <g>
                  <path d="M48.5,24h-39C8.7,24,8,23.3,8,22.5v-7C8,14.7,7.3,14,6.5,14h-3C2.7,14,2,14.7,2,15.5v13C2,29.3,2.7,30,3.5,30h2H8h40.5c0.8,0,1.5-0.7,1.5-1.5v-3C50,24.7,49.3,24,48.5,24z"/>
                </g>
              </g>
            </g>
          </svg>
        `;
        summariseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
          
          // Close the menu
          closeMenu();
        
        // Check if dialog is already open for page-general context
        // Check for both 'page-general' and 'page-general-generic' (the transformed key)
        const isPageGeneralOpen = ChatDialog.isOpen && ChatDialog.currentTextKey && 
          (ChatDialog.currentTextKey === 'page-general' || ChatDialog.currentTextKey.startsWith('page-general'));
        
        if (isPageGeneralOpen) {
          // Toggle off - close the dialog
            console.log('[HomeOptions] Dialog already open for page-general, closing it. currentTextKey:', ChatDialog.currentTextKey);
          ChatDialog.close();
          return;
        }
        
        // Open chat dialog for general page chat
        // Use 'page-general' as textKey for general page chat
        // Use pageTextContent if available, otherwise fallback to current page text
        let pageText = '';
        if (pageTextContent) {
          try {
            const contentData = JSON.parse(pageTextContent);
            pageText = contentData.text || '';
          } catch (e) {
              console.warn('[HomeOptions] Error parsing pageTextContent, using fallback');
            pageText = document.body.innerText || document.body.textContent || '';
          }
        } else {
          pageText = document.body.innerText || document.body.textContent || '';
        }
        ChatDialog.open(pageText.substring(0, 1000), 'page-general', 'ask', null, 'general');
      });
        
        // Add tooltip to Summarise button
        const summariseTooltip = document.createElement('div');
        summariseTooltip.className = 'home-options-menu-item-tooltip';
        summariseTooltip.textContent = 'Summarise page';
        summariseBtn.appendChild(summariseTooltip);
        
        // Create Settings button
        const settingsBtn = document.createElement('button');
        settingsBtn.className = 'home-options-menu-item';
        // Use the same gear icon as home-options-btn (inline SVG)
        settingsBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
            <path d="M19.14,12.94c0.04-0.31,0.06-0.63,0.06-0.94s-0.02-0.63-0.06-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61l-1.92-3.32c-0.11-0.2-0.35-0.27-0.56-0.2l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.5,2.5C14.47,2.22,14.24,2,13.95,2h-3.9c-0.29,0-0.52,0.22-0.55,0.5L9.1,5.37C8.5,5.61,7.97,5.93,7.47,6.31L5.08,5.35c-0.21-0.08-0.45,0-0.56,0.2L2.6,8.87c-0.11,0.2-0.06,0.47,0.12,0.61l2.03,1.58C4.71,11.37,4.68,11.69,4.68,12s0.02,0.63,0.06,0.94l-2.03,1.58c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.11,0.2,0.35,0.27,0.56,0.2l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.4,2.87c0.03,0.28,0.26,0.5,0.55,0.5h3.9c0.29,0,0.52-0.22,0.55-0.5l0.4-2.87c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96c0.21,0.08,0.45,0,0.56-0.2l1.92-3.32c0.11-0.2,0.06-0.47-0.12-0.61L19.14,12.94z M12,15.5c-1.93,0-3.5-1.57-3.5-3.5S10.07,8.5,12,8.5s3.5,1.57,3.5,3.5S13.93,15.5,12,15.5z"/>
          </svg>
        `;
        settingsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Close the menu
          closeMenu();
          
          console.log('[Content Script] Settings button clicked');
          showLanguageSelectionModal();
        });
        
        // Add tooltip to Settings button
        const settingsTooltip = document.createElement('div');
        settingsTooltip.className = 'home-options-menu-item-tooltip';
        settingsTooltip.textContent = 'Settings';
        settingsBtn.appendChild(settingsTooltip);
        
        // Create Bookmark Words button (3rd option)
        const bookmarkWordsBtn = document.createElement('button');
        bookmarkWordsBtn.className = 'home-options-menu-item';
        bookmarkWordsBtn.id = 'home-options-bookmark-words-btn';
        // Bookmark icon SVG
        bookmarkWordsBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
            <path d="M17 3H7C5.9 3 5 3.9 5 5V21L12 18L19 21V5C19 3.9 18.1 3 17 3Z" fill="white"/>
          </svg>
        `;
        // Open bookmark words dialog on click
        bookmarkWordsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Close the menu
          closeMenu();
          console.log('[Content Script] Bookmark Words button clicked - opening dialog');
          BookmarkWordsDialog.open();
        });
        
        // Add tooltip to Bookmark Words button
        const bookmarkWordsTooltip = document.createElement('div');
        bookmarkWordsTooltip.className = 'home-options-menu-item-tooltip';
        bookmarkWordsTooltip.textContent = 'Bookmarks';
        bookmarkWordsBtn.appendChild(bookmarkWordsTooltip);
        
        // Create Power button (toggle extension on/off)
        const powerBtn = document.createElement('button');
        powerBtn.className = 'home-options-menu-item';
        powerBtn.id = 'home-options-power-btn';
        // Power icon SVG (power symbol)
        powerBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
            <path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.59-5.41L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"/>
          </svg>
        `;
        powerBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Close the menu
          closeMenu();
          
          console.log('[Content Script] Power button clicked - toggling extension');
          
          // Get current extension state
          const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
          const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
          const currentState = result[GLOBAL_STORAGE_KEY] ?? true;
          const newState = !currentState;
          
          // Save new state
          await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: newState });
          console.log('[Content Script] Extension state toggled to:', newState);
          
          // Update extension state (this will trigger storage change listener)
          if (newState) {
            ButtonPanel.show();
            WordSelector.enable();
            TextSelector.enable();
            if (window.pageTextContent) {
              showCloseButton();
            }
            // Hide enable dialog if it exists
            hideEnableExtensionDialog();
          } else {
            ButtonPanel.hide(true);
            WordSelector.disable();
            TextSelector.disable();
            WordSelector.clearAll();
            TextSelector.clearAll();
            hideCloseButton();
            // Show enable dialog
            showEnableExtensionDialog();
          }
          
          // Update banner visibility
          BannerModule.updateVisibility(newState);
        });
        
        // Add tooltip to Power button
        const powerTooltip = document.createElement('div');
        powerTooltip.className = 'home-options-menu-item-tooltip';
        powerTooltip.textContent = 'Disable Extension';
        powerBtn.appendChild(powerTooltip);
        
        menu.appendChild(summariseBtn);
        menu.appendChild(settingsBtn);
        menu.appendChild(bookmarkWordsBtn);
        menu.appendChild(powerBtn);
        
        container.appendChild(button);
        container.appendChild(menu);
        
        // Append container to body
        document.body.appendChild(container);
        
        // Function to toggle menu visibility
        const toggleMenu = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const isVisible = menu.classList.contains('home-options-menu-visible');
          if (isVisible) {
            menu.classList.remove('home-options-menu-visible');
            console.log('[Content Script] Home options menu closed');
          } else {
            menu.classList.add('home-options-menu-visible');
            console.log('[Content Script] Home options menu opened');
          }
          updateActiveState();
        };
        
        // Add click handler to toggle menu
        button.addEventListener('click', toggleMenu);
        
        // Handle mouse enter/leave on container
        container.addEventListener('mouseenter', () => {
          isMouseInside = true;
          updateActiveState();
        });
        
        container.addEventListener('mouseleave', () => {
          isMouseInside = false;
          updateActiveState();
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!container.contains(e.target)) {
            closeMenu();
          }
        });
        
        // Prevent menu from closing when clicking on menu items
        menu.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        console.log('[Content Script] Close X button created (initially hidden)');
      };
      
      // Try to create immediately if body exists
      if (document.body) {
        createButton();
      } else {
        // If body doesn't exist yet, wait for it using MutationObserver
        const observer = new MutationObserver((mutations, obs) => {
          if (document.body) {
            createButton();
            obs.disconnect(); // Stop observing once body is found
          }
        });
        
        // Start observing the document
        observer.observe(document.documentElement, {
          childList: true,
          subtree: true
        });
        
        // Fallback: also check immediately in case body already exists
        if (document.body) {
          observer.disconnect();
          createButton();
        }
      }
    }
    
    
    console.log('[Content Script] Initializing with global storage key:', GLOBAL_STORAGE_KEY);
    
    // Create preferred language button immediately (before other initializations)
    createCloseButton();
    
    // Initialize the button panel when content script loads
    await ButtonPanel.init();
    
    // Initialize the word selector functionality (will check state internally)
    await WordSelector.init();
    
    // Initialize the text selector functionality (will check state internally)
    await TextSelector.init();
    
    // Initialize the chat dialog
    ChatDialog.init();
    BookmarkWordsDialog.init();
    
    // Handle query params for word highlighting
    const handleQueryParams = () => {
      const urlParams = new URLSearchParams(window.location.search);
      const word = urlParams.get('xplaino_word');
      
      if (word) {
        // Wait a bit for page to be fully rendered
        setTimeout(() => {
          // Find first occurrence of word on page
          const walker = document.createTreeWalker(
            document.body,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );
          
          let foundNode = null;
          let node;
          while (node = walker.nextNode()) {
            const text = node.textContent;
            // Use word boundary regex to find exact word match
            const regex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
            if (regex.test(text)) {
              foundNode = node;
              break;
            }
          }
          
          if (foundNode) {
            // Function to highlight word text within a text node
            const highlightWordInTextNode = (textNode, searchWord) => {
              const escapedWord = searchWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
              const text = textNode.textContent;
              const match = text.match(regex);
              
              if (match) {
                const matchIndex = text.search(regex);
                const beforeText = text.substring(0, matchIndex);
                const matchedText = match[0];
                const afterText = text.substring(matchIndex + matchedText.length);
                
                // Get parent element to preserve its styling
                const parent = textNode.parentNode;
                const computedStyle = window.getComputedStyle(parent);
                
                // Create highlight span
                const highlightSpan = document.createElement('span');
                
                // Preserve existing text styling from parent
                highlightSpan.style.fontSize = computedStyle.fontSize;
                highlightSpan.style.fontWeight = computedStyle.fontWeight;
                highlightSpan.style.fontStyle = computedStyle.fontStyle;
                highlightSpan.style.fontFamily = computedStyle.fontFamily;
                highlightSpan.style.color = computedStyle.color;
                highlightSpan.style.textDecoration = computedStyle.textDecoration;
                highlightSpan.style.lineHeight = computedStyle.lineHeight;
                highlightSpan.style.letterSpacing = computedStyle.letterSpacing;
                highlightSpan.style.textTransform = computedStyle.textTransform;
                highlightSpan.style.fontVariant = computedStyle.fontVariant;
                
                // Add highlight styling (background, border, etc.) - matching vocab-word-explained style
                // Start with initial green background
                highlightSpan.style.backgroundColor = 'rgba(240, 253, 244, 0.5)';
                highlightSpan.style.border = '0.5px solid #22c55e';
                highlightSpan.style.borderRadius = '8px';
                highlightSpan.style.padding = '0 2px';
                highlightSpan.style.transition = 'all 0.3s ease';
                highlightSpan.style.display = 'inline'; // Ensure it's inline to preserve text flow
                
                highlightSpan.textContent = matchedText;
                
                // Replace text node with new nodes
                if (beforeText) {
                  parent.insertBefore(document.createTextNode(beforeText), textNode);
                }
                parent.insertBefore(highlightSpan, textNode);
                if (afterText) {
                  parent.insertBefore(document.createTextNode(afterText), textNode);
                }
                parent.removeChild(textNode);
                
                // Scroll to the highlighted word
                highlightSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Add pulsation animation class (3 pulses)
                highlightSpan.classList.add('xplaino-word-pulsate');
                
                // After animation completes (1.5s), remove animation class and persist green background
                setTimeout(() => {
                  highlightSpan.classList.remove('xplaino-word-pulsate');
                  // Ensure final green background is persisted
                  highlightSpan.style.backgroundColor = 'rgba(240, 253, 244, 0.5)';
                }, 1500); // Match animation duration (1.5s)
                
                console.log('[WordSelector] Highlighted word:', searchWord);
                return true;
              }
              
              return false;
            };
            
            // Highlight the word
            const highlighted = highlightWordInTextNode(foundNode, word);
            
            if (!highlighted) {
              console.warn('[WordSelector] Could not highlight word:', word);
            }
          } else {
            console.warn('[WordSelector] Could not find word on page:', word);
          }
        }, 500); // Wait 500ms for page to render
      }
    };
    
    // Check query params on page load
    if (document.readyState === 'complete') {
      handleQueryParams();
    } else {
      window.addEventListener('load', handleQueryParams);
    }
    
    // Wait for page to load completely, then fetch page text content in a separate thread
    if (document.readyState === 'complete') {
      // Page already loaded, fetch content immediately
      fetchPageTextContent();
    } else {
      // Wait for page to load
      window.addEventListener('load', () => {
        // Use setTimeout to run in a separate thread after page load
        setTimeout(() => {
          fetchPageTextContent();
        }, 100); // Small delay to ensure page is fully rendered
      });
    }
    
    // ===================================
    // Banner Module - Shows welcome banner when extension is enabled
    // ===================================
    const BannerModule = {
      STORAGE_KEY: 'explain_ai_banner_dismissed',
      bannerContainer: null,
      
      /**
       * Check if banner should be shown
       * @returns {Promise<boolean>} Whether to show the banner
       */
      async shouldShowBanner() {
        try {
          // Check if extension is enabled
          const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
          const isEnabled = result[GLOBAL_STORAGE_KEY] ?? true;
          
          if (!isEnabled) {
            return false;
          }
          
          // Check if user has dismissed the banner
          const dismissedResult = await chrome.storage.local.get([this.STORAGE_KEY]);
          const isDismissed = dismissedResult[this.STORAGE_KEY] ?? false;
          
          return !isDismissed;
        } catch (error) {
          console.error('[Banner] Error checking banner state:', error);
          return false;
        }
      },
      
      /**
       * Mark banner as dismissed
       */
      async dismissBanner() {
        try {
          await chrome.storage.local.set({ [this.STORAGE_KEY]: true });
          console.log('[Banner] Banner dismissed');
        } catch (error) {
          console.error('[Banner] Error dismissing banner:', error);
        }
      },
      
      /**
       * Create the banner HTML structure
       */
      createBanner() {
        if (this.bannerContainer) {
          return; // Already created
        }
        
        // Create main container
        this.bannerContainer = document.createElement('div');
        this.bannerContainer.id = 'explain-ai-banner';
        this.bannerContainer.className = 'explain-ai-banner';
        
        // Create header with close button at top right
        const header = document.createElement('div');
        header.className = 'banner-header';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'banner-close';
        closeButton.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 4L4 12M4 4L12 12" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        `;
        closeButton.setAttribute('aria-label', 'Close banner');
        closeButton.addEventListener('click', () => this.hideBanner());
        
        header.appendChild(closeButton);
        
        // Create heading container (vertically centered)
        const headingContainer = document.createElement('div');
        headingContainer.className = 'banner-heading-container';
        
        const brandingImg = document.createElement('img');
        brandingImg.src = chrome.runtime.getURL('branding-removebg.png');
        brandingImg.alt = 'XplainO';
        brandingImg.className = 'banner-branding-img';
        
        headingContainer.appendChild(brandingImg);
        
        // Create instructions container
        const instructions = document.createElement('div');
        instructions.className = 'banner-instructions';
        
        const instruction1 = document.createElement('p');
        instruction1.className = 'banner-instruction-item';
        instruction1.innerHTML = 'Double click a word to select';
        
        const instruction2 = document.createElement('p');
        instruction2.className = 'banner-instruction-item';
        instruction2.innerHTML = 'Select one or more sentences';
        
        instructions.appendChild(instruction1);
        instructions.appendChild(instruction2);
        
        // Create footer with "Don't show again" button
        const footer = document.createElement('div');
        footer.className = 'banner-footer';
        
        const dontShowButton = document.createElement('button');
        dontShowButton.className = 'banner-dont-show';
        dontShowButton.textContent = "Don't show again";
        dontShowButton.addEventListener('click', () => {
          this.dismissBanner();
          this.hideBanner();
        });
        
        footer.appendChild(dontShowButton);
        
        // Assemble banner
        this.bannerContainer.appendChild(header);
        this.bannerContainer.appendChild(headingContainer);
        this.bannerContainer.appendChild(instructions);
        this.bannerContainer.appendChild(footer);
        
        // Prevent double-click and text selection on banner
        this.bannerContainer.addEventListener('dblclick', (e) => {
          e.preventDefault();
          e.stopPropagation();
          return false;
        });
        
        this.bannerContainer.addEventListener('selectstart', (e) => {
          e.preventDefault();
          return false;
        });
        
        // Add styles
        this.addStyles();
        
        // Append to body
        document.body.appendChild(this.bannerContainer);
      },
      
      /**
       * Add CSS styles for the banner
       */
      addStyles() {
        if (document.getElementById('explain-ai-banner-styles')) {
          return; // Styles already added
        }
        
        const style = document.createElement('style');
        style.id = 'explain-ai-banner-styles';
        style.textContent = `
          .explain-ai-banner {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            width: 400px !important;
            max-width: calc(100vw - 40px) !important;
            background: white !important;
            border: none !important;
            border-radius: 30px !important;
            padding: 20px !important;
            box-shadow: 0 4px 20px rgba(149, 39, 245, 0.15) !important;
            z-index: 10000001 !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
            transform: translateX(400px);
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
            visibility: visible !important;
            display: block !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
          }
          
          .explain-ai-banner * {
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
          }
          
          .explain-ai-banner.show {
            transform: translateX(0);
            opacity: 1;
          }
          
          .explain-ai-banner.hide {
            transform: translateX(400px);
            opacity: 0;
          }
          
          .banner-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            position: relative;
          }
          
          .banner-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
          }
          
          .banner-close:hover {
            background-color: rgba(149, 39, 245, 0.1);
          }
          
          .banner-close:active {
            background-color: rgba(149, 39, 245, 0.2);
          }
          
          .banner-heading-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 22px;
          }
          
          .banner-branding-img {
            max-width: 200px;
            height: auto;
            object-fit: contain;
          }
          
          
          .banner-instructions {
            margin-bottom: 16px;
          }
          
          .banner-instruction-item {
            font-size: 14px;
            color: #333;
            margin: 10px 0;
            line-height: 1.6;
            position: relative;
            padding-left: 0;
          }
          
          .banner-instruction-item::before {
            content: "ⓘ";
            color: #9527F5;
            font-size: 16px;
            font-weight: bold;
            margin-right: 8px;
            vertical-align: middle;
            line-height: 1;
          }
          
          .banner-highlight {
            background-color: #f5f0ff;
            color: #7a1fd9;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
          }
          
          .banner-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding-top: 8px;
          }
          
          .banner-dont-show {
            background: rgba(149, 39, 245, 0.1);
            border: none;
            color: #9527F5;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 10px;
            transition: background-color 0.2s ease;
          }
          
          .banner-dont-show:hover {
            background-color: rgba(149, 39, 245, 0.2);
          }
          
          .banner-dont-show:active {
            background-color: rgba(149, 39, 245, 0.25);
          }
        `;
        
        document.head.appendChild(style);
      },
      
      /**
       * Show the banner with sliding-in animation
       */
      async showBanner() {
        if (!this.bannerContainer) {
          this.createBanner();
        }
        
        const shouldShow = await this.shouldShowBanner();
        if (!shouldShow) {
          return;
        }
        
        // Remove hide class and add show class
        this.bannerContainer.classList.remove('hide');
        this.bannerContainer.classList.add('show');
      },
      
      /**
       * Hide the banner with sliding-out animation
       */
      hideBanner() {
        if (!this.bannerContainer) {
          return;
        }
        
        this.bannerContainer.classList.remove('show');
        this.bannerContainer.classList.add('hide');
        
        // Remove from DOM after animation
        setTimeout(() => {
          if (this.bannerContainer && this.bannerContainer.classList.contains('hide')) {
            this.bannerContainer.remove();
            this.bannerContainer = null;
          }
        }, 400);
      },
      
      /**
       * Initialize the banner - check if it should be shown
       */
      async init() {
        const shouldShow = await this.shouldShowBanner();
        if (shouldShow) {
          // Wait a bit for page to load, then show banner
          setTimeout(() => {
            this.showBanner();
          }, 500);
        }
      },
      
      /**
       * Update banner visibility based on extension state
       */
      async updateVisibility(isEnabled) {
        if (isEnabled) {
          const shouldShow = await this.shouldShowBanner();
          if (shouldShow) {
            this.showBanner();
          } else {
            this.hideBanner();
          }
        } else {
          this.hideBanner();
        }
      }
    };
    
    // Check global extension state on page load/reload AFTER initialization
    const checkGlobalExtensionState = async () => {
      try {
        const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
        let isEnabled = result[GLOBAL_STORAGE_KEY];
        
        // If not found, create it and set to true (enabled by default)
        if (isEnabled === undefined) {
          isEnabled = true;
          await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: isEnabled });
          console.log('[Content Script] Global toggle state not found, created with default value: true');
        }
        
        console.log('[Content Script] Global extension state:', isEnabled);
        
        if (isEnabled) {
          ButtonPanel.show();
          WordSelector.enable();
          TextSelector.enable();
        } else {
          ButtonPanel.hide(true); // Hide immediately when disabling
          WordSelector.disable();
          TextSelector.disable();
          WordSelector.clearAll();
          TextSelector.clearAll();
        }
        
        // Update banner visibility after state check
        await BannerModule.updateVisibility(isEnabled);
      } catch (error) {
        console.error('[Content Script] Error checking global extension state:', error);
        // Default to enabled on error
        ButtonPanel.show();
        WordSelector.enable();
        TextSelector.enable();
        
        // Update banner visibility on error (default to enabled)
        await BannerModule.updateVisibility(true);
      }
    };
    
    // Check state after initialization
    await checkGlobalExtensionState();
    
    // SIMPLE FIX - Force topics indicator to be visible
    window.fixTopicsDot = () => {
      console.log('[FIX] Forcing topics green dot to be visible...');
      const indicator = document.getElementById('topics-content-indicator');
      if (indicator) {
        indicator.style.cssText = `
          display: block !important;
          visibility: visible !important;
          opacity: 1 !important;
          background-color: #16a34a !important;
          border: 1px solid white !important;
          position: absolute !important;
          top: 4px !important;
          right: 4px !important;
          width: 8px !important;
          height: 8px !important;
          border-radius: 50% !important;
          z-index: 10 !important;
        `;
        console.log('[FIX] Topics green dot should now be visible!');
      } else {
        console.log('[FIX] Topics indicator element not found - creating one...');
        const topicsButton = document.getElementById('vocab-topics-btn');
        if (topicsButton) {
          const newIndicator = document.createElement('div');
          newIndicator.id = 'topics-content-indicator';
          newIndicator.style.cssText = `
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            background-color: #16a34a !important;
            border: 1px solid white !important;
            position: absolute !important;
            top: 4px !important;
            right: 4px !important;
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            z-index: 10 !important;
          `;
          topicsButton.appendChild(newIndicator);
          console.log('[FIX] Created and added topics green dot!');
        }
      }
    };
    
    // Listen for storage changes to show/hide panel (global)
    chrome.storage.onChanged.addListener((changes, namespace) => {
      console.log('[Content Script] Storage changed:', changes, 'Namespace:', namespace);
      
      if (namespace === 'local') {
        // Check if global key changed
        if (changes[GLOBAL_STORAGE_KEY]) {
          const isEnabled = changes[GLOBAL_STORAGE_KEY].newValue;
          console.log(`[Content Script] Global toggle state changed:`, isEnabled);
          
          if (isEnabled) {
            ButtonPanel.show();
            WordSelector.enable();
            TextSelector.enable();
        } else {
          ButtonPanel.hide(true); // Hide immediately when disabling
          WordSelector.disable();
          TextSelector.disable();
          // Clear all selections when toggling off
          WordSelector.clearAll();
          TextSelector.clearAll();
        }
        
        // Update banner visibility
        BannerModule.updateVisibility(isEnabled);
        }
        
        // Check if user account data changed (user logged in)
        if (changes['xplaino_userAccountData']) {
          const newValue = changes['xplaino_userAccountData'].newValue;
          if (newValue && newValue.isLoggedIn === true) {
            // User just logged in, hide modal
            if (typeof LoginModal !== 'undefined') {
              console.log('[Content Script] User account data updated with isLoggedIn=true, hiding login modal');
              LoginModal.hide();
            }
          }
        }
      }
    });
    
    // Listen for messages from popup and background script
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log('[Content Script] Message received:', message);
      
      if (message.type === 'TOGGLE_EXTENSION_GLOBAL') {
        console.log(`[Content Script] Global toggle changed:`, message.isEnabled);
        
        if (message.isEnabled) {
          ButtonPanel.show();
          WordSelector.enable();
          TextSelector.enable();
          // Show home options button if pageTextContent is available
          if (window.pageTextContent) {
            showCloseButton();
          }
        } else {
          ButtonPanel.hide(true); // Hide immediately when disabling
          WordSelector.disable();
          TextSelector.disable();
          // Clear all selections when toggling off
          WordSelector.clearAll();
          TextSelector.clearAll();
          // Hide home options button when extension is disabled
          hideCloseButton();
          // Close preferred language modal if it's open
          const languageModal = document.getElementById('prefered-language-modal');
          const languageOverlay = document.getElementById('prefered-language-overlay');
          if (languageModal || languageOverlay) {
            console.log('[Content Script] Closing preferred language modal when extension is disabled');
            if (languageOverlay) {
              languageOverlay.remove();
            }
            // Restore ask-about-page button
            restoreAskAboutPageButton();
          }
          // Close chat dialog if it's open for ask-about-page context
          if (typeof ChatDialog !== 'undefined' && ChatDialog.isOpen && ChatDialog.currentTextKey) {
            const isPageGeneral = ChatDialog.currentTextKey === 'page-general' || ChatDialog.currentTextKey.startsWith('page-general');
            if (isPageGeneral) {
              console.log('[Content Script] Closing chat dialog for ask-about-page when extension is disabled');
              ChatDialog.close();
            }
          }
        }
        
        // Update banner visibility
        BannerModule.updateVisibility(message.isEnabled);
        
        sendResponse({ success: true });
      } else if (message.type === 'TAB_STATE_CHANGE') {
        console.log(`[Content Script] Tab state change:`, message.eventType);
        handleTabStateChange(message.domain, message.eventType, sendResponse);
      } else if (message.type === 'CHECK_EXTENSION_STATE') {
        handleExtensionStateCheck(message.domain, sendResponse);
      } else if (message.type === 'SHOW_LANGUAGE_MODAL') {
        console.log('[Content Script] Show language modal requested');
        // Show the language selection modal
        showLanguageSelectionModal();
        sendResponse({ success: true });
      } else if (message.type === 'CHECK_MODAL_STATE') {
        // Check if language modal is currently open
        const languageModal = document.getElementById('prefered-language-modal');
        const languageOverlay = document.getElementById('prefered-language-overlay');
        const isModalOpen = !!(languageModal || languageOverlay);
        sendResponse({ isModalOpen: isModalOpen });
      }
    });
    
    // Initialize banner after checking extension state
    await BannerModule.init();
  },
});

// ===================================
// Tab State Management Functions
// ===================================

/**
 * Handle tab state change events from background script
 * @param {string} domain - The domain name
 * @param {string} eventType - Type of event (TAB_LOADED, TAB_SWITCHED, TAB_CREATED)
 * @param {Function} sendResponse - Response callback
 */
async function handleTabStateChange(domain, eventType, sendResponse) {
  try {
    console.log(`[Content Script] Handling tab state change: ${eventType} for ${domain}`);
    
    // Check global extension state in storage
    const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
    const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
    let isEnabled = result[GLOBAL_STORAGE_KEY];
    
    if (isEnabled === undefined) {
      // No storage data found - create it and set to enabled (ON by default)
      console.log(`[Content Script] Global toggle state not found, creating with default value: true`);
      isEnabled = true;
      await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: isEnabled });
      
      // Ensure all components are enabled (default ON)
      ButtonPanel.show();
      WordSelector.enable();
      TextSelector.enable();
      
      sendResponse({ success: true, isEnabled: true, isNewDomain: true });
    } else {
      // Storage data exists, use the stored value
      console.log(`[Content Script] Global extension state: ${isEnabled}`);
      
      if (isEnabled) {
        ButtonPanel.show();
        WordSelector.enable();
        TextSelector.enable();
        // Show home options button if pageTextContent is available
        if (window.pageTextContent) {
          showCloseButton();
        }
      } else {
        ButtonPanel.hide(true); // Hide immediately when disabling
        WordSelector.disable();
        TextSelector.disable();
        WordSelector.clearAll();
        TextSelector.clearAll();
        // Hide home options button when extension is disabled
        hideCloseButton();
        // Close chat dialog if it's open for ask-about-page context
        if (typeof ChatDialog !== 'undefined' && ChatDialog.isOpen && ChatDialog.currentTextKey) {
          const isPageGeneral = ChatDialog.currentTextKey === 'page-general' || ChatDialog.currentTextKey.startsWith('page-general');
          if (isPageGeneral) {
            console.log('[Content Script] Closing chat dialog for ask-about-page when extension is disabled');
            ChatDialog.close();
          }
        }
      }
      
      sendResponse({ success: true, isEnabled: isEnabled, isNewDomain: false });
    }
  } catch (error) {
    console.error('[Content Script] Error handling tab state change:', error);
    sendResponse({ success: false, error: error.message });
  }
}

/**
 * Handle extension state check request
 * @param {string} domain - The domain to check
 * @param {Function} sendResponse - Response callback
 */
async function handleExtensionStateCheck(domain, sendResponse) {
  try {
    const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
    const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
    let isEnabled = result[GLOBAL_STORAGE_KEY];
    
    // If not found, create it and set to true (enabled by default)
    if (isEnabled === undefined) {
      isEnabled = true;
      await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: isEnabled });
      console.log('[Content Script] Global toggle state not found, created with default value: true');
    }
    
    console.log(`[Content Script] Global extension state:`, isEnabled);
    
    sendResponse({
      success: true,
      isEnabled: isEnabled,
      domain: domain
    });
  } catch (error) {
    console.error('[Content Script] Error checking global extension state:', error);
    sendResponse({
      success: false,
      error: error.message,
      isEnabled: true // Default to enabled on error
    });
  }
}

// ===================================
// Error Banner Module - Shows error messages for rate limiting
// ===================================
const ErrorBanner = {
  STORAGE_KEY: 'vocab_error_banner_dismissed',
  bannerContainer: null,
  isMinimized: false,
  
  /**
   * Check if banner should be shown
   * @returns {Promise<boolean>} Whether to show the banner
   */
  async shouldShowBanner() {
    try {
      const result = await chrome.storage.local.get([this.STORAGE_KEY]);
      const isDismissed = result[this.STORAGE_KEY] ?? false;
      return !isDismissed;
    } catch (error) {
      console.error('[ErrorBanner] Error checking banner state:', error);
      return true; // Default to showing on error
    }
  },
  
  /**
   * Mark banner as dismissed
   */
  async dismissBanner() {
    try {
      await chrome.storage.local.set({ [this.STORAGE_KEY]: true });
      console.log('[ErrorBanner] Banner dismissed');
    } catch (error) {
      console.error('[ErrorBanner] Error dismissing banner:', error);
    }
  },
  
  /**
   * Show error banner with message
   * @param {string} message - Error message to display
   */
  async show(message) {
    // Check if banner should be shown
    const shouldShow = await this.shouldShowBanner();
    if (!shouldShow) {
      console.log('[ErrorBanner] Banner dismissed by user, not showing');
      return;
    }
    
    // If banner already exists and is minimized, restore it
    if (this.bannerContainer && this.isMinimized) {
      this.restore();
      return;
    }
    
    // Remove existing banner if any
    this.hide();
    this.isMinimized = false;
    
    // Create banner container
    this.bannerContainer = document.createElement('div');
    this.bannerContainer.id = 'vocab-error-banner';
    this.bannerContainer.className = 'vocab-error-banner';
    this.bannerContainer.innerHTML = `
      <button class="vocab-error-banner-close" aria-label="Minimize">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <div class="vocab-error-banner-content">
        <span class="vocab-error-banner-message">${message}</span>
      </div>
      <div class="vocab-error-banner-footer">
        <button class="vocab-error-banner-dismiss" aria-label="Don't show again">Don't show again</button>
      </div>
    `;
    
    // Add close button handler (top left) - minimize instead of hide
    const closeBtn = this.bannerContainer.querySelector('.vocab-error-banner-close');
    closeBtn.addEventListener('click', () => {
      this.minimize();
    });
    
    // Add "Don't show again" button handler (bottom left)
    const dismissBtn = this.bannerContainer.querySelector('.vocab-error-banner-dismiss');
    dismissBtn.addEventListener('click', async () => {
      await this.dismissBanner();
      this.hide();
    });
    
    // Append to body
    document.body.appendChild(this.bannerContainer);
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (!this.isMinimized) {
        this.hide();
      }
    }, 5000);
    
    // Add styles if not already added
    this.injectStyles();
  },
  
  /**
   * Minimize error banner
   */
  minimize() {
    if (this.bannerContainer) {
      this.bannerContainer.classList.add('minimized');
      this.isMinimized = true;
    }
  },
  
  /**
   * Restore minimized banner
   */
  restore() {
    if (this.bannerContainer) {
      this.bannerContainer.classList.remove('minimized');
      this.isMinimized = false;
    }
  },
  
  /**
   * Hide error banner
   */
  hide() {
    if (this.bannerContainer && this.bannerContainer.parentNode) {
      this.bannerContainer.remove();
      this.bannerContainer = null;
      this.isMinimized = false;
    }
  },
  
  /**
   * Inject CSS styles for error banner
   */
  injectStyles() {
    const styleId = 'vocab-error-banner-styles';
    if (document.getElementById(styleId)) {
      return; // Styles already injected
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      .vocab-error-banner {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000000;
        background: #fee2e2;
        color: #dc2626;
        border: 1px solid #dc2626;
        padding: 16px 20px;
        border-radius: 8px;
        box-shadow: none;
        animation: vocab-error-banner-slide-in 0.3s ease-out;
        max-width: 90%;
        width: auto;
        min-width: 300px;
        position: relative;
      }
      
      @keyframes vocab-error-banner-slide-in {
        from {
          opacity: 0;
          transform: translateX(20px) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0) translateY(0);
        }
      }
      
      .vocab-error-banner-close {
        position: absolute;
        top: 8px;
        left: 8px !important;
        right: auto !important;
        background: rgba(220, 38, 38, 0.1);
        border: 1px solid rgba(220, 38, 38, 0.3);
        color: #dc2626;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
        padding: 6px;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.9;
        transition: all 0.2s;
        border-radius: 4px;
        z-index: 10;
        margin: 0;
      }
      
      .vocab-error-banner-close svg {
        width: 16px;
        height: 16px;
        stroke: #dc2626;
      }
      
      .vocab-error-banner-close:hover {
        opacity: 1;
        background: rgba(220, 38, 38, 0.2);
        border-color: rgba(220, 38, 38, 0.5);
      }
      
      .vocab-error-banner.minimized {
        height: 44px;
        overflow: hidden;
      }
      
      .vocab-error-banner.minimized .vocab-error-banner-content,
      .vocab-error-banner.minimized .vocab-error-banner-footer {
        display: none;
      }
      
      .vocab-error-banner-content {
        display: flex;
        align-items: center;
        padding: 8px 40px 8px 40px;
        min-height: 40px;
      }
      
      .vocab-error-banner-message {
        font-size: 14px;
        font-weight: 500;
        line-height: 1.4;
        text-align: center;
        flex: 1;
      }
      
      .vocab-error-banner-footer {
        display: flex !important;
        justify-content: flex-start !important;
        align-items: center !important;
        padding-top: 8px;
        padding-left: 0 !important;
        padding-right: 0 !important;
        border-top: 1px solid rgba(220, 38, 38, 0.2);
        margin-top: 8px;
        margin-left: 0 !important;
        margin-right: 0 !important;
        text-align: left !important;
        width: 100%;
      }
      
      .vocab-error-banner-dismiss {
        background: none !important;
        border: 1px solid rgba(220, 38, 38, 0.5) !important;
        color: #dc2626 !important;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        padding: 6px 12px;
        opacity: 0.9;
        transition: all 0.2s;
        text-decoration: none;
        border-radius: 4px;
        margin-left: 0 !important;
        margin-right: auto !important;
        float: left !important;
        position: relative !important;
        left: 0 !important;
        right: auto !important;
      }
      
      .vocab-error-banner-dismiss:hover {
        opacity: 1;
        background: rgba(220, 38, 38, 0.1);
        border-color: rgba(220, 38, 38, 0.8);
      }
    `;
    
    document.head.appendChild(style);
  }
};

// ===================================
// Login Modal Module - Shows login modal for authentication
// ===================================
const LoginModal = {
  modalContainer: null,
  overlay: null,
  
  /**
   * Get dynamic description based on API name
   * @param {string} apiName - API endpoint name
   * @returns {string} Description message
   */
  getDescriptionForApi(apiName) {
    if (!apiName) {
      return 'Please sign in to continue';
    }
    
    const apiNameUpper = apiName.toUpperCase();
    const apiNameLower = apiName.toLowerCase();
    
    // Map API names to descriptions
    if (apiNameUpper === 'WORDS_EXPLANATION' || apiNameLower === 'words-explanation' || apiNameLower.includes('word')) {
      return 'Please sign in to get word meanings';
    } else if (apiNameUpper === 'SIMPLIFY' || apiNameLower === 'simplify') {
      return 'Please sign in to simplify text';
    } else if (apiNameUpper === 'SUMMARISE' || apiNameLower === 'summarise' || apiNameLower === 'summarize') {
      return 'Please sign in to summarise content';
    } else if (apiNameUpper === 'ASK' || apiNameLower === 'ask') {
      return 'Please sign in to ask questions';
    } else if (apiNameUpper === 'TRANSLATE' || apiNameLower === 'translate') {
      return 'Please sign in to translate text';
    } else if (apiNameUpper === 'WEB_SEARCH_STREAM' || apiNameLower === 'web-search' || apiNameLower.includes('search')) {
      return 'Please sign in to search the web';
    } else {
      return 'Please sign in to continue';
    }
  },
  
  /**
   * Show login modal in center of screen
   * @param {string} reason - Optional reason message (deprecated, use apiName instead)
   * @param {string} apiName - API endpoint name to determine dynamic description
   */
  show(reason, apiName) {
    console.log('[LoginModal] ===== SHOW CALLED =====');
    console.log('[LoginModal] Reason:', reason);
    console.log('[LoginModal] ApiName:', apiName);
    console.log('[LoginModal] Current overlay:', this.overlay);
    console.log('[LoginModal] Current modalContainer:', this.modalContainer);
    
    // Remove existing modal if any
    this.hide();
    
    // Get dynamic description based on API name
    const description = apiName ? this.getDescriptionForApi(apiName) : (reason || 'Please sign in to continue');
    console.log('[LoginModal] Using description:', description);
    
    // Inject styles first to ensure keyframes are available
    this.injectStyles();
    
    // Create overlay with initial state
    this.overlay = document.createElement('div');
    this.overlay.id = 'login-modal-overlay';
    this.overlay.style.cssText = `
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: 100% !important;
      background-color: rgba(0, 0, 0, 0.5) !important;
      z-index: 2147483647 !important;
      display: flex !important;
      justify-content: center !important;
      align-items: center !important;
      pointer-events: auto !important;
      opacity: 0 !important;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    `;
    
    // Create modal container with initial state
    this.modalContainer = document.createElement('div');
    this.modalContainer.id = 'login-modal';
    this.modalContainer.style.cssText = `
      background-color: white !important;
      border-radius: 30px !important;
      padding: 40px !important;
      max-width: 400px !important;
      width: 90% !important;
      box-shadow: 0 10px 40px rgba(149, 39, 245, 0.3), 0 0 0 1px rgba(149, 39, 245, 0.1) !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      gap: 24px !important;
      position: relative !important;
      opacity: 0 !important;
      transform: scale(0.9) translateY(-10px) !important;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    `;
    
    // Get branding image URL (from extension assets)
    const brandingImageUrl = chrome.runtime.getURL('branding-removebg.png');
    
    // Modal content with close button
    this.modalContainer.innerHTML = `
      <button id="login-modal-close" class="login-modal-close-button" aria-label="Close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M18 6L6 18M6 6L18 18" stroke="#9527F5" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <div style="text-align: center !important;">
        <img src="${brandingImageUrl}" alt="XplainO" style="max-width: 200px !important; width: 100% !important; height: auto !important; margin-bottom: 16px !important;">
      </div>
      <p class="login-modal-description" style="color: #666 !important; font-size: 16px !important; font-weight: 400 !important; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important; font-style: normal !important; text-align: center !important; margin: 0 !important; padding: 0 !important; line-height: 1.5 !important; letter-spacing: normal !important; text-decoration: none !important; text-transform: none !important; text-shadow: none !important; font-variant: normal !important; font-stretch: normal !important;">${description}</p>
      <button id="login-modal-google-signin" class="login-modal-signin-button">
        <svg class="google-logo" width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg" style="margin-right: 12px !important;">
          <g fill="none" fill-rule="evenodd">
            <path d="M17.64 9.2045c0-.6381-.0573-1.2518-.1636-1.8409H9v3.4814h4.8436c-.2086 1.125-.8427 2.0782-1.7959 2.7164v2.2581h2.9087c1.7028-1.5668 2.6836-3.874 2.6836-6.615z" fill="#4285F4"/>
            <path d="M9 18c2.43 0 4.4673-.806 5.9564-2.1805l-2.9087-2.2581c-.8059.54-1.8368.859-3.0477.859-2.344 0-4.3282-1.5831-5.036-3.7104H.9574v2.3318C2.4382 15.9832 5.4822 18 9 18z" fill="#34A853"/>
            <path d="M3.964 10.71c-.18-.54-.2822-1.1173-.2822-1.71s.1022-1.17.2823-1.71V4.9582H.9573C.3477 6.1732 0 7.5477 0 9s.348 2.8268.9573 4.0418l3.0067-2.3318z" fill="#FBBC05"/>
            <path d="M9 3.5795c1.3214 0 2.5077.4541 3.4405 1.3459l2.5813-2.5814C13.4632.8918 11.426 0 9 0 5.4822 0 2.4382 2.0168.9573 4.9582L3.964 7.29C4.6718 5.1627 6.6559 3.5795 9 3.5795z" fill="#EA4335"/>
          </g>
        </svg>
        <span>Sign in with Google</span>
      </button>
    `;
    
    // Append modal to overlay
    this.overlay.appendChild(this.modalContainer);
    
    // Store references for event handlers
    const overlay = this.overlay;
    const modalContainer = this.modalContainer;
    const loginModalInstance = this;
    
    // Single click handler for modal container using event delegation
    modalContainer.addEventListener('click', function(e) {
      // Handle close button click
      if (e.target.closest('#login-modal-close')) {
        e.stopPropagation();
        loginModalInstance.hide();
        return;
      }
      
      // Handle sign-in button click
      if (e.target.closest('#login-modal-google-signin')) {
        loginModalInstance.handleGoogleSignIn();
        return;
      }
      
      // Prevent all other modal clicks from bubbling to overlay
      e.stopPropagation();
    });
    
    // Close modal when clicking outside the modal (on the overlay)
    overlay.addEventListener('click', function(e) {
      // If the click is not inside the modal container, close the modal
      const modal = document.getElementById('login-modal');
      if (modal && !modal.contains(e.target)) {
        loginModalInstance.hide();
      }
    });
    
    // Append to body first
    document.body.appendChild(this.overlay);
    
    // Use requestAnimationFrame to trigger animation after DOM is ready
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        // Trigger animation by changing to final state
        this.overlay.style.setProperty('opacity', '1', 'important');
        this.modalContainer.style.setProperty('opacity', '1', 'important');
        this.modalContainer.style.setProperty('transform', 'scale(1) translateY(0)', 'important');
        console.log('[LoginModal] Overlay appended to body');
        console.log('[LoginModal] Overlay element:', this.overlay);
        console.log('[LoginModal] ModalContainer element:', this.modalContainer);
        console.log('[LoginModal] ===== SHOW COMPLETE =====');
      });
    });
  },
  
  /**
   * Hide login modal
   */
  hide() {
    console.log('[LoginModal] ===== HIDE CALLED =====');
    
    // Find overlay and modal from DOM instead of relying on this references
    const overlay = document.getElementById('login-modal-overlay');
    const modalContainer = document.getElementById('login-modal');
    
    console.log('[LoginModal] Overlay found in DOM:', !!overlay);
    console.log('[LoginModal] ModalContainer found in DOM:', !!modalContainer);
    
    if (overlay && overlay.parentNode) {
      // Set transition for smooth closing
      if (modalContainer) {
        modalContainer.style.setProperty('transition', 'opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)', 'important');
      }
      overlay.style.setProperty('transition', 'opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)', 'important');
      
      // Trigger fade-out by changing to initial state
      requestAnimationFrame(() => {
        if (modalContainer) {
          modalContainer.style.setProperty('opacity', '0', 'important');
          modalContainer.style.setProperty('transform', 'scale(0.9) translateY(-10px)', 'important');
        }
        overlay.style.setProperty('opacity', '0', 'important');
      });
      
      // Remove from DOM after animation completes
      setTimeout(() => {
        const overlayToRemove = document.getElementById('login-modal-overlay');
        if (overlayToRemove && overlayToRemove.parentNode) {
          console.log('[LoginModal] Removing overlay from DOM');
          overlayToRemove.remove();
        }
        // Clear references
        this.overlay = null;
        this.modalContainer = null;
        console.log('[LoginModal] Overlay and modalContainer cleared');
      }, 300);
    } else {
      console.log('[LoginModal] No overlay to remove or overlay not in DOM');
      // Clear references anyway
      this.overlay = null;
      this.modalContainer = null;
    }
  },
  
  /**
   * Handle Google sign-in flow
   */
  async handleGoogleSignIn() {
    try {
      const signInButton = document.getElementById('login-modal-google-signin');
      if (signInButton) {
        signInButton.disabled = true;
        signInButton.style.opacity = '0.6';
        signInButton.style.cursor = 'not-allowed';
      }
      
      const clientId = ApiConfig.GOOGLE_CLIENT_ID;
      if (!clientId) {
        throw new Error('Google Client ID not configured');
      }
      
      // Generate state and nonce for security
      const state = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      const nonce = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      
      // Store state in chrome.storage for verification
      await chrome.storage.local.set({ 'oauth_state': state, 'oauth_nonce': nonce });
      
      // Get redirect URI using message passing to background script
      const redirectUriResponse = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          { type: 'OAUTH_GET_REDIRECT_URI' },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
              return;
            }
            if (!response || !response.success) {
              reject(new Error(response?.error || 'Failed to get redirect URI'));
              return;
            }
            resolve(response.redirectUri);
          }
        );
      });
      
      const redirectUri = redirectUriResponse;
      console.log('[LoginModal] Using redirect URI:', redirectUri);
      
      // Create OAuth URL
      const scope = 'openid email profile';
      const responseType = 'id_token';
      
      const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?` +
        `client_id=${encodeURIComponent(clientId)}&` +
        `redirect_uri=${encodeURIComponent(redirectUri)}&` +
        `response_type=${responseType}&` +
        `scope=${encodeURIComponent(scope)}&` +
        `state=${state}&` +
        `nonce=${nonce}`;

      console.log('[LoginModal] Launching OAuth flow...');
      
      // Use message passing to background script for OAuth flow
      const callbackUrlResponse = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          { type: 'OAUTH_LAUNCH_FLOW', authUrl: authUrl },
          (response) => {
            if (chrome.runtime.lastError) {
              // Clean up stored state
              chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
              reject(new Error(chrome.runtime.lastError.message));
              return;
            }
            if (!response || !response.success) {
              // Clean up stored state
              chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
              reject(new Error(response?.error || 'OAuth flow failed'));
              return;
            }
            resolve(response.callbackUrl);
          }
        );
      });
      
      const callbackUrl = callbackUrlResponse;
      
      console.log('[LoginModal] OAuth callback URL received:', callbackUrl);
      
      // Parse the callback URL to extract id_token
      const url = new URL(callbackUrl);
      
      let idToken = null;
      let returnedState = null;
      
      // Check hash fragment (common in OAuth implicit flow)
      if (url.hash) {
        const hashParams = new URLSearchParams(url.hash.substring(1));
        idToken = hashParams.get('id_token');
        returnedState = hashParams.get('state');
      }
      
      // Check query params as fallback
      if (!idToken) {
        idToken = url.searchParams.get('id_token');
        returnedState = url.searchParams.get('state');
      }
      
      // Check for errors in callback
      if (!idToken) {
        const error = url.searchParams.get('error') || (url.hash ? new URLSearchParams(url.hash.substring(1)).get('error') : null);
        if (error) {
          const errorDesc = url.searchParams.get('error_description') || (url.hash ? new URLSearchParams(url.hash.substring(1)).get('error_description') : null);
          chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
          throw new Error(`OAuth error: ${error}${errorDesc ? ' - ' + errorDesc : ''}`);
        }
        chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
        throw new Error('No id_token found in OAuth callback');
      }
      
      // Verify state
      const stored = await chrome.storage.local.get(['oauth_state']);
      if (stored.oauth_state && stored.oauth_state !== returnedState) {
        chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
        throw new Error('OAuth state mismatch - possible security issue');
      }
      
      // Clean up stored state
      await chrome.storage.local.remove(['oauth_state', 'oauth_nonce']);
      
      // Call backend API with id_token
      await this.completeSignIn(idToken);
      
    } catch (error) {
      console.error('[LoginModal] Error in handleGoogleSignIn:', error);
      
      // Restore button state
      const signInButton = document.getElementById('login-modal-google-signin');
      if (signInButton) {
        signInButton.disabled = false;
        signInButton.style.opacity = '1';
        signInButton.style.cursor = 'pointer';
      }
      
      // Show error in banner
      if (typeof ErrorBanner !== 'undefined') {
        await ErrorBanner.show(error.message || 'Sign-in failed');
      }
      
      // Ensure cleanup on error
      await chrome.storage.local.remove(['oauth_state', 'oauth_nonce']).catch(() => {});
    }
  },
  
  /**
   * Complete sign-in by calling backend API
   * @param {string} idToken - Google OAuth id token
   */
  async completeSignIn(idToken) {
    try {
      // Import AuthService dynamically
      const { default: AuthService } = await import('../core/services/AuthService.js');
      
      const result = await AuthService.login(idToken);
      
      if (result.success && result.data) {
        // Log the structure before storing
        console.log('[LoginModal] Login API response data structure:', JSON.stringify(result.data, null, 2));
        console.log('[LoginModal] AccessToken in response:', result.data.accessToken || result.data.access_token ? 'FOUND' : 'NOT FOUND');
        console.log('[LoginModal] RefreshToken in response:', result.data.refreshToken ? 'FOUND' : 'NOT FOUND');
        console.log('[LoginModal] RefreshTokenExpiresAt in response:', result.data.refreshTokenExpiresAt ? 'FOUND' : 'NOT FOUND');
        
        // Store user account data directly - NO wrapping, NO nesting
        // Store result.data directly as the value for xplaino_userAccountData key
        const dataToStore = result.data; // Direct assignment, no transformation
        await chrome.storage.local.set({ 'xplaino_userAccountData': dataToStore });
        
        // Extract access token from response
        const accessToken = result.data.accessToken || result.data.access_token;
        
        // Store access token in ApiService memory
        if (accessToken) {
          const { default: ApiService } = await import('../core/services/ApiService.js');
          ApiService.setAccessToken(accessToken);
          console.log('[LoginModal] Access token stored in ApiService memory');
        }
        
        // Extract refreshToken and refreshTokenExpiresAt from response body
        const refreshToken = result.data.refreshToken;
        const refreshTokenExpiresAt = result.data.refreshTokenExpiresAt;
        
        if (refreshToken) {
          console.log('[LoginModal] ✓ RefreshToken found in response body (length:', refreshToken.length, ')');
        } else {
          console.warn('[LoginModal] ⚠ RefreshToken not found in response body');
        }
        
        if (refreshTokenExpiresAt) {
          console.log('[LoginModal] ✓ RefreshTokenExpiresAt found in response body:', refreshTokenExpiresAt);
        } else {
          console.warn('[LoginModal] ⚠ RefreshTokenExpiresAt not found in response body');
        }
        
        // Store exact login API response in xplaino-user-auth-info for access token retrieval
        // The response body already contains refreshToken and refreshTokenExpiresAt
        const authInfoToStore = {
          ...dataToStore
        };
        
        await chrome.storage.local.set({ 'xplaino-user-auth-info': authInfoToStore });
        console.log('[LoginModal] Stored login response in xplaino-user-auth-info');
        
        // Validate: Read back immediately to verify structure
        const verifyResult = await chrome.storage.local.get(['xplaino_userAccountData']);
        const storedData = verifyResult['xplaino_userAccountData'];
        console.log('[LoginModal] Verification - Stored data structure:', JSON.stringify(storedData, null, 2));
        console.log('[LoginModal] Verification - AccessToken accessible:', storedData?.accessToken || storedData?.access_token ? 'YES' : 'NO');
        if (storedData?.accessToken) {
          console.log('[LoginModal] Verification - AccessToken value (first 20 chars):', storedData.accessToken.substring(0, 20) + '...');
        } else if (storedData?.access_token) {
          console.log('[LoginModal] Verification - AccessToken value (first 20 chars):', storedData.access_token.substring(0, 20) + '...');
        }
        
        // Validate xplaino-user-auth-info storage
        const authInfoResult = await chrome.storage.local.get(['xplaino-user-auth-info']);
        const authInfoData = authInfoResult['xplaino-user-auth-info'];
        console.log('[LoginModal] Verification - xplaino-user-auth-info stored:', authInfoData ? 'YES' : 'NO');
        if (authInfoData?.accessToken) {
          console.log('[LoginModal] Verification - AccessToken in xplaino-user-auth-info (first 20 chars):', authInfoData.accessToken.substring(0, 20) + '...');
        }
        if (authInfoData?.refreshToken) {
          console.log('[LoginModal] Verification - RefreshToken in xplaino-user-auth-info (length):', authInfoData.refreshToken.length);
        }
        if (authInfoData?.refreshTokenExpiresAt) {
          console.log('[LoginModal] Verification - RefreshTokenExpiresAt in xplaino-user-auth-info:', authInfoData.refreshTokenExpiresAt);
        }
        
        // Hide modal
        this.hide();
        
        // Hide any error banners
        if (typeof ErrorBanner !== 'undefined') {
          ErrorBanner.hide();
        }
        
        console.log('[LoginModal] Sign-in successful');
        
        // Dispatch event to notify other parts of the extension
        window.dispatchEvent(new CustomEvent('user-logged-in', {
          detail: result.data
        }));
      } else {
        throw new Error(result.error || 'Login failed');
      }
    } catch (error) {
      console.error('[LoginModal] Error completing sign-in:', error);
      if (typeof ErrorBanner !== 'undefined') {
        await ErrorBanner.show(error.message || 'Sign-in failed');
      }
      throw error;
    }
  },
  
  /**
   * Inject CSS styles for login modal
   */
  injectStyles() {
    const styleId = 'login-modal-styles';
    if (document.getElementById(styleId)) {
      return; // Styles already injected
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      @keyframes login-modal-overlay-fade-in {
        from {
          opacity: 0 !important;
        }
        to {
          opacity: 1 !important;
        }
      }
      
      @keyframes login-modal-overlay-fade-out {
        from {
          opacity: 1 !important;
        }
        to {
          opacity: 0 !important;
        }
      }
      
      @keyframes login-modal-fade-in {
        from {
          opacity: 0 !important;
          transform: scale(0.9) translateY(-10px) !important;
        }
        to {
          opacity: 1 !important;
          transform: scale(1) translateY(0) !important;
        }
      }
      
      @keyframes login-modal-fade-out {
        from {
          opacity: 1 !important;
          transform: scale(1) translateY(0) !important;
        }
        to {
          opacity: 0 !important;
          transform: scale(0.9) translateY(-10px) !important;
        }
      }
      
      .login-modal-close-button {
        position: absolute !important;
        top: 16px !important;
        right: 16px !important;
        background: none !important;
        border: none !important;
        cursor: pointer !important;
        padding: 8px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        width: 32px !important;
        height: 32px !important;
        border-radius: 50% !important;
        transition: background-color 0.2s ease !important;
        z-index: 1 !important;
      }
      
      .login-modal-close-button:hover {
        background-color: rgba(149, 39, 245, 0.1) !important;
      }
      
      .login-modal-close-button:active {
        background-color: rgba(149, 39, 245, 0.2) !important;
      }
      
      .login-modal-close-button svg {
        width: 24px !important;
        height: 24px !important;
      }
      
      .login-modal-signin-button {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        gap: 12px !important;
        background-color: #f5f5f5 !important;
        border: none !important;
        border-radius: 50px !important;
        padding: 12px 24px !important;
        font-size: 14px !important;
        font-weight: 500 !important;
        color: #3c4043 !important;
        cursor: pointer !important;
        transition: background-color 0.2s ease, box-shadow 0.2s ease !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
        min-width: 240px !important;
      }
      
      .login-modal-signin-button:hover {
        background-color: #f8f9fa !important;
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.3) !important;
      }
      
      .login-modal-signin-button:active {
        background-color: #e8eaed !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
      }
      
      .login-modal-signin-button:disabled {
        opacity: 0.6 !important;
        cursor: not-allowed !important;
      }
      
      .login-modal-signin-button .google-logo {
        flex-shrink: 0 !important;
      }
      
      .login-modal-description {
        color: #666 !important;
        font-size: 16px !important;
        font-weight: 400 !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
        font-style: normal !important;
        text-align: center !important;
        margin: 0 !important;
        padding: 0 !important;
        line-height: 1.5 !important;
        letter-spacing: normal !important;
        text-decoration: none !important;
        text-transform: none !important;
        text-shadow: none !important;
        font-variant: normal !important;
        font-stretch: normal !important;
        text-rendering: optimizeLegibility !important;
        -webkit-font-smoothing: antialiased !important;
        -moz-osx-font-smoothing: grayscale !important;
      }
    `;
    
    document.head.appendChild(style);
  }
};

// ===================================
// API Error Handler Bridge - Routes API errors to appropriate UI components
// ===================================
const ApiErrorHandler = {
  /**
   * Initialize error handler - listens for API error events
   */
  init() {
    // Listen for API error banner events
    // DISABLED: Error banner functionality removed per user request
    // All errors should be handled by showing login modal for LOGIN_REQUIRED or other appropriate UI
    window.addEventListener('api-error-banner', (event) => {
      const { message, status, errorCode } = event.detail;
      
      console.log('[ApiErrorHandler] api-error-banner event received but ErrorBanner is disabled');
      console.log('[ApiErrorHandler] Event details:', { message, status, errorCode });
      
      // IMPORTANT: Never show error banner for LOGIN_REQUIRED
      // This is a safeguard in case errorCode is passed in the event detail
      if (errorCode === 'LOGIN_REQUIRED') {
        console.log('[ApiErrorHandler] LOGIN_REQUIRED detected in error banner event - should show login modal instead');
        // Show login modal instead
        if (typeof LoginModal !== 'undefined') {
          LoginModal.show('Please sign in to continue', null);
        }
        return;
      }
      
      // For all other errors, do not show error banner
      // Error banner functionality has been removed
      console.log('[ApiErrorHandler] Error banner event ignored - ErrorBanner functionality disabled');
    });
    
    // Listen for login required events
    window.addEventListener('api-login-required', (event) => {
      console.log('[ApiErrorHandler] ===== api-login-required EVENT RECEIVED =====');
      const { reason, status, apiEndpoint } = event.detail;
      console.log('[ApiErrorHandler] Event detail:', event.detail);
      console.log('[ApiErrorHandler] Reason:', reason);
      console.log('[ApiErrorHandler] Status:', status);
      console.log('[ApiErrorHandler] ApiEndpoint:', apiEndpoint);
      console.log('[ApiErrorHandler] Showing login modal:', reason);
      
      // IMPORTANT: Hide any existing error banners before showing login modal
      // This prevents the red error banner from flashing before the modal appears
      if (typeof ErrorBanner !== 'undefined') {
        console.log('[ApiErrorHandler] Hiding any existing error banners');
        ErrorBanner.hide();
      } else {
        console.log('[ApiErrorHandler] ErrorBanner is undefined');
      }
      
      if (typeof LoginModal !== 'undefined') {
        console.log('[ApiErrorHandler] LoginModal is defined, calling LoginModal.show() with apiEndpoint:', apiEndpoint);
        LoginModal.show(reason || 'Please sign in to continue', apiEndpoint);
        console.log('[ApiErrorHandler] LoginModal.show() called');
      } else {
        console.error('[ApiErrorHandler] ⚠️ LoginModal is undefined! Cannot show login modal');
      }
      console.log('[ApiErrorHandler] ===== api-login-required EVENT HANDLED =====');
    });
    
    // Listen for successful login to hide modal
    window.addEventListener('user-logged-in', (event) => {
      console.log('[ApiErrorHandler] user-logged-in event received, hiding login modal');
      if (typeof LoginModal !== 'undefined') {
        LoginModal.hide();
      }
    });
    
    console.log('[ApiErrorHandler] Error handler initialized');
  }
};

// Initialize error handler when content script loads
ApiErrorHandler.init();

// ===================================
// Login Modal Auto-Close on Page Load
// ===================================
/**
 * Check on page load if user is logged in and hide modal if visible
 */
async function checkAndHideLoginModalOnLoad() {
  try {
    const result = await chrome.storage.local.get(['xplaino_userAccountData']);
    const userData = result['xplaino_userAccountData'];
    
    if (userData && userData.isLoggedIn === true) {
      // User is logged in, hide modal if it's visible
      const overlay = document.getElementById('login-modal-overlay');
      if (overlay && typeof LoginModal !== 'undefined') {
        console.log('[Content Script] User is logged in, hiding login modal on page load');
        LoginModal.hide();
      }
    }
  } catch (error) {
    console.error('[Content Script] Error checking login state on page load:', error);
  }
}

// Check on page load if user is logged in and hide modal
if (document.readyState === 'complete') {
  checkAndHideLoginModalOnLoad();
} else {
  window.addEventListener('load', checkAndHideLoginModalOnLoad);
  // Also check when DOM is ready (in case load event already fired)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', checkAndHideLoginModalOnLoad);
  } else {
    // DOM already ready, check immediately
    checkAndHideLoginModalOnLoad();
  }
}

// ===================================
// Position Manager Module - Handles saving and loading panel position
// ===================================
const PositionManager = {
  STORAGE_KEY: 'vocab-helper-panel-position',
  
  /**
   * Save panel position to storage
   * @param {Object} position - Position object {top, left}
   */
  async savePosition(position) {
    try {
      await chrome.storage.local.set({ [this.STORAGE_KEY]: position });
    } catch (error) {
      console.error('Error saving panel position:', error);
    }
  },
  
  /**
   * Load panel position from storage
   * @returns {Promise<Object|null>} Position object or null if not found
   */
  async loadPosition() {
    try {
      const result = await chrome.storage.local.get([this.STORAGE_KEY]);
      return result[this.STORAGE_KEY] || null;
    } catch (error) {
      console.error('Error loading panel position:', error);
      return null;
    }
  },
  
  /**
   * Clear saved position
   */
  async clearPosition() {
    try {
      await chrome.storage.local.remove([this.STORAGE_KEY]);
    } catch (error) {
      console.error('Error clearing panel position:', error);
    }
  }
};

// ===================================
// Word Selector Module - Handles word selection and highlighting
// ===================================
const WordSelector = {
  // Use Set for O(1) insertion, deletion, and lookup
  selectedWords: new Set(),
  
  // Map to store word -> Set of highlight elements (for handling multiple instances)
  wordToHighlights: new Map(),
  
  // Map to store word -> Array of position objects {element, textStartIndex}
  wordPositions: new Map(),
  
  // Container for explained words (moved from selectedWords after API call)
  explainedWords: new Map(), // Map of word -> {word, meaning, examples, highlights, hasCalledGetMoreExamples}
  
  // Track if popup is open for each word (boolean flag)
  wordPopupOpen: new Map(), // Map of normalizedWord -> boolean
  
  // Cache for pronunciation audio blobs
  pronunciationCache: new Map(), // Map of word -> audio blob
  
  // Cache for translated word explanations (EN translations)
  translationCache: new Map(), // Map of normalizedWord -> {meaning, examples}
  
  // Track if the feature is enabled
  isEnabled: false,
  
  // Counter for generating unique IDs
  highlightIdCounter: 0,
  
  // Store bound handler for proper cleanup
  boundDoubleClickHandler: null,
  
  // Track pending words (words with magic button but no API call yet)
  pendingWords: new Map(), // Map of normalizedWord -> {word, range, highlight}
  
  // Track button wrappers for magic meaning buttons
  wordButtonWrappers: new Map(), // Map of normalizedWord -> button wrapper element
  
  // Inline purple logo SVG content (no fetch needed)
  purpleLogoSvgContent: `<svg xmlns="http://www.w3.org/2000/svg" width="293" height="277" viewBox="0 0 293 277"><g><path d="M 186.57 204.25 C187.92,206.31 188.69,207.96 188.26,207.91 C187.84,207.85 184.19,205.88 180.15,203.51 C161.17,192.42 147.56,192.19 128.25,202.64 C123.71,205.10 120.00,206.74 119.99,206.30 C119.99,205.86 122.22,201.00 124.95,195.50 C134.11,177.05 134.05,168.68 124.63,149.75 C121.69,143.84 119.51,139.00 119.80,139.00 C120.08,139.00 125.31,141.46 131.41,144.46 C145.26,151.27 150.99,152.43 160.47,150.30 C168.62,148.48 173.88,146.34 182.13,141.50 C185.42,139.58 188.26,138.00 188.46,138.00 C188.65,138.00 186.82,141.49 184.38,145.75 C173.12,165.50 172.39,176.08 181.04,194.11 C182.73,197.63 185.21,202.19 186.57,204.25 ZM 126.41 199.85 C127.40,201.46 128.35,201.30 131.27,199.00 C132.67,197.90 134.53,197.00 135.41,197.00 C136.28,197.00 137.00,196.60 137.00,196.11 C137.00,193.77 161.30,192.53 167.00,194.57 C170.73,195.91 174.93,196.94 176.39,196.87 C176.88,196.85 177.63,197.41 178.07,198.11 C180.06,201.34 177.37,189.80 174.78,184.02 C172.34,178.57 171.98,176.74 172.51,172.52 C173.45,165.02 175.89,155.79 177.39,154.04 C179.16,151.98 179.94,148.52 178.98,146.96 C178.39,146.01 176.88,146.44 172.80,148.74 C168.46,151.19 165.76,151.92 158.95,152.45 C154.27,152.82 148.49,152.67 146.00,152.13 C136.90,150.13 132.44,148.63 130.06,146.80 C127.93,145.15 127.52,145.11 126.77,146.44 C126.20,147.47 126.81,149.54 128.61,152.73 C131.43,157.71 131.80,159.51 132.64,172.24 C133.06,178.62 132.77,181.01 130.97,185.74 C129.78,188.91 128.84,192.58 128.90,193.89 C128.95,195.20 128.26,196.82 127.35,197.49 C126.44,198.15 126.01,199.21 126.41,199.85 ZM 150.15 242.32 C147.37,244.57 121.03,243.49 112.82,240.78 C105.12,238.24 93.05,229.53 89.27,223.79 C80.49,210.46 78.00,195.19 81.57,176.50 C82.40,172.10 83.30,167.15 83.55,165.50 C83.80,163.84 85.12,161.68 86.50,160.67 C88.18,159.43 89.00,157.87 89.00,155.89 C89.00,154.04 90.08,151.75 91.93,149.72 C96.79,144.37 100.91,138.25 100.18,137.44 C99.81,137.02 100.02,136.98 100.66,137.34 C101.35,137.74 102.96,136.18 104.66,133.47 C106.22,130.98 108.52,128.68 109.77,128.36 C111.01,128.04 112.92,126.64 114.02,125.25 C115.11,123.87 116.00,123.03 116.00,123.40 C116.00,124.15 117.85,122.76 121.85,119.00 C123.31,117.63 125.40,116.01 126.50,115.40 C134.97,110.72 138.51,109.00 141.76,107.99 C143.82,107.35 146.92,106.19 148.65,105.41 C150.38,104.64 153.08,103.99 154.65,103.99 C156.22,103.98 159.86,103.35 162.75,102.58 C165.65,101.81 168.80,101.33 169.75,101.51 C170.71,101.70 171.84,101.88 172.25,101.92 C172.66,101.97 173.00,102.38 173.00,102.85 C173.00,103.32 169.74,103.99 165.75,104.34 C129.65,107.47 93.23,139.14 84.01,175.41 C81.65,184.69 81.35,198.99 83.36,206.50 C87.73,222.85 102.75,236.93 119.65,240.51 C146.77,246.26 177.44,234.65 200.50,209.90 C228.52,179.84 232.86,139.22 210.34,117.88 C202.12,110.07 195.47,106.92 182.00,104.43 L 175.50 103.22 L 181.07 103.11 C189.32,102.95 200.71,106.97 206.25,112.00 C207.77,113.38 209.20,114.28 209.43,114.00 C209.67,113.72 210.92,115.07 212.21,117.00 C213.49,118.93 215.55,120.94 216.77,121.49 C218.16,122.10 219.23,123.70 219.61,125.74 C219.95,127.53 220.55,129.00 220.96,129.00 C221.36,129.00 222.93,134.00 224.44,140.11 C226.74,149.43 227.07,152.36 226.48,158.36 C226.10,162.29 225.14,167.30 224.36,169.50 C223.58,171.70 222.68,175.52 222.36,178.00 C222.04,180.48 221.18,183.18 220.46,184.00 C219.74,184.82 217.76,188.29 216.07,191.69 C214.39,195.09 212.54,198.17 211.96,198.52 C211.39,198.88 209.80,200.94 208.44,203.10 C205.21,208.21 194.10,219.30 186.50,225.00 C183.20,227.47 180.27,229.72 180.00,230.00 C178.26,231.75 163.42,238.20 158.00,239.57 C154.43,240.48 150.89,241.71 150.15,242.32 ZM 173.96 258.56 C165.33,260.73 160.70,261.25 147.50,261.52 C147.11,261.53 146.72,261.54 146.35,261.54 C137.70,261.72 133.80,261.81 129.96,261.38 C126.63,261.01 123.35,260.26 117.06,258.86 C105.19,256.23 96.80,253.10 86.03,247.31 C63.46,235.16 43.99,215.04 33.82,193.35 C31.72,188.87 30.00,184.88 30.00,184.48 C30.00,182.36 33.11,186.88 36.03,193.25 C38.93,199.57 42.32,205.39 44.03,207.00 C44.33,207.27 46.23,210.04 48.27,213.14 C55.35,223.96 69.06,236.14 81.00,242.24 C84.03,243.78 88.30,246.15 90.50,247.51 C92.70,248.86 95.42,249.97 96.55,249.98 C97.68,249.99 99.03,250.39 99.55,250.87 C100.07,251.35 102.75,252.52 105.50,253.47 C108.25,254.43 111.40,255.56 112.50,255.98 C118.27,258.21 126.62,259.24 139.35,259.29 C153.54,259.35 171.76,257.71 175.50,256.02 C179.32,254.31 192.84,250.00 194.42,250.00 C195.29,250.00 196.00,249.55 196.00,249.00 C196.00,248.45 196.83,248.00 197.85,248.00 C198.86,248.00 200.73,247.10 202.00,246.00 C203.27,244.90 204.70,244.00 205.17,244.00 C206.01,244.00 213.99,239.10 215.00,237.96 C215.27,237.65 217.22,236.10 219.32,234.53 C228.30,227.78 245.00,209.40 245.00,206.25 C245.00,204.64 251.67,198.34 252.50,199.17 C253.55,200.22 240.48,217.65 233.06,225.08 C215.89,242.28 197.68,252.60 173.96,258.56 ZM 264.62 165.64 C263.82,169.41 262.71,173.62 262.15,175.00 C261.24,177.23 261.12,176.99 261.06,172.81 C261.03,170.23 261.48,167.82 262.06,167.46 C262.66,167.09 262.85,165.57 262.48,163.93 C262.07,162.05 262.40,160.27 263.43,158.80 C264.67,157.02 265.00,153.70 265.00,142.84 C265.00,134.77 264.59,128.86 264.00,128.50 C263.45,128.16 263.00,126.14 263.00,124.00 C263.00,121.86 262.55,119.84 262.00,119.50 C261.45,119.16 261.00,117.52 261.00,115.86 C261.00,112.50 257.53,103.11 252.35,92.50 C247.05,81.61 244.24,77.38 239.61,73.29 C237.25,71.20 234.75,68.38 234.06,67.00 C232.48,63.87 223.27,55.00 221.61,55.00 C220.93,55.00 219.05,53.59 217.44,51.87 C215.82,50.16 211.84,47.47 208.58,45.92 C205.33,44.36 202.41,42.67 202.08,42.17 C201.31,40.97 191.42,36.00 189.78,35.99 C189.08,35.99 187.15,35.27 185.50,34.39 C183.85,33.51 179.35,32.19 175.50,31.45 C171.65,30.72 166.70,29.56 164.50,28.88 C162.30,28.21 153.30,27.38 144.50,27.03 L 128.50 26.40 L 143.64 26.20 C165.93,25.90 183.58,29.87 202.17,39.36 C234.18,55.70 257.14,85.95 264.46,121.47 C266.58,131.70 266.66,156.00 264.62,165.64 ZM 37.96 88.90 C37.90,91.26 34.52,97.19 33.71,96.37 C32.72,95.39 40.21,81.82 46.19,73.75 C52.52,65.20 65.30,53.27 75.00,46.84 C83.17,41.43 98.17,33.91 104.51,32.06 C114.11,29.25 118.82,28.14 123.50,27.58 L 128.50 26.98 L 123.50 28.56 C120.75,29.43 117.03,30.39 115.24,30.68 C113.45,30.98 111.73,31.62 111.43,32.11 C111.13,32.60 109.59,33.00 108.00,33.00 C106.41,33.00 104.86,33.42 104.55,33.92 C104.23,34.43 102.74,35.12 101.23,35.45 C96.02,36.59 74.10,48.76 70.18,52.68 C69.43,53.43 67.62,54.67 66.16,55.44 C63.21,56.98 55.00,65.29 55.00,66.73 C55.00,67.23 53.09,69.47 50.75,71.71 C45.30,76.93 42.00,81.00 42.00,82.50 C42.00,83.16 41.10,84.50 40.00,85.50 C38.90,86.50 37.98,88.03 37.96,88.90 ZM 27.43 168.50 C27.71,170.15 27.59,172.05 27.17,172.73 C25.56,175.33 22.99,157.67 23.00,144.00 C23.00,129.27 24.51,119.30 28.55,107.25 C31.64,98.05 32.92,95.52 32.97,98.56 C32.99,99.69 32.34,101.49 31.53,102.56 C30.72,103.63 30.05,105.75 30.03,107.29 C30.01,108.82 29.38,111.07 28.62,112.29 C27.86,113.50 27.19,116.44 27.13,118.81 C27.06,121.17 26.57,123.94 26.02,124.96 C24.28,128.22 24.53,157.64 26.36,163.63 C26.67,164.66 27.15,166.85 27.43,168.50 ZM 28.98 176.97 C29.61,178.14 29.98,180.06 29.81,181.23 C29.57,182.90 29.22,182.56 28.16,179.60 C26.66,175.42 27.21,173.66 28.98,176.97 Z" fill="rgb(135,89,231)"/><path d="M 264.62 165.64 C264.71,165.24 264.79,164.81 264.86,164.36 C264.03,170.01 262.75,174.56 260.94,178.50 C258.97,182.82 253.81,195.61 253.28,197.50 C253.15,197.99 252.90,198.61 252.56,199.31 C252.55,199.25 252.53,199.20 252.50,199.17 C251.67,198.34 245.00,204.64 245.00,206.25 C245.00,209.40 228.30,227.78 219.32,234.53 C217.22,236.10 215.27,237.65 215.00,237.96 C213.99,239.10 206.01,244.00 205.17,244.00 C204.70,244.00 203.27,244.90 202.00,246.00 C200.73,247.10 198.86,248.00 197.85,248.00 C196.83,248.00 196.00,248.45 196.00,249.00 C196.00,249.55 195.29,250.00 194.42,250.00 C192.84,250.00 179.32,254.31 175.50,256.02 C171.76,257.71 153.54,259.35 139.35,259.29 C126.62,259.24 118.27,258.21 112.50,255.98 C111.40,255.56 108.25,254.43 105.50,253.47 C102.75,252.52 100.07,251.35 99.55,250.87 C99.03,250.39 97.68,249.99 96.55,249.98 C95.42,249.97 92.70,248.86 90.50,247.51 C88.30,246.15 84.03,243.78 81.00,242.24 C69.06,236.14 55.35,223.96 48.27,213.14 C46.23,210.04 44.33,207.27 44.03,207.00 C42.32,205.39 38.93,199.57 36.03,193.25 C33.11,186.88 30.00,182.36 30.00,184.48 C30.00,184.50 30.00,184.52 30.01,184.55 C29.67,183.62 29.33,182.67 29.01,181.72 C29.44,182.56 29.65,182.34 29.81,181.23 C29.98,180.06 29.61,178.14 28.98,176.97 C27.81,174.78 27.18,174.81 27.31,176.28 C26.94,174.99 26.58,173.67 26.24,172.34 C26.57,173.02 26.88,173.19 27.17,172.73 C27.59,172.05 27.71,170.15 27.43,168.50 C27.15,166.85 26.67,164.66 26.36,163.63 C24.53,157.64 24.28,128.22 26.02,124.96 C26.57,123.94 27.06,121.17 27.13,118.81 C27.19,116.44 27.86,113.50 28.62,112.29 C29.38,111.07 30.01,108.82 30.03,107.29 C30.05,105.75 30.72,103.63 31.53,102.56 C32.34,101.49 32.99,99.69 32.97,98.56 C32.95,97.29 32.72,96.99 32.22,97.75 C34.88,91.68 38.05,85.87 41.69,80.37 C37.06,87.69 32.96,95.63 33.71,96.37 C34.52,97.19 37.90,91.26 37.96,88.90 C37.98,88.03 38.90,86.50 40.00,85.50 C41.10,84.50 42.00,83.16 42.00,82.50 C42.00,81.00 45.30,76.93 50.75,71.71 C53.09,69.47 55.00,67.23 55.00,66.73 C55.00,65.29 63.21,56.98 66.16,55.44 C67.62,54.67 69.43,53.43 70.18,52.68 C74.10,48.76 96.02,36.59 101.23,35.45 C102.74,35.12 104.23,34.43 104.55,33.92 C104.86,33.42 106.41,33.00 108.00,33.00 C109.59,33.00 111.13,32.60 111.43,32.11 C111.73,31.62 113.45,30.98 115.24,30.68 C117.03,30.39 120.75,29.43 123.50,28.56 L 128.50 26.98 L 123.50 27.58 C122.86,27.66 122.21,27.74 121.55,27.85 C122.18,27.72 122.83,27.60 123.50,27.48 C125.71,27.07 128.41,26.75 131.39,26.52 L 144.50 27.03 C153.30,27.38 162.30,28.21 164.50,28.88 C166.70,29.56 171.65,30.72 175.50,31.45 C179.35,32.19 183.85,33.51 185.50,34.39 C187.15,35.27 189.08,35.99 189.78,35.99 C191.42,36.00 201.31,40.97 202.08,42.17 C202.41,42.67 205.33,44.36 208.58,45.92 C211.84,47.47 215.82,50.16 217.44,51.87 C219.05,53.59 220.93,55.00 221.61,55.00 C223.27,55.00 232.48,63.87 234.06,67.00 C234.75,68.38 237.25,71.20 239.61,73.29 C244.24,77.38 247.05,81.61 252.35,92.50 C257.53,103.11 261.00,112.50 261.00,115.86 C261.00,117.52 261.45,119.16 262.00,119.50 C262.55,119.84 263.00,121.86 263.00,124.00 C263.00,126.14 263.45,128.16 264.00,128.50 C264.59,128.86 265.00,134.77 265.00,142.84 C265.00,153.70 264.67,157.02 263.43,158.80 C262.40,160.27 262.07,162.05 262.48,163.93 C262.85,165.57 262.66,167.09 262.06,167.46 C261.48,167.82 261.03,170.23 261.06,172.81 C261.12,176.99 261.24,177.23 262.15,175.00 C262.71,173.62 263.82,169.41 264.62,165.64 ZM 150.15 242.32 C150.89,241.71 154.43,240.48 158.00,239.57 C163.42,238.20 178.26,231.75 180.00,230.00 C180.27,229.72 183.20,227.47 186.50,225.00 C194.10,219.30 205.21,208.21 208.44,203.10 C209.80,200.94 211.39,198.88 211.96,198.52 C212.54,198.17 214.39,195.09 216.07,191.69 C217.76,188.29 219.74,184.82 220.46,184.00 C221.18,183.18 222.04,180.48 222.36,178.00 C222.68,175.52 223.58,171.70 224.36,169.50 C225.14,167.30 226.10,162.29 226.48,158.36 C227.07,152.36 226.74,149.43 224.44,140.11 C222.93,134.00 221.36,129.00 220.96,129.00 C220.55,129.00 219.95,127.53 219.61,125.74 C219.23,123.70 218.16,122.10 216.77,121.49 C215.55,120.94 213.49,118.93 212.21,117.00 C210.92,115.07 209.67,113.72 209.43,114.00 C209.20,114.28 207.77,113.38 206.25,112.00 C200.71,106.97 189.32,102.95 181.07,103.11 L 175.50 103.22 L 182.00 104.43 C183.55,104.71 185.01,105.01 186.39,105.32 C179.01,104.15 167.70,104.10 159.37,105.18 C161.49,104.80 163.62,104.52 165.75,104.34 C169.74,103.99 173.00,103.32 173.00,102.85 C173.00,102.38 172.66,101.97 172.25,101.92 C171.84,101.88 170.71,101.70 169.75,101.51 C168.80,101.33 165.65,101.81 162.75,102.58 C159.86,103.35 156.22,103.98 154.65,103.99 C153.08,103.99 150.38,104.64 148.65,105.41 C146.92,106.19 143.82,107.35 141.76,107.99 C138.51,109.00 134.97,110.72 126.50,115.40 C125.40,116.01 123.31,117.63 121.85,119.00 C117.85,122.76 116.00,124.15 116.00,123.40 C116.00,123.03 115.11,123.87 114.02,125.25 C112.92,126.64 111.01,128.04 109.77,128.36 C108.52,128.68 106.22,130.98 104.66,133.47 C102.96,136.18 101.35,137.74 100.66,137.34 C100.02,136.98 99.81,137.02 100.18,137.44 C100.91,138.25 96.79,144.37 91.93,149.72 C90.08,151.75 89.00,154.04 89.00,155.89 C89.00,157.87 88.18,159.43 86.50,160.67 C85.12,161.68 83.80,163.84 83.55,165.50 C83.30,167.15 82.40,172.10 81.57,176.50 C78.00,195.19 80.49,210.46 89.27,223.79 C93.05,229.53 105.12,238.24 112.82,240.78 C121.03,243.49 147.37,244.57 150.15,242.32 ZM 126.41 199.85 C126.01,199.21 126.44,198.15 127.35,197.49 C128.26,196.82 128.95,195.20 128.90,193.89 C128.84,192.58 129.78,188.91 130.97,185.74 C132.77,181.01 133.06,178.62 132.64,172.24 C131.80,159.51 131.43,157.71 128.61,152.73 C126.81,149.54 126.20,147.47 126.77,146.44 C127.52,145.11 127.93,145.15 130.06,146.80 C132.44,148.63 136.90,150.13 146.00,152.13 C148.49,152.67 154.27,152.82 158.95,152.45 C165.76,151.92 168.46,151.19 172.80,148.74 C176.88,146.44 178.39,146.01 178.98,146.96 C179.94,148.52 179.16,151.98 177.39,154.04 C175.89,155.79 173.45,165.02 172.51,172.52 C171.98,176.74 172.34,178.57 174.78,184.02 C177.37,189.80 180.06,201.34 178.07,198.11 C177.63,197.41 176.88,196.85 176.39,196.87 C174.93,196.94 170.73,195.91 167.00,194.57 C161.30,192.53 137.00,193.77 137.00,196.11 C137.00,196.60 136.28,197.00 135.41,197.00 C134.53,197.00 132.67,197.90 131.27,199.00 C128.35,201.30 127.40,201.46 126.41,199.85 ZM 172.63 28.75 C163.61,26.87 154.14,26.06 143.64,26.20 L 134.16 26.33 C145.30,25.68 159.32,26.10 167.14,27.58 C168.97,27.93 170.80,28.32 172.63,28.75 ZM 228.50 57.72 C221.32,51.08 213.28,45.32 204.53,40.60 C209.11,43.00 213.43,45.63 217.36,48.44 C221.09,51.10 224.85,54.25 228.50,57.72 ZM 60.38 228.90 C68.13,236.07 76.82,242.35 86.03,247.31 C87.96,248.35 89.81,249.30 91.62,250.18 C80.11,244.77 69.53,237.58 60.38,228.90 ZM 26.16 115.27 C23.90,124.10 23.00,132.63 23.00,144.00 C22.99,150.47 23.57,157.83 24.34,163.52 C22.49,151.60 22.48,133.21 24.49,122.70 C24.97,120.19 25.53,117.71 26.16,115.27 ZM 84.01 175.41 C85.99,167.64 89.21,160.08 93.41,152.96 C87.65,162.81 83.83,173.43 82.52,184.14 C82.85,181.01 83.35,178.01 84.01,175.41 ZM 264.29 120.66 C262.80,113.67 260.70,106.89 258.05,100.38 C261.04,107.51 263.04,113.90 264.29,120.66 ZM 140.00 241.68 C161.31,239.75 183.14,228.53 200.50,209.90 C183.07,228.60 161.30,239.80 140.00,241.68 ZM 30.80 186.63 C31.50,188.30 32.60,190.74 33.82,193.35 C35.68,197.31 37.84,201.22 40.28,205.03 C36.45,199.16 33.35,193.13 30.80,186.63 ZM 91.41 222.38 C92.45,223.67 93.60,224.97 94.85,226.28 C99.00,230.63 104.02,234.30 109.26,236.91 C102.33,233.53 96.13,228.46 91.41,222.38 ZM 82.03 194.28 C82.15,199.82 82.76,204.50 84.03,208.73 C83.78,207.99 83.56,207.25 83.36,206.50 C82.51,203.34 82.08,198.97 82.03,194.28 ZM 94.54 36.12 C90.34,38.10 85.69,40.51 81.54,42.86 C84.75,40.97 88.08,39.20 91.51,37.55 C92.56,37.05 93.57,36.57 94.54,36.12 ZM 114.43 29.32 C111.89,29.95 108.89,30.78 105.12,31.88 C108.01,30.92 111.00,30.10 114.43,29.32 ZM 233.07 225.08 C228.30,229.85 223.46,234.09 218.45,237.85 C223.46,234.09 228.30,229.85 233.06,225.08 C236.08,222.06 240.04,217.38 243.60,212.82 C240.17,217.29 236.36,221.78 233.07,225.08 ZM 254.48 92.46 C253.05,89.57 251.51,86.75 249.86,83.99 C251.59,86.83 253.14,89.65 254.46,92.41 ZM 193.87 107.42 C196.36,108.29 198.59,109.29 200.71,110.50 C198.70,109.38 196.50,108.41 193.87,107.42 ZM 64.30 55.05 C61.88,57.13 59.47,59.33 57.17,61.55 C59.45,59.30 61.83,57.13 64.30,55.05 ZM 266.06 140.25 C266.00,137.36 265.88,134.52 265.70,131.86 C265.90,134.52 266.01,137.30 266.06,140.25 ZM 28.81 106.47 C28.73,106.73 28.64,106.99 28.55,107.25 C28.10,108.59 27.68,109.91 27.29,111.20 C27.77,109.61 28.27,108.04 28.81,106.47 Z" fill="rgb(140,82,253)"/><path d="M 0.00 138.50 L 0.00 0.00 L 146.50 0.00 L 293.00 0.00 L 293.00 138.50 L 293.00 277.00 L 146.50 277.00 L 0.00 277.00 L 0.00 138.50 ZM 173.96 258.56 C197.68,252.60 215.88,242.29 233.07,225.08 C241.01,217.12 251.99,202.15 253.28,197.50 C253.81,195.61 258.97,182.82 260.94,178.50 C264.53,170.67 266.06,160.42 266.08,143.97 C266.12,123.24 263.37,111.03 254.46,92.41 C246.88,76.57 231.91,58.82 217.36,48.44 C203.63,38.64 185.29,31.03 167.14,27.58 C156.45,25.56 134.19,25.51 123.50,27.48 C109.20,30.12 102.77,32.14 91.51,37.55 C55.90,54.64 31.61,85.50 24.49,122.70 C22.26,134.39 22.52,155.82 25.03,167.26 C30.21,190.79 39.11,207.05 56.84,225.39 C72.90,242.02 94.01,253.75 117.06,258.86 C130.92,261.94 130.20,261.88 147.50,261.52 C160.70,261.25 165.33,260.73 173.96,258.56 ZM 119.18 240.47 C110.62,238.61 101.59,233.35 94.85,226.28 C85.39,216.36 82.03,207.51 82.01,192.41 C81.96,155.66 113.09,117.95 153.00,106.42 C162.24,103.75 183.26,103.73 191.00,106.39 C199.89,109.44 204.05,111.91 210.34,117.88 C232.86,139.22 228.52,179.84 200.50,209.90 C177.39,234.70 146.35,246.37 119.18,240.47 ZM 186.57 204.25 C185.21,202.19 182.73,197.63 181.04,194.11 C172.39,176.08 173.12,165.50 184.38,145.75 C186.82,141.49 188.65,138.00 188.46,138.00 C188.26,138.00 185.42,139.58 182.13,141.50 C173.88,146.34 168.62,148.48 160.47,150.30 C150.99,152.43 145.26,151.27 131.41,144.46 C125.31,141.46 120.08,139.00 119.80,139.00 C119.51,139.00 121.69,143.84 124.63,149.75 C134.05,168.68 134.11,177.05 124.95,195.50 C122.22,201.00 119.99,205.86 119.99,206.30 C120.00,206.74 123.71,205.10 128.25,202.64 C147.56,192.19 161.17,192.42 180.15,203.51 C184.19,205.88 187.84,207.85 188.26,207.91 C188.69,207.96 187.92,206.31 186.57,204.25 Z" fill="rgb(254,254,254)"/></g></svg>`,
  
  /**
   * Initialize word selector
   */
  async init() {
    console.log('[WordSelector] Initializing...');
    
    // SVG is now inline, no fetch needed
    console.log('[WordSelector] Purple logo SVG available inline');
    // Update any existing buttons
    this.updateAllMagicMeaningButtons();
    
    // Bind the handler once for proper cleanup
    this.boundDoubleClickHandler = this.handleDoubleClick.bind(this);
    
    // Inject styles for word highlights
    this.injectStyles();
    
    // Setup global click handler to close popups (only sticky ones)
    document.addEventListener('click', (e) => {
      // Get all sticky popups
      const stickyPopups = document.querySelectorAll('.vocab-word-popup[data-sticky="true"]');
      
      if (stickyPopups.length === 0) return;
      
      // Check if click is outside popup and not on an explained word
      const clickedInsidePopup = e.target.closest('.vocab-word-popup');
      const clickedOnWord = e.target.closest('.vocab-word-explained');
      
      // Also check if clicking on popup buttons (speaker, close, get more examples)
      const clickedOnPopupButton = e.target.closest('.vocab-word-popup-speaker') || 
                                   e.target.closest('.vocab-word-popup-close') || 
                                   e.target.closest('.vocab-word-popup-button') ||
                                   e.target.closest('.vocab-word-popup-bookmark');
      
      // Check if clicking inside the ask AI modal - don't close word popup in this case
      const clickedInsideAskAIModal = e.target.closest('.word-web-search-modal');
      
      // Check if any sticky popup has mouse inside it
      const hasMouseInsidePopup = Array.from(stickyPopups).some(popup => 
        popup.getAttribute('data-mouse-inside') === 'true'
      );
      
      // Close popup if clicking outside popup, word, popup buttons, ask AI modal, and no mouse is inside any popup
      if (!clickedInsidePopup && !clickedOnWord && !clickedOnPopupButton && !clickedInsideAskAIModal && !hasMouseInsidePopup) {
        // Use a longer delay to ensure the click event has fully processed
        setTimeout(() => {
          // Double-check that we still have sticky popups (in case they were closed by other means)
          const currentStickyPopups = document.querySelectorAll('.vocab-word-popup[data-sticky="true"]');
          if (currentStickyPopups.length > 0) {
            this.hideAllPopups();
          }
        }, 10);
      }
      
      // CASE: Both word popup and Ask AI modal are open
      // If clicking outside both, close the Ask AI modal (but keep word popup open)
      const askAIModals = document.querySelectorAll('.word-web-search-modal');
      if (stickyPopups.length > 0 && askAIModals.length > 0) {
        // Check if click is outside both modals
        const clickedOnAskAIButton = e.target.closest('.vocab-word-popup-ask-button');
        
        // If clicking outside both word popup AND Ask AI modal (and not on Ask AI button)
        if (!clickedInsidePopup && !clickedInsideAskAIModal && !clickedOnAskAIButton) {
          // Close all Ask AI modals
          askAIModals.forEach(modal => {
            // IMPORTANT: Save chat history before closing
            const modalWord = modal.getAttribute('data-word');
            const normalizedWord = modalWord ? modalWord.toLowerCase() : '';
            const chatHistoryJson = modal.getAttribute('data-chat-history') || '[]';
            const initialContext = modal.getAttribute('data-initial-context') || '';
            try {
              const chatHistory = JSON.parse(chatHistoryJson);
              if (normalizedWord && this.explainedWords.has(normalizedWord)) {
                const wordData = this.explainedWords.get(normalizedWord);
                wordData.askAIChatHistory = chatHistory;
                wordData.askAIInitialContext = initialContext;
                console.log('[WordSelector] Saved chat history before closing via click-outside');
              }
            } catch (e) {
              console.error('[WordSelector] Error saving chat history on click-outside:', e);
            }
            
            // Find the associated Ask AI button for this modal
            const wordPopup = document.querySelector(`.vocab-word-popup[data-word="${modalWord}"]`);
            if (wordPopup) {
              const askButton = wordPopup.querySelector('.vocab-word-popup-ask-button');
              if (askButton) {
                // Find the word element to animate to word center (same as word-meaning modal)
                let wordElement = null;
                if (normalizedWord) {
                  // First try to find by data-popup-id="active"
                  const activeWordElements = document.querySelectorAll('[data-popup-id="active"]');
                  for (const element of activeWordElements) {
                    const elementWord = element.getAttribute('data-word') || element.textContent.trim().toLowerCase();
                    if (elementWord === normalizedWord) {
                      wordElement = element;
                      break;
                    }
                  }
                  
                  // If not found, try to find any vocab-word-explained element with matching data-word
                  if (!wordElement) {
                    const allExplainedWords = document.querySelectorAll('.vocab-word-explained[data-word]');
                    for (const element of allExplainedWords) {
                      const elementWord = element.getAttribute('data-word');
                      if (elementWord && elementWord.toLowerCase() === normalizedWord) {
                        wordElement = element;
                        break;
                      }
                    }
                  }
                  
                  // If still not found, use the stored highlight reference from explainedWords map
                  if (
                    !wordElement &&
                    this.explainedWords &&
                    typeof this.explainedWords.has === 'function' &&
                    this.explainedWords.has(normalizedWord)
                  ) {
                    const explainedEntry = this.explainedWords.get(normalizedWord);
                    if (explainedEntry && explainedEntry.highlights && explainedEntry.highlights.size > 0) {
                      for (const highlightElement of explainedEntry.highlights) {
                        if (highlightElement && document.body.contains(highlightElement)) {
                          wordElement = highlightElement;
                          break;
                        }
                      }
                    }
                  }
                }
                
                console.log('[WordSelector] Clicking outside both modals - closing Ask AI modal', {
                  hasWordElement: !!wordElement,
                  willAnimateToWordCenter: !!wordElement
                });
                // Pass wordElement so modal animates to word center instead of button center
                this.closeAskAIModalWithAnimation(modal, askButton, wordElement);
              }
            } else {
              // Fallback: if we can't find the button, just remove the modal
              console.log('[WordSelector] Clicking outside both modals - removing Ask AI modal (no button found)');
              modal.remove();
            }
          });
        }
      }
    }, false); // Use bubble phase instead of capture phase
    
    // Check if extension is enabled for current domain
    const isExtensionEnabled = await this.checkExtensionEnabled();
    
    if (isExtensionEnabled) {
      this.enable();
    }
    
    console.log('[WordSelector] Initialized. Enabled:', isExtensionEnabled);
  },
  
  /**
   * Check if extension is enabled from storage
   * @returns {Promise<boolean>}
   */
  async checkExtensionEnabled() {
    try {
      const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
      const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
      let isEnabled = result[GLOBAL_STORAGE_KEY];
      
      // If not found, create it and set to true (enabled by default)
      if (isEnabled === undefined) {
        isEnabled = true;
        await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: isEnabled });
        console.log('[WordSelector] Global toggle state not found, created with default value: true');
      }
      
      return isEnabled;
    } catch (error) {
      console.error('[WordSelector] Error checking global extension state:', error);
      return true; // Default to true (enabled) on error
    }
  },
  
  /**
   * Enable word selector
   */
  enable() {
    if (this.isEnabled) return;
    
    this.isEnabled = true;
    document.addEventListener('dblclick', this.boundDoubleClickHandler);
    console.log('[WordSelector] Enabled');
  },
  
  /**
   * Disable word selector
   */
  disable() {
    if (!this.isEnabled) return;
    
    this.isEnabled = false;
    document.removeEventListener('dblclick', this.boundDoubleClickHandler);
    console.log('[WordSelector] Disabled');
  },
  
  /**
   * Check if an element or range is within allowed selection areas
   * Allowed: Main website content and .vocab-custom-content-editor-content
   * Disallowed: All other extension UI components
   * @param {Element|Range} elementOrRange - The element or range to check
   * @returns {boolean} True if selection is allowed, false otherwise
   */
  isSelectionAllowed(elementOrRange) {
    // Get the container element from element or range
    let containerElement = null;
    
    if (elementOrRange instanceof Range) {
      // For range, check the common ancestor container
      containerElement = elementOrRange.commonAncestorContainer;
      // If it's a text node, get its parent
      if (containerElement && containerElement.nodeType === Node.TEXT_NODE) {
        containerElement = containerElement.parentElement;
      } else if (containerElement && containerElement.nodeType === Node.ELEMENT_NODE) {
        containerElement = containerElement;
      }
    } else if (elementOrRange instanceof Element) {
      containerElement = elementOrRange;
    } else if (elementOrRange instanceof Node) {
      // For other node types (like text nodes), get parent element
      if (elementOrRange.nodeType === Node.TEXT_NODE) {
        containerElement = elementOrRange.parentElement;
      } else if (elementOrRange.nodeType === Node.ELEMENT_NODE) {
        containerElement = elementOrRange;
      }
    }
    
    // Ensure we have an Element (not a Text node or null)
    if (!containerElement || !(containerElement instanceof Element)) {
      return false;
    }
    
    // First check: If inside .vocab-custom-content-editor-content, allow it
    // This is the exception - even though it's inside vocab-custom-content-modal,
    // we want to allow selection in the editor content
    const editorContent = containerElement.closest('.vocab-custom-content-editor-content');
    if (editorContent) {
      return true;
    }
    
    // Second check: If inside any extension UI component, disallow it
    // List of extension UI component selectors
    const extensionUISelectors = [
      '.vocab-helper-panel',
      '.vocab-topics-modal',
      '.vocab-topics-modal-overlay',
      '.vocab-chat-dialog',
      '.vocab-custom-content-modal',
      '.vocab-custom-content-info-banner',
      '.vocab-word-popup',
      '.vocab-notification'
    ];
    
    // Check if the container is inside any extension UI component
    for (const selector of extensionUISelectors) {
      if (containerElement.closest(selector)) {
        return false;
      }
    }
    
    // If not in extension UI and not in editor content, it's main website content - allow it
    return true;
  },
  
  /**
   * Handle double-click event
   * @param {MouseEvent} event
   */
  handleDoubleClick(event) {
    // CRITICAL: Check if feature is enabled
    if (!this.isEnabled) {
      return;
    }
    
    // Check if clicking on an existing highlight to deselect it
    const clickedHighlight = event.target.closest('.vocab-word-highlight');
    if (clickedHighlight) {
      // Allow deselection of highlights anywhere (they should be removable)
      const word = clickedHighlight.getAttribute('data-word');
      if (word) {
        // Check if it's a green explained word - if so, use removeExplainedWord
        if (clickedHighlight.classList.contains('vocab-word-explained')) {
          this.removeExplainedWord(word);
          console.log('[WordSelector] Explained word deselected via double-click:', word);
        } else {
          this.removeWord(word);
          console.log('[WordSelector] Word deselected via double-click:', word);
        }
      }
      return;
    }
    
    // Check if selection is allowed in the clicked area
    if (!this.isSelectionAllowed(event.target)) {
      console.log('[WordSelector] Selection not allowed - clicked in extension UI');
      return;
    }
    
    // IMPORTANT: Don't prevent default - let Chrome's default double-click selection work
    // This allows the yellow highlight to appear naturally
    // Use setTimeout to process after Chrome's default behavior completes
    setTimeout(() => {
      // Get the selected text after Chrome's default selection
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();
    
      console.log('[WordSelector] ===== DOUBLE CLICK EVENT =====');
      console.log('[WordSelector] Selected text:', selectedText);
      
      // Check if a word was selected
      if (!selectedText || selectedText.length === 0) {
        console.log('[WordSelector] No text selected');
        return;
      }
      
      // Only process single words (no spaces)
      if (/\s/.test(selectedText)) {
        console.log('[WordSelector] Multiple words selected, skipping');
        return;
      }
      
      // Get the range and validate
      if (selection.rangeCount === 0) {
        console.log('[WordSelector] No valid range');
        return;
      }
      
      const range = selection.getRangeAt(0);
      
      // IMPORTANT: Also validate the selection range itself
      // This ensures the selected text is not from extension UI
      if (!this.isSelectionAllowed(range)) {
        console.log('[WordSelector] Selection not allowed - range is in extension UI');
        selection.removeAllRanges();
        return;
      }
      
      const normalizedWord = selectedText.toLowerCase();
      console.log('[WordSelector] Original word:', selectedText);
      console.log('[WordSelector] Normalized word:', normalizedWord);
      
      // Check if word is already explained (green) - if so, deselect it
      if (this.explainedWords.has(normalizedWord)) {
        // Check if clicking on the green highlight itself
        const clickedHighlight = event.target.closest('.vocab-word-explained');
        if (clickedHighlight) {
          // Allow deselection of green highlights
          this.removeExplainedWord(selectedText);
          selection.removeAllRanges();
          console.log('[WordSelector] Explained word deselected:', selectedText);
          return;
        }
      }
      
      // Check if word is already selected (purple) - if so, deselect it
      if (this.isWordSelected(normalizedWord)) {
        this.removeWord(selectedText);
        selection.removeAllRanges();
        console.log('[WordSelector] Word deselected:', selectedText);
        return;
      }
      
      // Add word to selected set (O(1) operation)
      this.addWord(selectedText);
      
      // Create span without background color (no vocab-word-highlight class initially)
      const highlight = this.createWordSpanWithoutBackground(range, selectedText, normalizedWord);
      
      // Clear the selection AFTER creating the span (allows Chrome's default highlight to show first)
      // Use a small delay to ensure Chrome's default behavior completes
      setTimeout(() => {
        selection.removeAllRanges();
      }, 50);
      
      console.log('[WordSelector] ✓ Word selected:', selectedText);
      console.log('[WordSelector] ✓ Normalized word stored:', normalizedWord);
      console.log('[WordSelector] ✓ Total selected words:', this.selectedWords.size);
      
      // Store pending word data
      this.pendingWords.set(normalizedWord, {
        word: selectedText,
        range: range.cloneRange(),
        highlight: highlight
      });
      
      // Show magic meaning button above the word
      this.showWordMagicMeaningButton(highlight, selectedText, normalizedWord);
    }, 0); // Process after Chrome's default double-click behavior
  },
  
  /**
   * Create and show loading spinner above a word highlight
   * @param {HTMLElement} highlight - The highlight element
   */
  showLoadingSpinner(highlight) {
    // Remove any existing spinner first
    this.hideLoadingSpinner(highlight);
    
    // Create spinner container with white circular background
    const spinnerContainer = document.createElement('div');
    spinnerContainer.className = 'vocab-word-loading-spinner-container';
    
    // Create spinner element
    const spinner = document.createElement('div');
    spinner.className = 'vocab-word-loading-spinner';
    
    spinnerContainer.appendChild(spinner);
    highlight.appendChild(spinnerContainer);
    
    console.log('[WordSelector] Loading spinner shown');
  },
  
  /**
   * Hide and remove loading spinner from a word highlight
   * @param {HTMLElement} highlight - The highlight element
   */
  hideLoadingSpinner(highlight) {
    const existingSpinner = highlight.querySelector('.vocab-word-loading-spinner-container');
    if (existingSpinner) {
      existingSpinner.remove();
      console.log('[WordSelector] Loading spinner removed');
    }
  },
  
  /**
   * Process word explanation API call for a single word
   * This is called automatically when a word is double-clicked
   * @param {string} word - The original word (with case)
   * @param {string} normalizedWord - The normalized word (lowercase)
   * @param {HTMLElement} highlight - The highlight element (optional, will be looked up if not provided)
   */
  async processWordExplanation(word, normalizedWord, highlight = null) {
    console.log('[WordSelector] ===== PROCESSING WORD EXPLANATION =====');
    console.log('[WordSelector] Word:', word);
    console.log('[WordSelector] Normalized word:', normalizedWord);
    console.log('[WordSelector] Highlight provided:', highlight !== null);
    
    // Check if word is already explained (green)
    if (this.explainedWords.has(normalizedWord)) {
      console.log('[WordSelector] Word already explained, skipping API call:', normalizedWord);
      return;
    }
    
    // Get the highlight element for this word if not provided
    if (!highlight) {
      const highlights = this.wordToHighlights.get(normalizedWord);
      if (!highlights || highlights.size === 0) {
        console.warn('[WordSelector] No highlights found for word:', normalizedWord);
        return;
      }
      // Use the most recently added highlight (last in the Set)
      highlight = Array.from(highlights)[highlights.size - 1];
    }
    
    // Check if highlight is already explained (has green class)
    if (highlight.classList.contains('vocab-word-explained')) {
      console.log('[WordSelector] Highlight already has green background, skipping API call');
      return;
    }
    
    // Build payload for this single word
    const docText = this.getDocumentText();
    const positions = this.findWordPositionsInDocument(normalizedWord);
    
    if (positions.length === 0) {
      console.warn('[WordSelector] No positions found for word:', normalizedWord);
      return;
    }
    
    // Use the first position
    const position = positions[0];
    const context = this.extractWordContext(docText, position, word.length);
    
    console.log('[WordSelector] Context extracted:', {
      textStartIndex: context.textStartIndex,
      textPreview: context.text.substring(0, 50) + '...',
      wordIndexInContext: context.wordIndexInText
    });
    
    // Build payload segment
    const payloadSegment = {
      textStartIndex: context.textStartIndex,
      text: context.text,
      important_words_location: [{
        word: word,
        index: context.wordIndexInText,
        length: word.length
      }],
      _wordHighlights: [highlight] // Keep for internal tracking
    };
    
    // Remove purple cross button and add pulsating animation
    const existingBtn = highlight.querySelector('.vocab-word-remove-btn');
    if (existingBtn) {
      existingBtn.remove();
    }
    
    // Add pulsating purple animation
    highlight.classList.add('vocab-word-loading');
    console.log('[WordSelector] Added loading animation to highlight');
    
    // Show loading spinner above the word
    this.showLoadingSpinner(highlight);
    
    // Prepare API payload (remove internal tracking property)
    const apiPayload = [{
      textStartIndex: payloadSegment.textStartIndex,
      text: payloadSegment.text,
      important_words_location: payloadSegment.important_words_location
    }];
    
    console.log('[WordSelector] Sending API request for word:', word);
    
    // Call ApiService with SSE
    ApiService.explainWords(
      apiPayload,
      // onEvent callback - called for each word explanation
      (eventData) => {
        console.log('[WordSelector] ===== SSE EVENT RECEIVED FOR DOUBLE-CLICKED WORD =====');
        console.log('[WordSelector] Full event data:', JSON.stringify(eventData, null, 2));
        
        const wordInfo = eventData.word_info;
        if (!wordInfo) {
          console.warn('[WordSelector] No word_info in event data');
          return;
        }
        
        // Use word_info.location.word for matching
        const targetWord = wordInfo.location?.word || wordInfo.word;
        const normalizedTargetWord = targetWord.toLowerCase().trim();
        
        console.log('[WordSelector] Processing word explanation:', {
          targetWord: targetWord,
          normalizedTargetWord: normalizedTargetWord,
          originalWord: word,
          originalNormalized: normalizedWord
        });
        
        // Find the matching highlight
        const wordHighlight = highlight;
        const highlightDataWord = wordHighlight.getAttribute('data-word');
        
        // Check if this is the correct highlight
        if (highlightDataWord && highlightDataWord.toLowerCase() === normalizedTargetWord) {
          console.log('[WordSelector] ===== APPLYING GREEN BACKGROUND =====');
          console.log('[WordSelector] ✓ Found matching highlight for word:', targetWord);
          
          // Remove pulsating animation
          wordHighlight.classList.remove('vocab-word-loading');
          
          // Hide loading spinner
          this.hideLoadingSpinner(wordHighlight);
          
          // Remove old purple cross button if exists
          const oldBtn = wordHighlight.querySelector('.vocab-word-remove-btn');
          if (oldBtn) {
            oldBtn.remove();
          }
          
          // Force a reflow to ensure the element is ready for animation
          void wordHighlight.offsetWidth;
          
          // Change background to green with popup animation
          wordHighlight.classList.add('vocab-word-explained', 'word-popup');
          
          // Force another reflow to trigger the animation
          void wordHighlight.offsetWidth;
          
          // Remove popup animation after it completes (0.6s)
          setTimeout(() => {
            wordHighlight.classList.remove('word-popup');
            // Re-enable transition after animation completes
            wordHighlight.style.transition = '';
            wordHighlight.style.willChange = '';
          }, 600);
          
          // Store explanation data on the element
          wordHighlight.setAttribute('data-meaning', wordInfo.meaning);
          wordHighlight.setAttribute('data-examples', JSON.stringify(wordInfo.examples));
          
          // Store word explanation in analysis data for persistence
          if (ButtonPanel.topicsModal && ButtonPanel.topicsModal.customContentModal && ButtonPanel.topicsModal.customContentModal.activeTabId) {
            const activeContent = ButtonPanel.topicsModal.customContentModal.getContentByTabId(parseInt(ButtonPanel.topicsModal.customContentModal.activeTabId));
            if (activeContent && activeContent.analysis) {
              // Check if this word already exists in wordMeanings
              const existingWordIndex = activeContent.analysis.wordMeanings.findIndex(w => 
                w.word.toLowerCase() === normalizedTargetWord
              );
              
              const wordExplanationData = {
                word: targetWord,
                normalizedWord: normalizedTargetWord,
                meaning: wordInfo.meaning,
                examples: wordInfo.examples,
                shouldAllowFetchMoreExamples: wordInfo.shouldAllowFetchMoreExamples || false,
                textStartIndex: wordInfo.textStartIndex,
                location: wordInfo.location,
                timestamp: new Date().toISOString()
              };
              
              if (existingWordIndex !== -1) {
                // Update existing word explanation
                activeContent.analysis.wordMeanings[existingWordIndex] = wordExplanationData;
                console.log('[WordSelector] Updated existing word explanation in analysis data');
              } else {
                // Add new word explanation
                activeContent.analysis.wordMeanings.push(wordExplanationData);
                console.log('[WordSelector] Added new word explanation to analysis data');
              }
            }
          }
          
          // Add green wireframe cross button
          const greenCrossBtn = this.createRemoveExplainedButton(targetWord);
          wordHighlight.appendChild(greenCrossBtn);
          
          // Store in explainedWords map
          // Extract languageCode from eventData (could be at top level or in word_info)
          const languageCode = eventData.languageCode || wordInfo.languageCode || null;
          
          if (!this.explainedWords.has(normalizedTargetWord)) {
            this.explainedWords.set(normalizedTargetWord, {
              word: targetWord,
              meaning: wordInfo.meaning,
              examples: wordInfo.examples,
              shouldAllowFetchMoreExamples: wordInfo.shouldAllowFetchMoreExamples || false,
              hasCalledGetMoreExamples: false,
              languageCode: languageCode,
              highlights: new Set()
            });
          } else {
            // Update existing entry with languageCode if not already set
            const existingEntry = this.explainedWords.get(normalizedTargetWord);
            if (!existingEntry.languageCode && languageCode) {
              existingEntry.languageCode = languageCode;
            }
          }
          this.explainedWords.get(normalizedTargetWord).highlights.add(wordHighlight);
          
          // Setup hover and click interactions for this word
          this.setupWordInteractions(wordHighlight);
          
          // Update button states
          ButtonPanel.updateButtonStatesFromSelections();
          
          // Remove from selectedWords (since it's now explained)
          this.selectedWords.delete(normalizedWord);
          
          console.log('[WordSelector] ===== GREEN BACKGROUND APPLIED SUCCESSFULLY =====');
          console.log('[WordSelector] ✓ Word explanation complete:', targetWord);
          
          // Automatically show word meaning popup after green background is applied
          // Use a small delay to ensure DOM is updated and breathing animation starts
          setTimeout(() => {
            console.log('[WordSelector] ===== AUTO-SHOWING WORD MEANING POPUP =====');
            console.log('[WordSelector] Word highlight element:', {
              element: wordHighlight,
              isInDOM: document.body.contains(wordHighlight),
              classes: wordHighlight.className,
              hasExplainedClass: wordHighlight.classList.contains('vocab-word-explained'),
              textContent: wordHighlight.textContent.trim(),
              dataWord: wordHighlight.getAttribute('data-word'),
              normalizedWord: normalizedWord,
              isInExplainedWords: this.explainedWords.has(normalizedWord)
            });
            
            // Validate element before showing popup
            if (!wordHighlight || !document.body.contains(wordHighlight)) {
              console.error('[WordSelector] ✗ Word highlight element is not in DOM, cannot show popup');
              return;
            }
            
            if (!wordHighlight.classList.contains('vocab-word-explained')) {
              console.error('[WordSelector] ✗ Word highlight does not have vocab-word-explained class, cannot show popup');
              console.error('[WordSelector] Current classes:', wordHighlight.className);
              return;
            }
            
            if (!this.explainedWords.has(normalizedWord)) {
              console.error('[WordSelector] ✗ Word not found in explainedWords map, cannot show popup');
              console.error('[WordSelector] Available words in map:', Array.from(this.explainedWords.keys()));
              return;
            }
            
            console.log('[WordSelector] ✓ All validations passed, showing popup');
            this.showWordPopup(wordHighlight, true); // Show as sticky popup
          }, 100);
        } else {
          console.warn('[WordSelector] Highlight data-word mismatch:', {
            highlightDataWord: highlightDataWord,
            normalizedTargetWord: normalizedTargetWord
          });
        }
      },
      // onComplete callback
      () => {
        console.log('[WordSelector] Word explanation API call completed');
      },
      // onError callback
      async (error) => {
        console.error('[WordSelector] Error during word explanation:', error);
        console.log('[WordSelector] Error details:', {
          status: error.status,
          errorCode: error.errorCode,
          message: error.message
        });
        
        const normalizedWord = highlight.getAttribute('data-word')?.toLowerCase();
        
        // Remove pulsating animation on error
        highlight.classList.remove('vocab-word-loading');
        
        // Hide loading spinner on error
        this.hideLoadingSpinner(highlight);
        
        // Check if it's a LOGIN_REQUIRED error FIRST (regardless of status code)
        // This takes precedence over 429 rate limit errors
        // Even if status is 429, if errorCode is LOGIN_REQUIRED, show login modal instead of error banner
        if (error.errorCode === 'LOGIN_REQUIRED') {
          console.log('[WordSelector] LOGIN_REQUIRED error detected (status:', error.status, '), showing login modal - NOT showing error banner');
          
          // Hide any existing error banners first
          if (typeof ErrorBanner !== 'undefined') {
            ErrorBanner.hide();
            console.log('[WordSelector] Hid any existing error banners');
          }
          
          // Show login modal (centered) - do NOT show error banner
          if (typeof LoginModal !== 'undefined') {
            LoginModal.show('Please sign in to get word meanings', 'WORDS_EXPLANATION');
          } else {
            console.warn('[WordSelector] LoginModal is not available');
          }
          
          // Revert - remove highlight and clean up
          if (normalizedWord) {
            // Clean up any remaining pending data or button wrappers
            this.pendingWords.delete(normalizedWord);
            this.hideWordMagicMeaningButton(normalizedWord);
            // Remove the word (which will remove the highlight)
            this.removeWord(normalizedWord);
          }
          
          return;
        }
        
        // Check if it's a 429 rate limit error (but NOT LOGIN_REQUIRED)
        // Explicitly check that errorCode is NOT LOGIN_REQUIRED to prevent showing error banner for LOGIN_REQUIRED
        const isRateLimit = (error.status === 429 || error.message?.includes('429') || error.message?.includes('Rate limit'));
        const isNotLoginRequired = error.errorCode !== 'LOGIN_REQUIRED';
        
        if (isRateLimit && isNotLoginRequired) {
          console.log('[WordSelector] 429 rate limit error detected (NOT LOGIN_REQUIRED)');
          // Error banner functionality removed - just show notification
          TextSelector.showNotification('You are requesting too fast, please retry after few seconds');
          
          // Revert - remove highlight and clean up
          if (normalizedWord) {
            // Clean up any remaining pending data or button wrappers
            this.pendingWords.delete(normalizedWord);
            this.hideWordMagicMeaningButton(normalizedWord);
            // Remove the word (which will remove the highlight)
            this.removeWord(normalizedWord);
          }
        } else {
          // Show error notification for other errors
          TextSelector.showNotification('Error getting word meaning. Please try again.');
          
          // Revert - remove highlight and clean up
          if (normalizedWord) {
            // Clean up any remaining pending data or button wrappers
            this.pendingWords.delete(normalizedWord);
            this.hideWordMagicMeaningButton(normalizedWord);
            // Remove the word (which will remove the highlight)
            this.removeWord(normalizedWord);
            console.log('[WordSelector] Removed word due to API error:', normalizedWord);
          } else {
            // Fallback: directly remove the highlight if we can't get the word
            this.removeHighlight(highlight);
            console.log('[WordSelector] Removed highlight directly due to API error');
          }
        }
      }
    );
  },
  
  /**
   * Check if a word is already selected
   * @param {string} word - The word to check
   * @returns {boolean}
   */
  isWordSelected(word) {
    const normalizedWord = word.toLowerCase();
    return this.selectedWords.has(normalizedWord); // O(1) operation
  },
  
  /**
   * Add a word to the selected words set
   * @param {string} word - The word to add
   */
  addWord(word) {
    const normalizedWord = word.toLowerCase().trim();
    console.log(`[WordSelector] Adding word: "${word}" (normalized: "${normalizedWord}")`);
    this.selectedWords.add(normalizedWord); // O(1) operation
    console.log(`[WordSelector] Selected words now:`, Array.from(this.selectedWords));
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Remove a word from the selected words set
   * @param {string} word - The word to remove
   */
  removeWord(word) {
    const normalizedWord = word.toLowerCase().trim();
    
    console.log(`[WordSelector] Removing word: "${word}" (normalized: "${normalizedWord}")`);
    
    // Check if word is in explainedWords - if so, use removeExplainedWord instead
    if (this.explainedWords.has(normalizedWord)) {
      console.log('[WordSelector] Word is in explainedWords, using removeExplainedWord instead');
      this.removeExplainedWord(word);
      return;
    }
    
    // Get all highlights for this word
    const highlights = this.wordToHighlights.get(normalizedWord);
    
    if (highlights) {
      // Remove all highlight elements for this word
      highlights.forEach(highlight => {
        this.removeHighlight(highlight);
      });
      
      // Clean up the mapping
      this.wordToHighlights.delete(normalizedWord); // O(1) operation
    }
    
    // Remove from selected words set
    this.selectedWords.delete(normalizedWord); // O(1) operation
    
    console.log('[WordSelector] Word removed:', word);
    console.log('[WordSelector] Remaining selected words:', this.selectedWords.size);
    console.log('[WordSelector] Selected words now:', Array.from(this.selectedWords));
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Get all CSS properties from a range's start container to preserve them
   * @param {Range} range - The range to get styles from
   * @returns {Object} Object containing all relevant CSS properties
   */
  getRangeCSSProperties(range) {
    const startContainer = range.startContainer;
    let element = startContainer;
    
    // If startContainer is a text node, get its parent element
    if (startContainer.nodeType === Node.TEXT_NODE) {
      element = startContainer.parentElement;
    } else if (startContainer.nodeType === Node.ELEMENT_NODE) {
      element = startContainer;
    }
    
    if (!element) {
      console.warn('[WordSelector] Could not find element for CSS properties');
      return {};
    }
    
    // Get computed styles
    const computedStyles = window.getComputedStyle(element);
    
    // Extract all font and text-related properties
    const cssProperties = {
      // Font properties
      fontSize: computedStyles.fontSize,
      fontFamily: computedStyles.fontFamily,
      fontStyle: computedStyles.fontStyle,
      fontWeight: computedStyles.fontWeight,
      fontVariant: computedStyles.fontVariant,
      fontStretch: computedStyles.fontStretch,
      lineHeight: computedStyles.lineHeight,
      letterSpacing: computedStyles.letterSpacing,
      wordSpacing: computedStyles.wordSpacing,
      
      // Text properties
      color: computedStyles.color,
      textDecoration: computedStyles.textDecoration,
      textDecorationLine: computedStyles.textDecorationLine,
      textDecorationColor: computedStyles.textDecorationColor,
      textDecorationStyle: computedStyles.textDecorationStyle,
      textTransform: computedStyles.textTransform,
      textShadow: computedStyles.textShadow,
      
      // Other important properties
      verticalAlign: computedStyles.verticalAlign,
      textAlign: computedStyles.textAlign,
      direction: computedStyles.direction,
      unicodeBidi: computedStyles.unicodeBidi,
      
      // Theme-related properties (if any)
      backgroundColor: computedStyles.backgroundColor,
    };
    
    console.log('[WordSelector] Captured CSS properties:', cssProperties);
    return cssProperties;
  },
  
  /**
   * Apply CSS properties to preserve them in the highlight
   * @param {HTMLElement} element - The element to apply styles to
   * @param {Object} cssProperties - The CSS properties to apply
   */
  applyCSSProperties(element, cssProperties) {
    // List of critical properties that must be preserved to prevent font size/style changes
    const criticalProperties = [
      'fontSize', 'fontFamily', 'fontStyle', 'fontWeight', 'fontVariant',
      'fontStretch', 'lineHeight', 'letterSpacing', 'wordSpacing',
      'color', 'textDecoration', 'textDecorationLine', 'textDecorationColor',
      'textDecorationStyle', 'textTransform', 'textShadow',
      'verticalAlign', 'direction'
    ];
    
    // Apply critical properties with !important to ensure they override any conflicting styles
    criticalProperties.forEach(property => {
      const value = cssProperties[property];
      if (value && value.trim() !== '' && value !== 'auto') {
        // Convert camelCase to kebab-case for CSS properties
        const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
        // Apply with !important to override website CSS that might affect child elements
        element.style.setProperty(cssProperty, value, 'important');
      }
    });
  },
  
  /**
   * Preserve CSS properties for all text nodes within an element
   * @param {HTMLElement} container - The container element
   * @param {Object} cssProperties - The CSS properties to preserve
   */
  preserveTextNodeStyles(container, cssProperties) {
    // Only process direct children to avoid interfering with nested formatting elements
    const children = Array.from(container.childNodes);
    
    children.forEach(child => {
      if (child.nodeType === Node.TEXT_NODE) {
        // For direct text nodes, wrap them in a span to preserve styles
        // This ensures the text maintains its original font size, style, and color
        const span = document.createElement('span');
        span.style.setProperty('display', 'inline', 'important');
        // Apply all captured CSS properties to preserve the original appearance
        this.applyCSSProperties(span, cssProperties);
        container.insertBefore(span, child);
        span.appendChild(child);
      } else if (child.nodeType === Node.ELEMENT_NODE) {
        // For element nodes that are not the remove button
        // Only apply font-size preservation to prevent size changes from website CSS
        // Don't override other properties that the element might have (like font-weight for <b>)
        if (!child.classList.contains('vocab-word-remove-btn') && 
            !child.classList.contains('vocab-word-remove-explained-btn')) {
          // Only preserve fontSize to prevent size changes, other properties are preserved by the element itself
          if (cssProperties.fontSize) {
            child.style.setProperty('font-size', cssProperties.fontSize, 'important');
          }
          // Also preserve color if it's a text-level element
          if (cssProperties.color && 
              ['SPAN', 'B', 'STRONG', 'EM', 'I', 'U', 'CODE', 'MARK'].includes(child.tagName)) {
            child.style.setProperty('color', cssProperties.color, 'important');
          }
        }
      }
    });
  },
  
  /**
   * Highlight a range with a styled span
   * @param {Range} range - The range to highlight
   * @param {string} word - The word being highlighted
   */
  highlightRange(range, word) {
    const normalizedWord = word.toLowerCase();
    
    console.log('[WordSelector] ===== CREATING HIGHLIGHT =====');
    console.log('[WordSelector] Original word:', word);
    console.log('[WordSelector] Normalized word for data-word:', normalizedWord);
    
    // CRITICAL: Capture CSS properties BEFORE wrapping to preserve them
    const cssProperties = this.getRangeCSSProperties(range);
    console.log('[WordSelector] Captured CSS properties before wrapping:', cssProperties);
    
    // Create highlight wrapper
    // DO NOT apply font properties to the highlight span - let child elements preserve their formatting
    // The highlight span should only provide the background color, not override text formatting
    const highlight = document.createElement('span');
    highlight.className = 'vocab-word-highlight';
    highlight.setAttribute('data-word', normalizedWord);
    highlight.setAttribute('data-highlight-id', `highlight-${this.highlightIdCounter++}`);
    
    // Ensure the highlight span doesn't interfere with child formatting
    // Set display to inline to preserve text flow
    highlight.style.setProperty('display', 'inline', 'important');
    highlight.style.setProperty('position', 'relative', 'important');
    // DO NOT set font properties - let children inherit or use their own styles
    
    console.log('[WordSelector] Highlight element created with data-word:', normalizedWord);
    console.log('[WordSelector] Preserving all formatting from selected range - no font overrides applied');
    
    // Wrap the selected range FIRST
    // This preserves all formatting (bold, italic, font sizes, etc.) from the original content
    
    // Try surroundContents first - this works when the range doesn't cross element boundaries
    // If it fails or might break formatting, use extractContents which preserves DOM structure
    try {
      // Check if range might contain formatting elements by checking the HTML
      const rangeClone = range.cloneContents();
      const hasFormattingElements = rangeClone.querySelector('b, strong, em, i, u, span, font, h1, h2, h3, h4, h5, h6');
      
      if (hasFormattingElements) {
        // Range contains formatting elements - use extractContents to preserve structure
        console.log('[WordSelector] Range contains formatting elements - using extractContents to preserve formatting');
        const extractedContents = range.extractContents();
        highlight.appendChild(extractedContents);
        range.insertNode(highlight);
        console.log('[WordSelector] Used extractContents - formatting preserved');
      } else {
        // No formatting elements - try surroundContents
        range.surroundContents(highlight);
        console.log('[WordSelector] Used surroundContents - formatting preserved');
      }
    } catch (error) {
      // surroundContents failed - use extractContents which preserves DOM structure
      console.warn('[WordSelector] surroundContents failed, using extractContents:', error);
      const extractedContents = range.extractContents();
      highlight.appendChild(extractedContents);
      range.insertNode(highlight);
      console.log('[WordSelector] Used extractContents (fallback) - formatting preserved');
    }
    
    // CRITICAL: After wrapping, preserve CSS properties to prevent font size/style changes
    // Apply properties to all text nodes and child elements within the highlight
    this.preserveTextNodeStyles(highlight, cssProperties);
    console.log('[WordSelector] Applied CSS properties to preserve font size, style, and color');
    
    // Create and append remove button AFTER wrapping the content
    const removeBtn = this.createRemoveButton(word);
    highlight.appendChild(removeBtn);
    
    // Store the highlight in our map (O(1) operation)
    if (!this.wordToHighlights.has(normalizedWord)) {
      this.wordToHighlights.set(normalizedWord, new Set());
    }
    this.wordToHighlights.get(normalizedWord).add(highlight);
    
    console.log('[WordSelector] ✓ Highlight stored for normalized word:', normalizedWord);
    console.log('[WordSelector] ✓ Total highlights for this word:', this.wordToHighlights.get(normalizedWord).size);
  },
  
  /**
   * Create word span without background color (for magic button state)
   * @param {Range} range - The range to wrap
   * @param {string} word - The original word
   * @param {string} normalizedWord - The normalized word (lowercase)
   * @returns {HTMLElement} The created span element
   */
  createWordSpanWithoutBackground(range, word, normalizedWord) {
    console.log('[WordSelector] ===== CREATING WORD SPAN WITHOUT BACKGROUND =====');
    console.log('[WordSelector] Original word:', word);
    console.log('[WordSelector] Normalized word:', normalizedWord);
    
    // Capture CSS properties BEFORE wrapping to preserve them
    const cssProperties = this.getRangeCSSProperties(range);
    console.log('[WordSelector] Captured CSS properties before wrapping:', cssProperties);
    
    // Create span wrapper without background color class
    const span = document.createElement('span');
    span.className = 'vocab-word-span-pending'; // Neutral class, no background
    span.setAttribute('data-word', normalizedWord);
    span.setAttribute('data-highlight-id', `word-span-${this.highlightIdCounter++}`);
    
    // Ensure the span doesn't interfere with child formatting
    // Match the exact style approach from highlightRange
    span.style.setProperty('display', 'inline', 'important');
    span.style.setProperty('position', 'relative', 'important');
    // Ensure no overflow clipping that would hide the button
    span.style.setProperty('overflow', 'visible', 'important');
    // Ensure no margins or padding that could cause layout shifts
    span.style.setProperty('margin', '0', 'important');
    span.style.setProperty('padding', '0', 'important');
    span.style.setProperty('vertical-align', 'baseline', 'important');
    
    console.log('[WordSelector] Word span element created with data-word:', normalizedWord);
    
    // Wrap the selected range
    try {
      const rangeClone = range.cloneContents();
      const hasFormattingElements = rangeClone.querySelector('b, strong, em, i, u, span, font, h1, h2, h3, h4, h5, h6');
      
      if (hasFormattingElements) {
        console.log('[WordSelector] Range contains formatting elements - using extractContents');
        const extractedContents = range.extractContents();
        span.appendChild(extractedContents);
        range.insertNode(span);
        console.log('[WordSelector] Used extractContents - formatting preserved');
      } else {
        range.surroundContents(span);
        console.log('[WordSelector] Used surroundContents - formatting preserved');
      }
    } catch (error) {
      console.warn('[WordSelector] surroundContents failed, using extractContents:', error);
      const extractedContents = range.extractContents();
      span.appendChild(extractedContents);
      range.insertNode(span);
      console.log('[WordSelector] Used extractContents (fallback) - formatting preserved');
    }
    
    // Preserve CSS properties
    this.preserveTextNodeStyles(span, cssProperties);
    console.log('[WordSelector] Applied CSS properties to preserve font size, style, and color');
    
    // Store the span in our map (but don't add to wordToHighlights yet - only after API call succeeds)
    // We'll track it in pendingWords instead
    
    return span;
  },
  
  /**
   * Create a remove button for the highlight
   * @param {string} word - The word this button will remove
   * @returns {HTMLElement}
   */
  createRemoveButton(word) {
    const btn = document.createElement('button');
    btn.className = 'vocab-word-remove-btn';
    btn.setAttribute('aria-label', `Remove highlight for "${word}"`);
    btn.innerHTML = this.createCloseIcon();
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.removeWord(word);
    });
    
    return btn;
  },
  
  /**
   * Create close/cross icon SVG - Purple cross icon
   * @returns {string} SVG markup
   */
  createCloseIcon() {
    return `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 2L10 10M10 2L2 10" stroke="#9527F5" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Show magic meaning button above word span
   * @param {HTMLElement} span - The word span element
   * @param {string} word - The original word
   * @param {string} normalizedWord - The normalized word
   */
  showWordMagicMeaningButton(span, word, normalizedWord) {
    // Remove any existing button first
    this.hideWordMagicMeaningButton(normalizedWord);
    
    // Create button container (similar to spinner container position)
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'vocab-word-magic-button-container';
    buttonContainer.setAttribute('data-word', normalizedWord);
    
    // Create and add magic meaning button
    const magicBtn = this.createWordMagicMeaningButton(word, normalizedWord);
    // Remove breathing class temporarily and add appearing animation
    magicBtn.classList.remove('magic-meaning-breathing');
    magicBtn.classList.add('magic-meaning-appearing');
    buttonContainer.appendChild(magicBtn);
    
    // Append to span
    span.appendChild(buttonContainer);
    // Remove appearing class after animation completes and restore breathing animation
    setTimeout(() => {
      magicBtn.classList.remove('magic-meaning-appearing');
      magicBtn.classList.add('magic-meaning-breathing');
    }, 200);
    
    // Store button wrapper
    this.wordButtonWrappers.set(normalizedWord, buttonContainer);
    
    console.log('[WordSelector] Magic meaning button shown for word:', normalizedWord);
    console.log('[WordSelector] Button container:', buttonContainer);
    console.log('[WordSelector] Span element:', span);
    
    // Ensure button is visible after DOM update
    // Use requestAnimationFrame to ensure layout is complete
    requestAnimationFrame(() => {
      if (buttonContainer && buttonContainer.parentNode) {
        // Force a reflow to ensure button is positioned correctly
        void buttonContainer.offsetHeight;
        console.log('[WordSelector] Button container position verified');
      }
    });
    
    // Add global click handler to remove button and span on outside click
    // Use setTimeout to avoid immediate removal when button is created
    setTimeout(() => {
      const handleGlobalClick = (event) => {
        // Check if button container still exists
        if (!buttonContainer || !buttonContainer.parentNode) {
          document.removeEventListener('click', handleGlobalClick);
          return;
        }
        
        // Check if click is on the magic button or its container
        if (event.target && (
          event.target.closest('.vocab-word-magic-button-container') ||
          event.target.closest('.vocab-word-magic-meaning-btn')
        )) {
          // Click is on the button - don't remove it
          return;
        }
        
        // Check if button is in loading state (spinner showing)
        const btn = buttonContainer.querySelector('.vocab-word-magic-meaning-btn');
        if (btn && btn.classList.contains('magic-meaning-loading')) {
          // Button is in loading state - don't remove it
          return;
        }
        
        // Click is outside - remove button and span
        console.log('[WordSelector] Outside click detected, removing magic button and span');
        this.removeWordMagicButtonAndSpan(normalizedWord);
        document.removeEventListener('click', handleGlobalClick);
      };
      
      // Add click handler with small delay to let button click handler execute first
      setTimeout(() => {
        document.addEventListener('click', handleGlobalClick);
      }, 10);
    }, 10);
  },
  
  /**
   * Hide magic meaning button
   * @param {string} normalizedWord - The normalized word
   */
  hideWordMagicMeaningButton(normalizedWord) {
    const buttonContainer = this.wordButtonWrappers.get(normalizedWord);
    if (buttonContainer && buttonContainer.parentNode) {
      const magicBtn = buttonContainer.querySelector('.vocab-word-magic-meaning-btn');
      if (magicBtn) {
        // Add disappearing animation
        magicBtn.classList.remove('magic-meaning-breathing');
        magicBtn.classList.add('magic-meaning-disappearing');
        // Force a reflow to ensure animation starts
        void magicBtn.offsetHeight;
        // Remove after animation completes - don't delete from map until after removal
        setTimeout(() => {
          if (buttonContainer && buttonContainer.parentNode) {
            buttonContainer.remove();
          }
          // Delete from map after removal
          this.wordButtonWrappers.delete(normalizedWord);
        }, 200);
        // Return early to prevent immediate deletion from map
        return;
      } else {
        // If button not found, remove immediately
        buttonContainer.remove();
      }
    }
    // Only delete from map if we didn't schedule a delayed removal
    this.wordButtonWrappers.delete(normalizedWord);
  },
  
  /**
   * Remove magic button and span (cleanup on outside click)
   * @param {string} normalizedWord - The normalized word
   */
  removeWordMagicButtonAndSpan(normalizedWord) {
    // Remove button
    this.hideWordMagicMeaningButton(normalizedWord);
    
    // Remove span
    const pendingData = this.pendingWords.get(normalizedWord);
    if (pendingData && pendingData.highlight) {
      const span = pendingData.highlight;
      if (span.parentNode) {
        // Replace span with its text content
        const parent = span.parentNode;
        const textNode = document.createTextNode(span.textContent);
        parent.replaceChild(textNode, span);
        parent.normalize();
      }
    }
    
    // Clean up pending data
    this.pendingWords.delete(normalizedWord);
    this.selectedWords.delete(normalizedWord);
    
    console.log('[WordSelector] Removed magic button and span for word:', normalizedWord);
  },
  
  /**
   * Create magic meaning button for word
   * @param {string} word - The original word
   * @param {string} normalizedWord - The normalized word
   * @returns {HTMLElement}
   */
  createWordMagicMeaningButton(word, normalizedWord) {
    const btn = document.createElement('button');
    btn.className = 'vocab-word-magic-meaning-btn magic-meaning-breathing';
    btn.setAttribute('aria-label', 'Get magic meaning');
    btn.setAttribute('data-word', normalizedWord);
    
    // Use inline purple logo SVG (always available, no fetch needed)
    const iconHtml = this.createWordMagicMeaningIcon();
    btn.innerHTML = iconHtml;
    console.log('[WordSelector] Magic button icon set, length:', iconHtml.length);
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      console.log('[WordSelector] Magic-meaning button clicked for:', normalizedWord);
      
      // Get pending data
      const pendingData = this.pendingWords.get(normalizedWord);
      if (!pendingData) {
        console.warn('[WordSelector] No pending data found for word:', normalizedWord);
        return;
      }
      
      const span = pendingData.highlight;
      
      // Change button to spinner state
      btn.classList.add('magic-meaning-loading');
      btn.classList.remove('magic-meaning-breathing');
      btn.innerHTML = this.createWordSpinnerIcon();
      btn.disabled = true;
      
      // Convert span to proper highlight with purple background and pulsating animation
      span.classList.remove('vocab-word-span-pending');
      span.classList.add('vocab-word-highlight', 'vocab-word-loading');
      
      // Remove magic button container (spinner will replace it)
      const buttonContainer = this.wordButtonWrappers.get(normalizedWord);
      if (buttonContainer && buttonContainer.parentNode) {
        buttonContainer.remove();
      }
      this.wordButtonWrappers.delete(normalizedWord);
      
      // Store in wordToHighlights map
      if (!this.wordToHighlights.has(normalizedWord)) {
        this.wordToHighlights.set(normalizedWord, new Set());
      }
      this.wordToHighlights.get(normalizedWord).add(span);
      
      // Clean up pending data (no longer needed)
      this.pendingWords.delete(normalizedWord);
      
      // Show loading spinner above the word
      this.showLoadingSpinner(span);
      
      // Make API call
      this.processWordExplanation(word, normalizedWord, span);
    });
    
    return btn;
  },
  
  /**
   * Create magic meaning icon SVG (same as TextSelector)
   * @returns {string} SVG markup
   */
  createWordMagicMeaningIcon() {
    // Use cached SVG content (same as home-options-btn but purple)
    if (this.purpleLogoSvgContent) {
      // Create a temporary container to parse and modify the SVG
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = this.purpleLogoSvgContent;
      const svgElement = tempDiv.querySelector('svg');
      if (svgElement) {
        // Set size attributes
        svgElement.setAttribute('width', '20');
        svgElement.setAttribute('height', '20');
        svgElement.setAttribute('viewBox', '0 0 293 277'); // Preserve original viewBox
        svgElement.style.display = 'block';
        svgElement.style.pointerEvents = 'none';
        svgElement.style.visibility = 'visible';
        svgElement.style.opacity = '1';
        // Return the modified SVG HTML
        return svgElement.outerHTML;
      }
    }
    // If SVG not loaded yet, return empty placeholder
    // The button will be updated when SVG loads via updateAllMagicMeaningButtons()
    return '<div style="width: 20px; height: 20px; background: transparent;"></div>';
  },
  
  /**
   * Update all existing magic meaning buttons with loaded SVG
   */
  updateAllMagicMeaningButtons() {
    if (!this.purpleLogoSvgContent) return;
    
    // Find all word magic meaning buttons
    const buttons = document.querySelectorAll('.vocab-word-magic-meaning-btn');
    buttons.forEach(btn => {
      if (!btn.classList.contains('magic-meaning-loading')) {
        btn.innerHTML = this.createWordMagicMeaningIcon();
      }
    });
  },
  
  /**
   * Create spinner icon SVG for loading state (same as TextSelector)
   * @returns {string} SVG markup
   */
  createWordSpinnerIcon() {
    return `
      <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="9" cy="9" r="7" stroke="#9527F5" stroke-width="0.8" stroke-linecap="round" stroke-dasharray="14 30" opacity="0.15"/>
        <circle cx="9" cy="9" r="7" stroke="#9527F5" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="14 30" stroke-dashoffset="6" opacity="1">
          <animateTransform attributeName="transform" type="rotate" from="0 9 9" to="360 9 9" dur="1s" repeatCount="indefinite"/>
        </circle>
      </svg>
    `;
  },
  
  /**
   * Remove a highlight element and restore original text
   * @param {HTMLElement} highlight - The highlight element to remove
   */
  removeHighlight(highlight) {
    const parent = highlight.parentNode;
    if (!parent) return;
    
    // Remove the button first
    const btn = highlight.querySelector('.vocab-word-remove-btn');
    if (btn) {
      btn.remove();
    }
    
    // Move all child nodes back to parent
    while (highlight.firstChild) {
      parent.insertBefore(highlight.firstChild, highlight);
    }
    
    // Remove the empty highlight span
    highlight.remove();
    
    // Normalize the parent to merge adjacent text nodes
    parent.normalize();
  },
  
  /**
   * Get all selected words
   * @returns {Set<string>}
   */
  getSelectedWords() {
    return new Set(this.selectedWords); // Return a copy
  },
  
  /**
   * Clear all selections
   */
  clearAll() {
    // Remove all highlights
    this.wordToHighlights.forEach((highlights) => {
      highlights.forEach(highlight => {
        this.removeHighlight(highlight);
      });
    });
    
    // Clear data structures (O(1) for Set clear)
    this.selectedWords.clear();
    this.wordToHighlights.clear();
    this.wordPositions.clear();
    this.explainedWords.clear();
    
    console.log('[WordSelector] All selections cleared');
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },

  /**
   * Clear only selections (purple highlights) but preserve meanings (green highlights)
   */
  clearSelectionsOnly() {
    console.log('[WordSelector] Clearing only selections, preserving meanings');
    
    // Only clear selected words (purple highlights)
    this.selectedWords.forEach(word => {
      const highlights = this.wordToHighlights.get(word);
      if (highlights) {
        highlights.forEach(highlight => {
          // Only remove if it's a selection highlight (purple), not explained (green)
          if (highlight.classList.contains('vocab-word-selected') && 
              !highlight.classList.contains('vocab-word-explained')) {
            this.removeHighlight(highlight);
          }
        });
      }
    });
    
    // Clear only selection data structures
    this.selectedWords.clear();
    this.wordPositions.clear();
    
    // Keep explainedWords and wordToHighlights intact
    
    console.log('[WordSelector] Selections cleared, meanings preserved');
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Get full document text for position calculation
   * @returns {string} Full document text
   */
  getDocumentText() {
    return document.body.innerText || '';
  },
  
  /**
   * Find all positions of a word in the document
   * @param {string} word - The word to find
   * @returns {Array<number>} Array of character indices where word appears
   */
  findWordPositionsInDocument(word) {
    const docText = this.getDocumentText();
    const positions = [];
    const wordLower = word.toLowerCase();
    const docTextLower = docText.toLowerCase();
    
    // Find all occurrences
    let index = 0;
    while ((index = docTextLower.indexOf(wordLower, index)) !== -1) {
      // Check if it's a whole word (not part of another word)
      const before = index > 0 ? docText[index - 1] : ' ';
      const after = index + wordLower.length < docText.length ? docText[index + wordLower.length] : ' ';
      
      // Check if surrounded by non-word characters
      if (!/\w/.test(before) && !/\w/.test(after)) {
        positions.push(index);
      }
      index += wordLower.length;
    }
    
    return positions;
  },
  
  /**
   * Extract context around a word (15 words before and after)
   * @param {string} docText - Full document text
   * @param {number} wordIndex - Starting index of the word in document
   * @param {number} wordLength - Length of the word
   * @returns {Object} {text, textStartIndex, wordIndexInText}
   */
  extractWordContext(docText, wordIndex, wordLength) {
    console.log(`[WordSelector] extractWordContext: wordIndex=${wordIndex}, wordLength=${wordLength}`);
    
    // Split document into words (including whitespace for position tracking)
    const beforeText = docText.substring(0, wordIndex);
    const afterText = docText.substring(wordIndex + wordLength);
    
    // Get words before (up to 15)
    const wordsBeforeMatch = beforeText.match(/\S+/g) || [];
    const wordsBefore = wordsBeforeMatch.slice(-15);
    
    // Get words after (up to 15)
    const wordsAfterMatch = afterText.match(/\S+/g) || [];
    const wordsAfter = wordsAfterMatch.slice(0, 15);
    
    // Calculate the actual start index in document
    let textStartIndex = wordIndex;
    if (wordsBefore.length > 0) {
      // Find where the first of our 15 words before starts in the document
      // We need to find the actual position of the first word in our context
      const firstWord = wordsBefore[0];
      const lastOccurrence = beforeText.lastIndexOf(firstWord);
      
      if (lastOccurrence !== -1) {
        textStartIndex = lastOccurrence;
      } else {
        // Fallback: use wordIndex as start
        textStartIndex = wordIndex;
      }
    }
    
    // Build the context text
    const contextParts = [];
    if (wordsBefore.length > 0) {
      contextParts.push(wordsBefore.join(' '));
    }
    contextParts.push(docText.substring(wordIndex, wordIndex + wordLength));
    if (wordsAfter.length > 0) {
      contextParts.push(wordsAfter.join(' '));
    }
    
    const text = contextParts.join(' ');
    const wordIndexInText = wordsBefore.length > 0 ? wordsBefore.join(' ').length + 1 : 0;
    
    console.log(`[WordSelector] Context result: textStartIndex=${textStartIndex}, wordIndexInText=${wordIndexInText}`);
    console.log(`[WordSelector] Context text: "${text.substring(0, 100)}..."`);
    
    return {
      text,
      textStartIndex,
      wordIndexInText
    };
  },
  
  /**
   * Build API payload for word explanation
   * Algorithm: For each word, extract 10 words before and after. Merge overlapping contexts.
   * @returns {Array<Object>} Array of payload segments
   */
  buildWordsExplanationPayload() {
    console.log('[WordSelector] ===== Building Words Explanation Payload =====');
    const docText = this.getDocumentText();
    const selectedWordsArray = Array.from(this.selectedWords);
    
    console.log('[WordSelector] Selected words:', selectedWordsArray);
    console.log('[WordSelector] Document text length:', docText.length);
    
    // Build position data for each word
    const wordDataList = [];
    
    for (const word of selectedWordsArray) {
      console.log(`[WordSelector] Processing word: "${word}"`);
      const highlights = this.wordToHighlights.get(word);
      
      if (!highlights || highlights.size === 0) {
        console.warn(`[WordSelector] No highlights found for word: "${word}"`);
        continue;
      }
      
      console.log(`[WordSelector] Found ${highlights.size} highlight(s) for word: "${word}"`);
      
      // Find all positions of this word in document
      const positions = this.findWordPositionsInDocument(word);
      console.log(`[WordSelector] Found ${positions.length} position(s) in document for word: "${word}"`, positions);
      
      // For each highlight, find its position
      let highlightIndex = 0;
      highlights.forEach(highlight => {
        highlightIndex++;
        const highlightText = highlight.textContent.replace(/\s+/g, ' ').trim();
        console.log(`[WordSelector] Processing highlight #${highlightIndex} for "${word}": text="${highlightText}"`);
        
        // Try to match this highlight to a position
        // We'll use the first available position for simplicity
        if (positions.length > 0) {
          const position = positions.shift(); // Take first position
          const context = this.extractWordContext(docText, position, word.length);
          
          console.log(`[WordSelector] Assigned position ${position} to highlight #${highlightIndex}`);
          console.log(`[WordSelector] Context: textStartIndex=${context.textStartIndex}, text="${context.text.substring(0, 50)}..."`);
          
          wordDataList.push({
            word: word,
            textStartIndex: context.textStartIndex,
            text: context.text,
            wordIndexInContext: context.wordIndexInText,
            wordLength: word.length,
            highlight: highlight
          });
        } else {
          console.warn(`[WordSelector] No more positions available for highlight #${highlightIndex} of word "${word}"`);
        }
      });
    }
    
    console.log('[WordSelector] Total word data entries created:', wordDataList.length);
    
    // Sort by textStartIndex (document order)
    wordDataList.sort((a, b) => a.textStartIndex - b.textStartIndex);
    console.log('[WordSelector] Sorted word data by position');
    
    // Merge overlapping contexts
    const mergedSegments = [];
    let currentSegment = null;
    
    for (const wordData of wordDataList) {
      if (!currentSegment) {
        // Start new segment
        console.log(`[WordSelector] Starting new segment with word "${wordData.word}" at position ${wordData.textStartIndex}`);
        currentSegment = {
          textStartIndex: wordData.textStartIndex,
          text: wordData.text,
          important_words_location: [{
            word: wordData.word,
            index: wordData.wordIndexInContext,
            length: wordData.wordLength
          }],
          wordHighlights: [wordData.highlight]
        };
      } else {
        const currentEnd = currentSegment.textStartIndex + currentSegment.text.length;
        const newStart = wordData.textStartIndex;
        const newEnd = newStart + wordData.text.length;
        
        // Check if overlapping or adjacent
        if (newStart <= currentEnd + 20) { // Allow 20 char gap for merging
          console.log(`[WordSelector] Merging word "${wordData.word}" into current segment (overlap detected)`);
          // Merge: extend current segment
          const mergedStart = Math.min(currentSegment.textStartIndex, newStart);
          const mergedEnd = Math.max(currentEnd, newEnd);
          
          // Recalculate text from document
          currentSegment.text = docText.substring(mergedStart, mergedEnd);
          currentSegment.textStartIndex = mergedStart;
          
          // Add word location (recalculate index in merged text)
          const wordIndexInMerged = wordData.textStartIndex + wordData.wordIndexInContext - mergedStart;
          currentSegment.important_words_location.push({
            word: wordData.word,
            index: wordIndexInMerged,
            length: wordData.wordLength
          });
          currentSegment.wordHighlights.push(wordData.highlight);
        } else {
          // No overlap, save current and start new
          console.log(`[WordSelector] No overlap - saving current segment and starting new one for word "${wordData.word}"`);
          mergedSegments.push(currentSegment);
          currentSegment = {
            textStartIndex: wordData.textStartIndex,
            text: wordData.text,
            important_words_location: [{
              word: wordData.word,
              index: wordData.wordIndexInContext,
              length: wordData.wordLength
            }],
            wordHighlights: [wordData.highlight]
          };
        }
      }
    }
    
    // Add last segment
    if (currentSegment) {
      console.log('[WordSelector] Adding final segment');
      mergedSegments.push(currentSegment);
    }
    
    console.log(`[WordSelector] Created ${mergedSegments.length} merged segment(s)`);
    mergedSegments.forEach((segment, idx) => {
      console.log(`[WordSelector] Segment ${idx + 1}: textStartIndex=${segment.textStartIndex}, words=${segment.important_words_location.length}, highlights=${segment.wordHighlights.length}`);
      console.log(`[WordSelector] Segment ${idx + 1} words:`, segment.important_words_location.map(w => w.word));
    });
    
    // Return payload (remove wordHighlights from API payload, keep for internal use)
    const payload = mergedSegments.map(segment => ({
      textStartIndex: segment.textStartIndex,
      text: segment.text,
      important_words_location: segment.important_words_location,
      _wordHighlights: segment.wordHighlights // Keep for internal tracking
    }));
    
    console.log('[WordSelector] ===== Payload Build Complete =====');
    return payload;
  },
  
  /**
   * Create popup for word meaning
   * @param {string} word - The word
   * @param {string} meaning - The meaning
   * @param {Array<string>} examples - Example sentences
   * @param {boolean} shouldAllowFetchMoreExamples - Whether to show the "View more examples" button
   * @param {string|null} languageCode - Language code from API response (e.g., "ENGLISH"). If "ENGLISH", shows speaker icon for pronunciation
   * @returns {Promise<HTMLElement>} Popup element
   */
  async createWordPopup(word, meaning, examples, shouldAllowFetchMoreExamples = true, languageCode = null) {
    const popup = document.createElement('div');
    popup.className = 'vocab-word-popup';
    popup.setAttribute('data-word', word.toLowerCase());
    
    // Add inline styles to ensure popup is visible and not overridden by website CSS
    popup.style.setProperty('position', 'absolute', 'important');
    popup.style.setProperty('z-index', '10000010', 'important');
    popup.style.setProperty('display', 'block', 'important');
    popup.style.setProperty('visibility', 'visible', 'important');
    popup.style.setProperty('opacity', '0', 'important'); // Will be set to 1 when visible class is added
    popup.style.setProperty('pointer-events', 'none', 'important'); // Will be set to 'all' when visible
    
    // Meaning
    const meaningDiv = document.createElement('div');
    meaningDiv.className = 'vocab-word-popup-meaning';
    meaningDiv.innerHTML = `<span class="word-bold"></span>${meaning}`;
    popup.appendChild(meaningDiv);
    
    // Examples container (has separator line on top)
    const examplesContainer = document.createElement('div');
    examplesContainer.className = 'vocab-word-popup-examples-container';
    
    // Examples heading - light purple, horizontally centered, below separator
    if (examples && examples.length > 0) {
      const examplesHeading = document.createElement('div');
      examplesHeading.className = 'vocab-word-popup-examples-heading';
      examplesHeading.textContent = 'Examples';
      examplesHeading.style.setProperty('color', 'rgba(147, 51, 234, 0.7)', 'important'); // Light purple
      examplesHeading.style.setProperty('text-align', 'center', 'important');
      examplesHeading.style.setProperty('font-size', '18px', 'important'); // Increased font size
      examplesHeading.style.setProperty('font-weight', '600', 'important'); // Thicker/bolder
      examplesHeading.style.setProperty('margin-bottom', '10px', 'important');
      examplesHeading.style.setProperty('margin-top', '8px', 'important'); // Space below separator
      examplesContainer.appendChild(examplesHeading);
    }
    
    if (examples && examples.length > 0) {
      const examplesList = document.createElement('ul');
      examplesList.className = 'vocab-word-popup-examples';
      examplesList.id = `vocab-word-examples-${word.toLowerCase()}`;
      
      examples.forEach(example => {
        const li = document.createElement('li');
        // Bold the word in examples
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const highlightedExample = example.replace(regex, `<span class="word-bold">${word}</span>`);
        li.innerHTML = highlightedExample;
        examplesList.appendChild(li);
      });
      
      examplesContainer.appendChild(examplesList);
    }
    
    popup.appendChild(examplesContainer);
    
    // Store original meaning and examples for translation
    popup.setAttribute('data-original-meaning', meaning);
    popup.setAttribute('data-original-examples', JSON.stringify(examples));
    popup.setAttribute('data-language-code', languageCode || '');
    popup.setAttribute('data-current-tab', languageCode || 'EN'); // Track current active tab
    
    // Create bottom container for speaker icon, tab group, and button
    const bottomContainer = document.createElement('div');
    bottomContainer.className = 'vocab-word-popup-bottom-container';
    
    // Speaker icon for pronunciation - HIDDEN for now
    // Add it to bottom container at the leftmost position
    // if (languageCode === 'ENGLISH') {
    //   const speakerBtn = document.createElement('button');
    //   speakerBtn.className = 'vocab-word-popup-speaker';
    //   speakerBtn.setAttribute('aria-label', `Pronounce "${word}"`);
    //   speakerBtn.innerHTML = this.createSpeakerIcon();
    //   speakerBtn.addEventListener('click', async (e) => {
    //     e.stopPropagation();
    //     await this.handlePronunciation(word, speakerBtn);
    //   });
    //   bottomContainer.appendChild(speakerBtn);
    //   // Add class to popup to indicate speaker icon exists
    //   popup.classList.add('has-speaker-icon');
    // }
    
    // Bookmark icon - check if word is already bookmarked
    const bookmarkBtn = document.createElement('button');
    bookmarkBtn.className = 'vocab-word-popup-bookmark';
    bookmarkBtn.setAttribute('aria-label', 'Bookmark word');
    bookmarkBtn.setAttribute('title', 'Save to bookmarks');
    bookmarkBtn.setAttribute('data-word', word.toLowerCase());
    
    // Check if word is bookmarked and set initial state
    const isBookmarked = await BookmarkWordsService.isBookmarked(word);
    if (isBookmarked) {
      bookmarkBtn.classList.add('bookmarked');
      bookmarkBtn.innerHTML = this.createBookmarkIcon(true);
    } else {
      bookmarkBtn.innerHTML = this.createBookmarkIcon(false);
    }
    
    bookmarkBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      await this.handleBookmarkClick(word, meaning, bookmarkBtn);
    });
    
    // View more button - first button
    const button = document.createElement('button');
    button.className = 'vocab-word-popup-button';
    button.setAttribute('title', 'Generate more examples');
    button.innerHTML = this.createSparkleIcon();
    button.setAttribute('data-word', word.toLowerCase());
    button.setAttribute('data-meaning', meaning);
    
    // Set initial button visibility based on shouldAllowFetchMoreExamples
    if (!shouldAllowFetchMoreExamples) {
      button.style.display = 'none';
      popup.classList.add('no-more-examples-button');
    } else {
      button.style.display = 'flex';
    }
    
    button.addEventListener('click', async (e) => {
      e.stopPropagation();
      console.log('[WordSelector] View more examples clicked for:', word);
      await this.handleViewMoreExamples(word, meaning, examples, button, popup);
    });
    
    // Ask button - last button
    const askButton = document.createElement('button');
    askButton.className = 'vocab-word-popup-ask-button';
    askButton.setAttribute('aria-label', 'Ask AI');
    askButton.setAttribute('title', 'Ask AI');
    askButton.innerHTML = this.createChatIcon();
    
    // Ask AI button should always be visible, never hide it
    askButton.style.display = 'flex';
    
    askButton.addEventListener('click', async (e) => {
      e.stopPropagation();
      console.log('[WordSelector] Ask AI clicked for:', word);
      
      const normalizedWord = word.toLowerCase();
      
      // Check if modal is already open for this word (toggle behavior)
      const existingModal = document.querySelector('.word-web-search-modal');
      if (existingModal) {
        const modalWord = existingModal.getAttribute('data-word');
        if (modalWord === normalizedWord) {
          // Modal is already open for this word - close it
          console.log('[WordSelector] Modal already open for this word, closing it');
          this.closeAskAIModalWithAnimation(existingModal, askButton);
          return;
        } else {
          // Modal is open for a different word - close it first, then open for this word
          this.closeAskAIModalWithAnimation(existingModal, askButton);
          setTimeout(() => {
            this.openWebSearchModal(word, meaning, examples, popup, askButton);
          }, 400);
          return;
        }
      }
      
      // Modal is not open - open it
      this.openWebSearchModal(word, meaning, examples, popup, askButton);
    });
    
    // Add buttons in order: Get more examples, Bookmark, Ask AI
    bottomContainer.appendChild(button);
    bottomContainer.appendChild(bookmarkBtn);
    bottomContainer.appendChild(askButton);
    
    // Append bottom container to popup
    popup.appendChild(bottomContainer);
    
    return popup;
  },
  
  /**
   * Handle "View more examples" button click
   * @param {string} word - The word
   * @param {string} meaning - The meaning
   * @param {Array<string>} currentExamples - Current examples
   * @param {HTMLElement} button - The button element
   * @param {HTMLElement} popup - The popup element
   */
  async handleViewMoreExamples(word, meaning, currentExamples, button, popup) {
    // Show loading state
    button.disabled = true;
    button.classList.add('loading');
    const originalHTML = button.innerHTML; // Store original HTML to restore later
    
    // Create light purple spinner icon for loading state
    const lightPurpleSpinnerIcon = `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="10" cy="10" r="8" stroke="#D8B4FE" stroke-width="1" stroke-linecap="round" stroke-dasharray="12 28" opacity="0.3"/>
        <circle cx="10" cy="10" r="8" stroke="#D8B4FE" stroke-width="2" stroke-linecap="round" stroke-dasharray="12 28" stroke-dashoffset="6" opacity="1">
          <animateTransform attributeName="transform" type="rotate" from="0 10 10" to="360 10 10" dur="1s" repeatCount="indefinite"/>
        </circle>
      </svg>
    `;
    
    button.innerHTML = lightPurpleSpinnerIcon;
    
    try {
      // Extract all currently displayed examples from the popup
      const examplesList = document.getElementById(`vocab-word-examples-${word.toLowerCase()}`);
      let allCurrentExamples = [];
      
      if (examplesList) {
        // Get all example text from the list items
        const listItems = examplesList.querySelectorAll('li');
        allCurrentExamples = Array.from(listItems).map(li => {
          // Remove the highlighting spans to get clean text
          const text = li.textContent || li.innerText;
          return text.trim();
        });
      }
      
      console.log('[WordSelector] Current examples in popup:', allCurrentExamples);
      console.log('[WordSelector] Original examples passed:', currentExamples);
      
      // Check current active tab to determine which language to use for API call
      const currentTab = popup ? popup.getAttribute('data-current-tab') : 'EN';
      const languageCode = popup ? popup.getAttribute('data-language-code') : '';
      const hasTabs = languageCode && languageCode !== 'EN';
      const isEnTabActive = currentTab === 'EN';
      
      // Use meaning and examples in the current tab's language for API call
      let meaningForApi = meaning;
      let examplesForApi = allCurrentExamples;
      
      if (hasTabs && popup) {
        if (isEnTabActive) {
          // If EN tab is active, get the English meaning and examples from cache
          const normalizedWord = word.toLowerCase();
          if (this.translationCache.has(normalizedWord)) {
            const cached = this.translationCache.get(normalizedWord);
            meaningForApi = cached.meaning;
            examplesForApi = cached.examples || [];
          }
        } else {
          // If local language tab is active, use original meaning and examples
          const originalMeaning = popup.getAttribute('data-original-meaning');
          const originalExamplesJson = popup.getAttribute('data-original-examples');
          if (originalMeaning) {
            meaningForApi = originalMeaning;
          }
          if (originalExamplesJson) {
            try {
              const originalExamples = JSON.parse(originalExamplesJson) || [];
              examplesForApi = originalExamples;
            } catch (e) {
              console.error('[WordSelector] Error parsing original examples for API:', e);
            }
          }
        }
      }
      
      console.log('[WordSelector] Using for API - tab:', currentTab, 'meaning:', meaningForApi, 'examples count:', examplesForApi.length);
      
      // Use meaning and examples in the current tab's language for the API call
      const response = await ApiService.getMoreExplanations(word, meaningForApi, examplesForApi);
      
      if (response.success && response.data) {
        const newExamples = response.data.examples || [];
        const shouldAllowFetchMoreExamples = response.data.shouldAllowFetchMoreExamples || false;
        
        // Get original examples count to identify new examples
        const originalExamplesJson = popup ? popup.getAttribute('data-original-examples') : '[]';
        let originalExamples = [];
        try {
          originalExamples = JSON.parse(originalExamplesJson) || [];
        } catch (e) {
          console.error('[WordSelector] Error parsing original examples:', e);
        }
        
        // Determine which examples are new (added after initial load)
        const originalCount = originalExamples.length;
        const newExamplesOnly = newExamples.slice(originalCount);
        
        // If EN tab is active, new examples will be in English - store them separately
        if (isEnTabActive && newExamplesOnly.length > 0) {
          // Store English-only examples
          const existingEnExamplesJson = popup.getAttribute('data-en-examples-only') || '[]';
          let existingEnExamples = [];
          try {
            existingEnExamples = JSON.parse(existingEnExamplesJson) || [];
          } catch (e) {
            console.error('[WordSelector] Error parsing existing EN-only examples:', e);
          }
          
          // Combine with new English examples
          const allEnExamplesOnly = [...existingEnExamples, ...newExamplesOnly];
          popup.setAttribute('data-en-examples-only', JSON.stringify(allEnExamplesOnly));
          console.log('[WordSelector] Stored English-only examples:', allEnExamplesOnly);
        }
        
        // Update the examples list in the popup
        const examplesList = document.getElementById(`vocab-word-examples-${word.toLowerCase()}`);
        if (examplesList) {
          // Clear existing examples
          examplesList.innerHTML = '';
          
          // Add all examples (old + new)
          newExamples.forEach(example => {
            const li = document.createElement('li');
            const regex = new RegExp(`\\b${word}\\b`, 'gi');
            const highlightedExample = example.replace(regex, `<span class="word-bold">${word}</span>`);
            li.innerHTML = highlightedExample;
            examplesList.appendChild(li);
          });
          
          console.log('[WordSelector] Updated examples for word:', word);
        }
        
        // Update button visibility based on shouldAllowFetchMoreExamples
        // Ask AI button should always be visible, never hide it
        const askButton = popup.querySelector('.vocab-word-popup-ask-button');
        if (shouldAllowFetchMoreExamples) {
          button.style.display = 'flex';
          button.disabled = false;
          button.classList.remove('disabled');
        } else {
          button.style.display = 'none';
        }
        // Always keep Ask AI button visible
        if (askButton) {
          askButton.style.display = 'flex';
        }
        
        // Update stored word data with new examples and shouldAllowFetchMoreExamples value
        const normalizedWord = word.toLowerCase();
        if (this.explainedWords.has(normalizedWord)) {
          const wordData = this.explainedWords.get(normalizedWord);
          
          // IMPORTANT: Always update wordData.examples with all examples (old + new) for persistence
          // This ensures that when the popup is reopened, all examples (including newly fetched ones) are shown
          wordData.examples = newExamples; // Update with all examples from API response
          
          // Also update the data-original-examples attribute if popup exists
          if (popup) {
            popup.setAttribute('data-original-examples', JSON.stringify(newExamples));
          }
          
          wordData.shouldAllowFetchMoreExamples = shouldAllowFetchMoreExamples;
          wordData.hasCalledGetMoreExamples = true; // Mark that API has been called
          console.log('[WordSelector] Updated examples and shouldAllowFetchMoreExamples for word:', word);
          console.log('[WordSelector] New examples count:', newExamples.length);
          console.log('[WordSelector] shouldAllowFetchMoreExamples:', shouldAllowFetchMoreExamples);
          console.log('[WordSelector] hasCalledGetMoreExamples set to true');
          console.log('[WordSelector] Examples saved to wordData.examples for persistence');
        }
      } else {
        console.error('[WordSelector] Failed to get more examples:', response.error);
        TextSelector.showNotification('Failed to load more examples');
      }
    } catch (error) {
      console.error('[WordSelector] Error fetching more examples:', error);
      TextSelector.showNotification('Error loading more examples');
    } finally {
      // Reset button state
      button.classList.remove('loading');
      button.innerHTML = originalHTML; // Restore original HTML (including icon)
    }
  },
  
  /**
   * Switch language tab (local language <-> EN)
   * @param {HTMLElement} popup - The popup element
   * @param {string} word - The word
   * @param {string} localLanguageCode - The local language code
   * @param {HTMLElement} localTab - The local language tab element
   * @param {HTMLElement} enTab - The EN tab element
   * @param {string} targetTab - The target tab to switch to ('EN' or localLanguageCode)
   */
  async switchLanguageTab(popup, word, localLanguageCode, localTab, enTab, targetTab) {
    const normalizedWord = word.toLowerCase();
    const currentTab = popup.getAttribute('data-current-tab');
    
    // If already on the target tab, do nothing
    if (currentTab === targetTab) {
      console.log('[WordSelector] Already on target tab, no action needed');
      return;
    }
    
    console.log('[WordSelector] Switching language tab:', {
      word: word,
      currentTab: currentTab,
      targetTab: targetTab,
      localLanguageCode: localLanguageCode
    });
    
    // Update tab group data attribute for sliding animation
    const tabGroup = popup.querySelector('.vocab-word-popup-tab-group');
    if (tabGroup) {
      tabGroup.setAttribute('data-active-tab', targetTab);
    }
    
    // Update tab active classes immediately for visual feedback
    if (targetTab === localLanguageCode) {
      localTab.classList.add('vocab-word-popup-tab-active');
      enTab.classList.remove('vocab-word-popup-tab-active');
    } else {
      enTab.classList.add('vocab-word-popup-tab-active');
      localTab.classList.remove('vocab-word-popup-tab-active');
    }
    
    // Wait for slide animation to complete before showing spinner
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // If switching to local language, show original content
    if (targetTab === localLanguageCode) {
      const originalMeaning = popup.getAttribute('data-original-meaning');
      const originalExamplesJson = popup.getAttribute('data-original-examples');
      let originalExamples = [];
      
      try {
        originalExamples = JSON.parse(originalExamplesJson) || [];
      } catch (e) {
        console.error('[WordSelector] Error parsing original examples:', e);
      }
      
      // Get current English examples from cache to compare counts
      let cachedEnExamples = [];
      if (this.translationCache.has(normalizedWord)) {
        const cached = this.translationCache.get(normalizedWord);
        cachedEnExamples = cached.examples || [];
      }
      
      // Check if there are English-only examples that need translation
      const enExamplesJson = popup.getAttribute('data-en-examples-only') || '[]';
      let enExamplesOnly = [];
      try {
        enExamplesOnly = JSON.parse(enExamplesJson) || [];
      } catch (e) {
        console.error('[WordSelector] Error parsing EN-only examples:', e);
      }
      
      // Compare example counts: if English has more examples than original, translate the new ones
      const totalEnExamples = cachedEnExamples.length + enExamplesOnly.length;
      const needsTranslation = totalEnExamples > originalExamples.length;
      
      if (needsTranslation) {
        console.log('[WordSelector] Example count mismatch - original:', originalExamples.length, 'total EN:', totalEnExamples);
        console.log('[WordSelector] Translating new English examples to local language');
        
        // Get the examples that need translation (the ones beyond original count)
        const examplesToTranslate = totalEnExamples > originalExamples.length 
          ? cachedEnExamples.slice(originalExamples.length) 
          : [];
        
        // Also include any English-only examples
        const allExamplesToTranslate = [...examplesToTranslate, ...enExamplesOnly];
        
        if (allExamplesToTranslate.length > 0) {
          console.log('[WordSelector] Translating new English examples to local language:', allExamplesToTranslate);
          
          // Show loading on local tab after slide animation
          localTab.disabled = true;
          localTab.classList.add('loading');
          const originalTabText = localTab.textContent;
          localTab.innerHTML = '<div class="vocab-loading-spinner" style="width: 10px; height: 10px; border: 2px solid white; border-top-color: transparent; border-radius: 50%; animation: vocab-spin 0.8s linear infinite;"></div>';
          
          try {
            // Translate new English examples to local language
            const payload = {
              targetLangugeCode: localLanguageCode,
              texts: allExamplesToTranslate
            };
            
            const url = `${ApiConfig.getCurrentBaseUrl()}${ApiConfig.ENDPOINTS.TRANSLATE}`;
            
            // Get X-Unauthenticated-User-Id header for request
            const unauthenticatedUserIdHeader = await ApiService.getUnauthenticatedUserIdHeader();
            
            // Prepare request headers
            const requestHeaders = {
              'Content-Type': 'application/json',
              ...unauthenticatedUserIdHeader
            };
            
            const response = await fetch(url, {
              method: 'POST',
              headers: requestHeaders,
              body: JSON.stringify(payload)
            });
            
            // Store X-Unauthenticated-User-Id from response header
            await ApiService.storeUnauthenticatedUserId(response);
            
            if (response.ok) {
              const data = await response.json();
              const translatedNewExamples = data.translatedTexts || [];
              
              // Combine original examples with translated new examples
              const allExamples = [...originalExamples, ...translatedNewExamples];
              
              // Update popup with local language content
              this.updatePopupContent(popup, word, originalMeaning, allExamples);
              
              // Update original examples to include translated new examples
              popup.setAttribute('data-original-examples', JSON.stringify(allExamples));
              
              // Update stored word data
              const normalizedWord = word.toLowerCase();
              if (this.explainedWords.has(normalizedWord)) {
                const wordData = this.explainedWords.get(normalizedWord);
                wordData.examples = allExamples;
              }
              
              // Clear English-only examples since they're now translated
              popup.removeAttribute('data-en-examples-only');
              
              // Update cache to reflect the new count
              if (this.translationCache.has(normalizedWord)) {
                const cached = this.translationCache.get(normalizedWord);
                // Keep the same meaning, but update examples count awareness
                // The cache will be updated when switching back to EN
              }
            } else {
              // If translation fails, just show original examples
              this.updatePopupContent(popup, word, originalMeaning, originalExamples);
            }
          } catch (error) {
            console.error('[WordSelector] Error translating new English examples:', error);
            // Fallback to original examples
            this.updatePopupContent(popup, word, originalMeaning, originalExamples);
          } finally {
            localTab.disabled = false;
            localTab.classList.remove('loading');
            localTab.textContent = originalTabText;
          }
        } else {
          // No examples to translate, just show original content
          this.updatePopupContent(popup, word, originalMeaning, originalExamples);
        }
      } else {
        // No translation needed, just show original content
        this.updatePopupContent(popup, word, originalMeaning, originalExamples);
      }
      
      // Update current tab attribute
      popup.setAttribute('data-current-tab', localLanguageCode);
      
      // Update button visibility: show button when local language tab is active
      const button = popup.querySelector('.vocab-word-popup-button');
      const askButton = popup.querySelector('.vocab-word-popup-ask-button');
      if (button) {
        // Get shouldAllowFetchMoreExamples from wordData
        const normalizedWord = word.toLowerCase();
        let shouldAllowFetchMoreExamples = true;
        if (this.explainedWords.has(normalizedWord)) {
          const wordData = this.explainedWords.get(normalizedWord);
          if (wordData.hasCalledGetMoreExamples) {
            shouldAllowFetchMoreExamples = wordData.shouldAllowFetchMoreExamples || false;
          }
        }
        
        if (shouldAllowFetchMoreExamples) {
          button.style.display = 'flex';
          popup.classList.remove('no-more-examples-button');
        } else {
          button.style.display = 'none';
          popup.classList.add('no-more-examples-button');
        }
        // Always keep Ask AI button visible
        if (askButton) {
          askButton.style.display = 'flex';
        }
      }
      
    } else {
      // Switching to EN - translate to English
      const originalMeaning = popup.getAttribute('data-original-meaning');
      const originalExamplesJson = popup.getAttribute('data-original-examples');
      let originalExamples = [];
      
      try {
        originalExamples = JSON.parse(originalExamplesJson) || [];
      } catch (e) {
        console.error('[WordSelector] Error parsing original examples:', e);
      }
      
      // Show loading on EN tab after slide animation
      enTab.disabled = true;
      enTab.classList.add('loading');
      const originalTabText = enTab.textContent;
      enTab.innerHTML = '<div class="vocab-loading-spinner" style="width: 10px; height: 10px; border: 2px solid white; border-top-color: transparent; border-radius: 50%; animation: vocab-spin 0.8s linear infinite;"></div>';
      
      try {
        // Check cache first
        let translatedMeaning, translatedExamples;
        
        if (this.translationCache.has(normalizedWord)) {
          console.log('[WordSelector] Using cached translation for:', word);
          const cached = this.translationCache.get(normalizedWord);
          translatedMeaning = cached.meaning;
          translatedExamples = cached.examples;
          
          // Compare number of examples: if original has more examples than cached, re-translate
          if (originalExamples.length !== translatedExamples.length) {
            console.log('[WordSelector] Example count mismatch - original:', originalExamples.length, 'cached EN:', translatedExamples.length);
            console.log('[WordSelector] Re-translating all examples to English');
            
            // Clear cache and re-translate
            this.translationCache.delete(normalizedWord);
            translatedMeaning = null;
            translatedExamples = null;
          }
        }
        
        // If no cache or cache was invalid, translate
        if (!translatedMeaning || !translatedExamples) {
          // Prepare API payload - combine explanation_text and examples into texts array
          const texts = [originalMeaning, ...originalExamples];
          const payload = {
            targetLangugeCode: "EN",
            texts: texts
          };
          
          console.log('[WordSelector] Calling translate API with payload:', payload);
          
          // Call translate API
          const url = `${ApiConfig.getCurrentBaseUrl()}${ApiConfig.ENDPOINTS.TRANSLATE}`;
          
          // Get X-Unauthenticated-User-Id header for request
          const unauthenticatedUserIdHeader = await ApiService.getUnauthenticatedUserIdHeader();
          
          // Prepare request headers
          const requestHeaders = {
            'Content-Type': 'application/json',
            ...unauthenticatedUserIdHeader
          };
          
          const response = await fetch(url, {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(payload)
          });
          
          // Store X-Unauthenticated-User-Id from response header
          await ApiService.storeUnauthenticatedUserId(response);
          
          if (!response.ok) {
            throw new Error(`Translation API failed: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log('[WordSelector] Translation API response:', data);
          
          // Extract translated meaning and examples from translatedTexts array
          const translatedTexts = data.translatedTexts || [];
          translatedMeaning = translatedTexts[0] || originalMeaning;
          translatedExamples = translatedTexts.slice(1) || [];
          
          // Cache the translation
          this.translationCache.set(normalizedWord, {
            meaning: translatedMeaning,
            examples: translatedExamples
          });
          
          console.log('[WordSelector] Translation cached for:', word);
        }
        
        // Update popup with English content
        this.updatePopupContent(popup, word, translatedMeaning, translatedExamples);
        
        // Update current tab attribute
        popup.setAttribute('data-current-tab', 'EN');
        
        // Update button visibility: always hide button when EN tab is active
        // But Ask AI button should always be visible
        const button = popup.querySelector('.vocab-word-popup-button');
        const askButton = popup.querySelector('.vocab-word-popup-ask-button');
        if (button) {
          button.style.display = 'none';
          popup.classList.add('no-more-examples-button');
        }
        // Always keep Ask AI button visible
        if (askButton) {
          askButton.style.display = 'flex';
        }
        
      } catch (error) {
        console.error('[WordSelector] Error translating to English:', error);
        alert('Failed to translate to English. Please try again.');
      } finally {
        enTab.disabled = false;
        enTab.classList.remove('loading');
        enTab.textContent = originalTabText;
      }
    }
  },
  
  /**
   * Update popup content with text (meaning and examples)
   * @param {HTMLElement} popup - The popup element
   * @param {string} word - The word
   * @param {string} meaning - The meaning to display
   * @param {Array<string>} examples - The examples to display
   */
  updatePopupContent(popup, word, meaning, examples) {
    // Update meaning
    const meaningDiv = popup.querySelector('.vocab-word-popup-meaning');
    if (meaningDiv) {
      meaningDiv.innerHTML = `<span class="word-bold">${word}</span> means ${meaning}`;
    }
    
    // Update examples section - ensure heading exists below separator
    const examplesContainer = popup.querySelector('.vocab-word-popup-examples-container');
    if (examples && examples.length > 0) {
      let examplesHeading = popup.querySelector('.vocab-word-popup-examples-heading');
      if (!examplesHeading && examplesContainer) {
        examplesHeading = document.createElement('div');
        examplesHeading.className = 'vocab-word-popup-examples-heading';
        examplesHeading.textContent = 'Examples';
        examplesHeading.style.setProperty('color', 'rgba(147, 51, 234, 0.7)', 'important'); // Light purple
        examplesHeading.style.setProperty('text-align', 'center', 'important');
        examplesHeading.style.setProperty('font-size', '18px', 'important'); // Increased font size
        examplesHeading.style.setProperty('font-weight', '600', 'important'); // Thicker/bolder
        examplesHeading.style.setProperty('margin-bottom', '10px', 'important');
        examplesHeading.style.setProperty('margin-top', '8px', 'important'); // Space below separator
        // Insert heading as first child of examples container (after separator)
        const examplesList = examplesContainer.querySelector('.vocab-word-popup-examples');
        if (examplesList) {
          examplesContainer.insertBefore(examplesHeading, examplesList);
        } else {
          examplesContainer.appendChild(examplesHeading);
        }
      } else if (examplesHeading) {
        // Update existing heading styles
        examplesHeading.style.setProperty('font-size', '18px', 'important'); // Increased font size
        examplesHeading.style.setProperty('font-weight', '600', 'important');
      }
    } else {
      // Remove heading if no examples
      const examplesHeading = popup.querySelector('.vocab-word-popup-examples-heading');
      if (examplesHeading) {
        examplesHeading.remove();
      }
    }
    
    // Update examples
    const examplesList = popup.querySelector('.vocab-word-popup-examples');
    if (examplesList) {
      examplesList.innerHTML = '';
      if (examples && examples.length > 0) {
        examples.forEach(example => {
          const li = document.createElement('li');
          const regex = new RegExp(`\\b${word}\\b`, 'gi');
          const highlightedExample = example.replace(regex, `<span class="word-bold">${word}</span>`);
          li.innerHTML = highlightedExample;
          examplesList.appendChild(li);
        });
      }
    }
    
    console.log('[WordSelector] Popup content updated');
  },
  
  /**
   * Position popup relative to word highlight
   * @param {HTMLElement} popup - The popup element
   * @param {HTMLElement} wordElement - The word highlight element
   */
  positionPopup(popup, wordElement) {
    console.log('[WordSelector] ===== POSITIONING POPUP =====');
    
    // Validate inputs
    if (!popup || !wordElement) {
      console.error('[WordSelector] ✗ Invalid inputs for positionPopup:', { popup, wordElement });
      return;
    }
    
    if (!document.body.contains(wordElement)) {
      console.error('[WordSelector] ✗ wordElement is not in DOM');
      return;
    }
    
    if (!document.body.contains(popup)) {
      console.error('[WordSelector] ✗ popup is not in DOM');
      return;
    }
    
    const rect = wordElement.getBoundingClientRect();
    console.log('[WordSelector] Word element bounding rect:', {
      top: rect.top,
      left: rect.left,
      bottom: rect.bottom,
      right: rect.right,
      width: rect.width,
      height: rect.height,
      scrollY: window.scrollY,
      scrollX: window.scrollX
    });
    
    // Check if element is visible
    if (rect.width === 0 || rect.height === 0) {
      console.warn('[WordSelector] ⚠ Word element has zero dimensions, may not be visible');
    }
    
    const popupHeight = popup.offsetHeight || 250; // Estimated height
    const popupWidth = popup.offsetWidth || 340;
    
    console.log('[WordSelector] Popup dimensions:', {
      width: popupWidth,
      height: popupHeight,
      offsetWidth: popup.offsetWidth,
      offsetHeight: popup.offsetHeight
    });
    
    // Calculate position (bottom-right of word, not overlapping)
    let top = rect.bottom + window.scrollY + 8; // 8px gap below word
    let left = rect.right + window.scrollX - popupWidth / 2; // Center horizontally with word
    
    console.log('[WordSelector] Initial calculated position:', { top, left });
    
    // Adjust if popup goes off-screen
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    console.log('[WordSelector] Viewport dimensions:', {
      width: viewportWidth,
      height: viewportHeight
    });
    
    // Horizontal adjustment
    if (left + popupWidth > viewportWidth + window.scrollX) {
      const oldLeft = left;
      left = viewportWidth + window.scrollX - popupWidth - 10;
      console.log('[WordSelector] Adjusted left (right edge):', { oldLeft, newLeft: left });
    }
    if (left < window.scrollX + 10) {
      const oldLeft = left;
      left = window.scrollX + 10;
      console.log('[WordSelector] Adjusted left (left edge):', { oldLeft, newLeft: left });
    }
    
    // Vertical adjustment (if not enough space below, show above)
    if (rect.bottom + popupHeight > viewportHeight + window.scrollY) {
      const oldTop = top;
      top = rect.top + window.scrollY - popupHeight - 8; // Show above
      console.log('[WordSelector] Adjusted top (showing above):', { oldTop, newTop: top });
    }
    
    popup.style.top = `${top}px`;
    popup.style.left = `${left}px`;
    
    console.log('[WordSelector] ✓ Final popup position set:', {
      top: `${top}px`,
      left: `${left}px`,
      styleTop: popup.style.top,
      styleLeft: popup.style.left
    });
  },
  
  /**
   * Open web search modal for a word
   * @param {string} word - The word to search for
   * @param {string} meaning - The word meaning
   * @param {Array<string>} examples - Example sentences
   * @param {HTMLElement} wordPopup - The word meaning popup element
   * @param {HTMLElement} searchButton - The search button element for positioning
   */
  openWebSearchModal(word, meaning, examples, wordPopup, searchButton) {
    console.log('[WordSelector] Opening web search modal for:', word);
    
    const normalizedWord = word.toLowerCase();
    
    // Check if there's existing chat history for this word
    let existingChatHistory = [];
    let existingInitialContext = '';
    if (this.explainedWords.has(normalizedWord)) {
      const wordData = this.explainedWords.get(normalizedWord);
      if (wordData.askAIChatHistory) {
        existingChatHistory = wordData.askAIChatHistory;
      }
      if (wordData.askAIInitialContext) {
        existingInitialContext = wordData.askAIInitialContext;
      }
    }
    
    // Extract word context (15 words before + word + 15 words after) if not already set
    if (!existingInitialContext || existingInitialContext.trim() === '') {
      const docText = this.getDocumentText();
      const positions = this.findWordPositionsInDocument(normalizedWord);
      
      if (positions.length > 0) {
        // Use the first position
        const position = positions[0];
        const context = this.extractWordContext(docText, position, word.length);
        existingInitialContext = context.text;
        console.log('[WordSelector] Extracted word context for initial_context:', existingInitialContext.substring(0, 100) + '...');
      } else {
        // Fallback if word not found in document
        existingInitialContext = `Word: ${word}`;
        console.log('[WordSelector] Word not found in document, using fallback context');
      }
    }
    
    // Note: Toggle behavior is now handled in the button click handler
    // This function is called when we want to open the modal (not toggle)
    this.createAndShowAskAIModal(word, meaning, examples, wordPopup, searchButton, existingChatHistory, existingInitialContext);
  },
  
  /**
   * Create and show the Ask AI modal with opening animation
   */
  createAndShowAskAIModal(word, meaning, examples, wordPopup, searchButton, existingChatHistory = [], existingInitialContext = '') {
    // Store reference to WordSelector instance for use in nested functions
    const wordSelector = this;
    const normalizedWord = word.toLowerCase();
    
    // Get search button position for modal positioning
    // For position: fixed, use viewport coordinates (getBoundingClientRect already gives viewport coords)
    const searchButtonRect = searchButton.getBoundingClientRect();
    const searchButtonTop = searchButtonRect.top;
    const searchButtonBottom = searchButtonRect.bottom;
    const searchButtonLeft = searchButtonRect.left;
    const searchButtonRight = searchButtonRect.right;
    
    // Also get word popup position for reference
    const wordPopupRect = wordPopup.getBoundingClientRect();
    const wordPopupTop = wordPopupRect.top;
    const wordPopupBottom = wordPopupRect.bottom;
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'word-web-search-modal';
    modal.setAttribute('data-word', word.toLowerCase());
    
    // Create modal content container
    const modalContent = document.createElement('div');
    modalContent.className = 'word-ask-ai-modal-content';
    
    // Header removed - no minimization icon needed
    
    // Create search results container
    const resultsContainer = document.createElement('div');
    resultsContainer.className = 'word-web-search-results';
    
    // Create loading indicator
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'word-web-search-loading';
    loadingIndicator.innerHTML = `
      <div class="word-web-search-loading-spinner"></div>
      <div class="word-web-search-loading-text">Searching the web...</div>
    `;
    resultsContainer.appendChild(loadingIndicator);
    
    // Create metadata display
    const metadataDiv = document.createElement('div');
    metadataDiv.className = 'word-web-search-metadata';
    metadataDiv.style.display = 'none';
    
    // Create results list
    const resultsList = document.createElement('div');
    resultsList.className = 'word-web-search-results-list';
    
    // Create chat input area (similar to vocab-chat-input-area)
    const inputArea = document.createElement('div');
    inputArea.className = 'word-web-search-input-area';
    
    const inputField = document.createElement('textarea');
    inputField.className = 'word-web-search-input';
    inputField.placeholder = 'Ask AI anything about the word';
    inputField.rows = 1;
    
    // Auto-resize textarea
    inputField.addEventListener('input', (e) => {
      e.target.style.height = 'auto';
      const maxHeight = 120;
      const newHeight = Math.min(e.target.scrollHeight, maxHeight);
      e.target.style.height = newHeight + 'px';
      
      if (e.target.scrollHeight > maxHeight) {
        e.target.style.overflowY = 'auto';
      } else {
        e.target.style.overflowY = 'hidden';
      }
      
      // Update explain button visibility when input changes
      if (modal._updateExplainButtonVisibility) {
        modal._updateExplainButtonVisibility();
      }
    });
    
    // Handle Enter key
    inputField.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        e.stopPropagation();
        this.sendWebSearchChatMessage(modal, word, inputField);
      }
    });
    
    // Prevent clicks in input from closing word popup
    inputField.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Create send button (upward arrow)
    const sendBtn = document.createElement('button');
    sendBtn.className = 'word-web-search-send-btn';
    sendBtn.setAttribute('aria-label', 'Send message');
    sendBtn.innerHTML = this.createSendIcon();
    sendBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Check if API call is in progress (stop icon is shown)
      const isStopIcon = sendBtn.querySelector('rect[fill="#9527F5"]');
      if (isStopIcon) {
        // Abort the API call
        const abortFn = modal._currentAbortFn;
        if (abortFn && typeof abortFn === 'function') {
          console.log('[WordSelector] Aborting API call');
          abortFn();
          // Store current chat in memory before aborting
          const resultsList = modal.querySelector('.word-web-search-results-list');
          const chatMessages = resultsList.querySelectorAll('.word-web-search-chat-message');
          if (chatMessages.length > 0) {
            // Build chat history from current messages
            const chatHistory = [];
            chatMessages.forEach((msg, index) => {
              if (msg.classList.contains('user-message')) {
                chatHistory.push({
                  role: 'user',
                  content: msg.textContent.trim()
                });
              } else if (msg.classList.contains('ai-message')) {
                const responseText = msg.querySelector('.word-web-search-chat-response-text');
                if (responseText) {
                  chatHistory.push({
                    role: 'assistant',
                    content: responseText.textContent.trim()
                  });
                }
              }
            });
            // Store in modal
            modal.setAttribute('data-chat-history', JSON.stringify(chatHistory));
            // Also save to explainedWords map
            const normalizedWord = word.toLowerCase();
            if (this.explainedWords.has(normalizedWord)) {
              const wordData = this.explainedWords.get(normalizedWord);
              wordData.askAIChatHistory = chatHistory;
              console.log('[WordSelector] Saved chat history to explainedWords map after abort');
            }
          }
          // Clear abort function
          modal._currentAbortFn = null;
          // Restore send icon
          sendBtn.innerHTML = this.createSendIcon();
          sendBtn.setAttribute('aria-label', 'Send message');
        }
      } else {
        // Normal send action
        this.sendWebSearchChatMessage(modal, word, inputField);
      }
    });
    
    // Create delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'word-web-search-delete-btn';
    deleteBtn.setAttribute('aria-label', 'Clear chat history');
    deleteBtn.title = 'Clear chat history';
    deleteBtn.innerHTML = this.createTrashIcon();
    deleteBtn.style.display = 'none'; // Hidden by default, show when chat history exists
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      this.clearWebSearchChatHistory(modal);
    });
    
    // Create "Explain" button - shown when there's no content in results
    const explainBtn = document.createElement('button');
    explainBtn.className = 'word-web-search-explain-btn';
    explainBtn.textContent = 'Explain';
    explainBtn.setAttribute('aria-label', 'Explain word');
    explainBtn.style.setProperty('display', 'none', 'important'); // Hidden by default, shown when no content
    explainBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Simulate asking "Please explain the selected word in detail"
      inputField.value = 'Please explain the selected word in detail';
      // Trigger the send action
      this.sendWebSearchChatMessage(modal, word, inputField);
      // Hide the explain button after clicking
      explainBtn.style.setProperty('display', 'none', 'important');
    });
    
    // Add padding to input field to make room for explain button on the right
    inputField.style.paddingRight = '90px';
    
    inputArea.appendChild(inputField);
    inputArea.appendChild(explainBtn); // Explain button positioned absolutely inside inputArea
    inputArea.appendChild(sendBtn);
    inputArea.appendChild(deleteBtn);
    
    // Function to update explain button visibility based on input and results state
    const updateExplainButtonVisibility = () => {
      const inputValue = inputField.value.trim();
      const resultsList = modal.querySelector('.word-web-search-results-list');
      
      // Check if input area has content (input field has text)
      const isInputEmpty = !inputValue;
      
      // Check if results container has content (results list has children)
      const isResultsEmpty = !resultsList || resultsList.children.length === 0;
      
      // Show explain button only if BOTH input and results are empty
      // Use setProperty with !important to override CSS rules
      if (isInputEmpty && isResultsEmpty) {
        explainBtn.style.setProperty('display', 'flex', 'important');
      } else {
        explainBtn.style.setProperty('display', 'none', 'important');
      }
    };
    
    // Function to check if results container should be visible
    const updateResultsVisibility = () => {
      const resultsList = modal.querySelector('.word-web-search-results-list');
      const loadingIndicator = modal.querySelector('.word-web-search-loading');
      const hasContent = resultsList && resultsList.children.length > 0;
      const isLoading = loadingIndicator && loadingIndicator.style.display !== 'none';
      
      if (hasContent || isLoading) {
        // Show results container if there's content or loading
        resultsContainer.style.display = '';
      } else {
        // Hide results container if no content
        resultsContainer.style.display = 'none';
      }
      
      // Update explain button visibility
      updateExplainButtonVisibility();
    };
    
    // Initial visibility check
    updateResultsVisibility();
    
    // Store the update function on the modal for later use
    modal._updateResultsVisibility = updateResultsVisibility;
    modal._updateExplainButtonVisibility = updateExplainButtonVisibility;
    
    // Prevent clicks inside modal from closing word popup
    modal.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Assemble modal (header removed)
    modalContent.appendChild(resultsContainer);
    resultsContainer.appendChild(metadataDiv);
    resultsContainer.appendChild(resultsList);
    modalContent.appendChild(inputArea);
    modal.appendChild(modalContent);
    
    // Append to body
    document.body.appendChild(modal);
    
    // Make modal draggable/pannable
    try {
      // Use the stored wordSelector reference (which is 'this' at function start)
      // Try multiple ways to access the method to handle minification issues
      const target = wordSelector || this;
      let initMethod = null;
      
      // Try direct property access
      if (target && typeof target.initModalDragging === 'function') {
        initMethod = target.initModalDragging;
      }
      // Try bracket notation (in case property name is minified)
      else if (target && target['initModalDragging'] && typeof target['initModalDragging'] === 'function') {
        initMethod = target['initModalDragging'];
      }
      // Try to find the method by iterating properties (for minified code)
      else if (target && typeof target === 'object') {
        for (const key in target) {
          if (typeof target[key] === 'function' && key.toLowerCase().includes('dragging')) {
            initMethod = target[key];
            break;
          }
        }
      }
      
      if (initMethod) {
        initMethod.call(target, modal);
      } else {
        console.error('[WordSelector] initModalDragging method not found.', {
          target: target,
          hasTarget: !!target,
          targetType: typeof target,
          targetKeys: target ? Object.keys(target).filter(k => k.toLowerCase().includes('drag') || k.toLowerCase().includes('modal')).slice(0, 20) : null,
          wordSelector: wordSelector,
          hasThis: !!this
        });
      }
    } catch (error) {
      console.error('[WordSelector] Error initializing modal dragging:', error);
      // Continue anyway - modal will still work, just won't be draggable
    }
    
    // Set initial styles - start with scale(0) for animation
    // Use absolute positioning so modal scrolls with page
    modal.style.setProperty('position', 'absolute', 'important');
    modal.style.setProperty('z-index', '10000020', 'important');
    modal.style.setProperty('display', 'flex', 'important');
    modal.style.setProperty('visibility', 'visible', 'important');
    modal.style.setProperty('opacity', '0', 'important'); // Start invisible, will be set to 1 when animation starts
    // DO NOT set initial transform - let CSS animation handle it via CSS variables
    modal.style.setProperty('background', 'white', 'important');
    modal.style.setProperty('pointer-events', 'all', 'important');
    // Ensure modal has minimum dimensions for animation to be visible
    modal.style.setProperty('min-width', '300px', 'important');
    modal.style.setProperty('min-height', '200px', 'important');
    
    // Position modal relative to search button
    // Convert viewport coordinates to document coordinates (add scroll offset)
    const scrollX = window.scrollX || window.pageXOffset || 0;
    const scrollY = window.scrollY || window.pageYOffset || 0;
    modal.style.setProperty('top', `${searchButtonTop + scrollY}px`, 'important');
    modal.style.setProperty('left', `${searchButtonRight + scrollX + 20}px`, 'important');
    
    // Function to reposition modal intelligently
    const repositionModal = () => {
      // Don't reposition if user is currently dragging the modal
      if (modal.hasAttribute('data-is-dragging') && modal.getAttribute('data-is-dragging') === 'true') {
        return;
      }
      
      // Don't reposition if animation just completed (prevent glitch)
      if (modal.getAttribute('data-animation-complete') === 'false') {
        return;
      }
      
      const modalRect = modal.getBoundingClientRect();
      const modalHeight = modalRect.height;
      const modalWidth = modalRect.width;
      
      // Get current scroll position
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const padding = 15; // Increased padding for better visibility
      
      // Get current button positions (viewport coordinates)
      const currentButtonRect = searchButton.getBoundingClientRect();
      const currentButtonRight = currentButtonRect.right;
      const currentButtonLeft = currentButtonRect.left;
      const currentButtonTop = currentButtonRect.top;
      const currentButtonBottom = currentButtonRect.bottom;
      
      // Get current word popup positions (viewport coordinates)
      const currentWordPopupRect = wordPopup.getBoundingClientRect();
      const currentWordPopupTop = currentWordPopupRect.top;
      const currentWordPopupBottom = currentWordPopupRect.bottom;
      
      // ===== HORIZONTAL POSITIONING - Prioritize full visibility =====
      let modalLeft;
      
      // Calculate available space on both sides (viewport coordinates)
      const spaceOnRight = viewportWidth - currentButtonRight;
      const spaceOnLeft = currentButtonLeft;
      
      // Check if modal can fit on either side
      const canFitOnRight = spaceOnRight >= modalWidth + padding;
      const canFitOnLeft = spaceOnLeft >= modalWidth + padding;
      
      if (canFitOnRight && canFitOnLeft) {
        // Both sides have space - prefer right side
        modalLeft = currentButtonRight + 20;
      } else if (canFitOnRight) {
        // Only right side has space
        modalLeft = currentButtonRight + 20;
      } else if (canFitOnLeft) {
        // Only left side has space
        modalLeft = currentButtonLeft - modalWidth - 20;
      } else {
        // Neither side has enough space - center it or position optimally
        // Position to maximize visibility
        if (spaceOnRight > spaceOnLeft) {
          // More space on right, position as far right as possible while staying visible
          modalLeft = Math.max(padding, viewportWidth - modalWidth - padding);
        } else {
          // More space on left, position as far left as possible while staying visible
          modalLeft = padding;
        }
      }
      
      // Final safety check: ensure modal is fully visible horizontally (viewport coordinates)
      // Constrain to viewport - modal should never go off left or right side
      modalLeft = Math.max(padding, Math.min(modalLeft, viewportWidth - modalWidth - padding));
      
      // Convert to document coordinates (horizontal position stays within viewport)
      modalLeft = modalLeft + scrollX;
      
      // ===== VERTICAL POSITIONING - Allow to go outside viewport =====
      let modalTop;
      
      // Position relative to button (viewport coordinates)
      // Try to position below button first, but allow it to go outside viewport
      modalTop = Math.min(currentWordPopupTop, currentButtonTop);
      
      // Convert to document coordinates for vertical position
      // Allow modal to go outside viewport vertically (top/bottom) when scrolling
      modalTop = modalTop + scrollY;
      
      // Note: We don't constrain vertical position to viewport - it's OK if it goes
      // above or below the viewport when scrolling. Only horizontal position is constrained.
      
      modal.style.setProperty('top', `${modalTop}px`, 'important');
      modal.style.setProperty('left', `${modalLeft}px`, 'important');
      
      console.log('[WordSelector] Modal repositioned:', {
        searchButtonTop,
        searchButtonBottom,
        wordPopupTop,
        wordPopupBottom,
        modalTop,
        modalHeight,
        modalBottom: modalTop + modalHeight,
        modalLeft,
        modalWidth,
        viewportWidth,
        viewportHeight,
        spaceOnRight,
        spaceOnLeft,
        canFitOnRight,
        canFitOnLeft
      });
    };
    
    // Initial positioning is handled in the animation code below
    // Don't call repositionModal() here as it would interfere with the animation
    
    // Reposition when content changes (using MutationObserver)
    const observer = new MutationObserver(() => {
      // Debounce repositioning to avoid excessive calls
      clearTimeout(modal._repositionTimeout);
      modal._repositionTimeout = setTimeout(() => {
        repositionModal();
      }, 100);
      
      // Auto-scroll when content changes (only if user is at bottom)
      const resultsListForScroll = modal.querySelector('.word-web-search-results-list');
      if (resultsListForScroll) {
        // Use immediate scroll during content updates for smooth experience
        this.scrollToBottom(resultsListForScroll, true, true);
      }
    });
    
    // Observe changes in the results list (where chat messages are added)
    const resultsListForObserver = modal.querySelector('.word-web-search-results-list');
    if (resultsListForObserver) {
      observer.observe(resultsListForObserver, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }
    
    // Also observe window resize and scroll
    const handleResize = () => {
      repositionModal();
    };
    
    const handleScroll = () => {
      // Update modal position when page scrolls
      repositionModal();
    };
    
    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleScroll, { passive: true });
    
    // Store cleanup function on modal
    modal._cleanupPositioning = () => {
      observer.disconnect();
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('scroll', handleScroll);
      if (modal._repositionTimeout) {
        clearTimeout(modal._repositionTimeout);
      }
    };
    
    // Store initial context and chat history (ensure initial context is never empty)
    // initial_context should be: 15 words before + word + 15 words after
    const safeInitialContext = (existingInitialContext && existingInitialContext.trim() !== '') 
      ? existingInitialContext 
      : `Word: ${word}`;
    modal.setAttribute('data-initial-context', safeInitialContext);
    modal.setAttribute('data-chat-history', JSON.stringify(existingChatHistory));
    
    // Restore chat history if it exists
    if (existingChatHistory.length > 0) {
      // Hide loading indicator
      const loadingIndicatorElement = modal.querySelector('.word-web-search-loading');
      if (loadingIndicatorElement) {
        loadingIndicatorElement.style.display = 'none';
      }
      
      // Show delete button
      deleteBtn.style.display = 'flex';
      
      // Restore chat messages
      existingChatHistory.forEach((msg) => {
        if (msg.role === 'user') {
          const userMessageDiv = document.createElement('div');
          userMessageDiv.className = 'word-web-search-chat-message user-message';
          // Extract original question from prefixed question
          const prefixedContent = msg.content;
          // Match the prefix pattern - use a simpler, more reliable approach
          // Pattern: "Here the word of interest is 'WORD'. Based on the context given can you answer my question. Here is my question :- USER_QUESTION"
          // Extract everything after "Here is my question :- " which is more reliable
          const questionMarker = 'Here is my question :- ';
          const markerIndex = prefixedContent.indexOf(questionMarker);
          let originalQuestion;
          if (markerIndex !== -1) {
            // Extract the question part after the marker
            originalQuestion = prefixedContent.substring(markerIndex + questionMarker.length);
          } else {
            // Fallback: try regex pattern
            const prefixMatch = prefixedContent.match(/Here is my question :- (.+)$/);
            if (prefixMatch && prefixMatch[1]) {
              originalQuestion = prefixMatch[1];
            } else {
              // Last resort: use full content
              originalQuestion = prefixedContent;
            }
          }
          // Display only the original question (without prefix) in the UI
          // The full prefixed question is still stored in chat history and sent to API
          userMessageDiv.textContent = originalQuestion;
          resultsList.appendChild(userMessageDiv);
        } else if (msg.role === 'assistant') {
          const aiMessageDiv = document.createElement('div');
          aiMessageDiv.className = 'word-web-search-chat-message ai-message';
          const aiResponseText = document.createElement('div');
          aiResponseText.className = 'word-web-search-chat-response-text';
          aiResponseText.innerHTML = this.renderMarkdown(msg.content);
          aiMessageDiv.appendChild(aiResponseText);
          resultsList.appendChild(aiMessageDiv);
        }
      });
      
      // Scroll to bottom when restoring chat history
      this.scrollToBottom(resultsList, false, false);
      
      // Update results visibility after restoring chat history
      if (modal._updateResultsVisibility) {
        modal._updateResultsVisibility();
      }
    } else {
      // Hide loading indicator since we're not searching automatically
      const loadingIndicatorElement = modal.querySelector('.word-web-search-loading');
      if (loadingIndicatorElement) {
        loadingIndicatorElement.style.display = 'none';
      }
      
      // Update results visibility - should show explain button when no content
      if (modal._updateResultsVisibility) {
        modal._updateResultsVisibility();
      }
    }
    
    // Animate opening from button center to final position (no smooth fade/scale)
    try {
      // Get current button position (viewport coordinates) right before animation
      const buttonRectForCenter = searchButton.getBoundingClientRect();
      const buttonLeft = buttonRectForCenter.left;
      const buttonRight = buttonRectForCenter.right;
      const buttonTop = buttonRectForCenter.top;
      const buttonBottom = buttonRectForCenter.bottom;
      
      // Calculate button center position correctly
      // Center X = left + (right - left) / 2 = left + width/2
      const buttonCenterX = buttonLeft + (buttonRight - buttonLeft) / 2;
      // Center Y = top + (bottom - top) / 2 = top + height/2
      const buttonCenterY = buttonTop + (buttonBottom - buttonTop) / 2;
      
      // Clean up any previous animation state
      modal.classList.remove('ask-ai-closing');
      
      // Force a reflow to ensure modal is rendered and we can get its dimensions
      void modal.offsetHeight;
      
      // Get modal dimensions
      // The modal CSS has: width: 90vw !important; max-width: 600px !important;
      // So the final width should be: min(90vw, 600px)
      const modalMaxWidth = 600; // From CSS: max-width: 600px !important
      const vwWidth = window.innerWidth;
      const viewportBasedWidth = vwWidth * 0.9; // 90vw
      
      // Calculate final width respecting max-width constraint
      const modalWidth = Math.min(viewportBasedWidth, modalMaxWidth);
      
      // CRITICAL: Calculate final height BEFORE setting dimensions to 0x0
      // Temporarily set the modal to its final width to get accurate height
      // Save current state
      const originalMinWidth = modal.style.minWidth;
      const originalMinHeight = modal.style.minHeight;
      const originalMaxWidth = modal.style.maxWidth;
      const originalMaxHeight = modal.style.maxHeight;
      const originalWidth = modal.style.width;
      const originalHeight = modal.style.height;
      
      // Temporarily set modal to final width to measure its natural height
      modal.style.setProperty('min-width', '0px', 'important');
      modal.style.setProperty('min-height', '0px', 'important');
      modal.style.setProperty('max-width', `${modalMaxWidth}px`, 'important');
      modal.style.setProperty('width', `${modalWidth}px`, 'important');
      modal.style.setProperty('height', 'auto', 'important');
      
      // Force reflow to get accurate height measurement
      void modal.offsetHeight;
      const modalRect = modal.getBoundingClientRect();
      const modalHeight = modalRect.height || 300; // Get actual rendered height
      
      // Restore original state (will be overridden below, but ensures clean state)
      if (originalMinWidth) modal.style.minWidth = originalMinWidth;
      if (originalMinHeight) modal.style.minHeight = originalMinHeight;
      if (originalMaxWidth) modal.style.maxWidth = originalMaxWidth;
      if (originalMaxHeight) modal.style.maxHeight = originalMaxHeight;
      if (originalWidth) modal.style.width = originalWidth;
      if (originalHeight) modal.style.height = originalHeight;
      
      // Calculate final position using same logic as repositionModal
      // CRITICAL: Get fresh button/popup positions right before calculation to ensure accuracy
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      const viewportWidth = window.innerWidth;
      const padding = 15;
      
      // Force a reflow to ensure we get the most current positions
      void searchButton.offsetHeight;
      void wordPopup.offsetHeight;
      
      // Get current button and popup positions (viewport coordinates) - get fresh positions
      const currentButtonRect = searchButton.getBoundingClientRect();
      const currentButtonRight = currentButtonRect.right;
      const currentButtonLeft = currentButtonRect.left;
      const currentButtonTop = currentButtonRect.top;
      const currentWordPopupRect = wordPopup.getBoundingClientRect();
      const currentWordPopupTop = currentWordPopupRect.top;
      
      // Calculate horizontal final position using EXACT same logic as repositionModal
      const spaceOnRight = viewportWidth - currentButtonRight;
      const spaceOnLeft = currentButtonLeft;
      const canFitOnRight = spaceOnRight >= modalWidth + padding;
      const canFitOnLeft = spaceOnLeft >= modalWidth + padding;
      
      let finalLeft;
      if (canFitOnRight && canFitOnLeft) {
        // Both sides have space - prefer right side
        finalLeft = currentButtonRight + 20;
      } else if (canFitOnRight) {
        // Only right side has space
        finalLeft = currentButtonRight + 20;
      } else if (canFitOnLeft) {
        // Only left side has space
        finalLeft = currentButtonLeft - modalWidth - 20;
      } else {
        // Neither side has enough space - position optimally
        if (spaceOnRight > spaceOnLeft) {
          // More space on right, position as far right as possible while staying visible
          finalLeft = Math.max(padding, viewportWidth - modalWidth - padding);
        } else {
          // More space on left, position as far left as possible while staying visible
          finalLeft = padding;
        }
      }
      // Final safety check: ensure modal is fully visible horizontally (viewport coordinates)
      finalLeft = Math.max(padding, Math.min(finalLeft, viewportWidth - modalWidth - padding));
      // Convert to document coordinates
      finalLeft = finalLeft + scrollX;
      
      // Calculate vertical final position using EXACT same logic as repositionModal
      const finalTop = Math.min(currentWordPopupTop, currentButtonTop) + scrollY;
      
      console.log('[WordSelector] Opening animation - Final position calculated:', {
        modalWidth,
        modalHeight,
        finalLeft,
        finalTop,
        currentButtonRight,
        currentButtonLeft,
        spaceOnRight,
        spaceOnLeft,
        canFitOnRight,
        canFitOnLeft
      });
      
      // Set initial position at button center (convert viewport to document coordinates)
      // Start from button center with 0x0 dimensions - same position as closing animation destination
      const initialLeft = buttonCenterX + scrollX;
      const initialTop = buttonCenterY + scrollY;
      
      // CRITICAL: Override min-width and min-height to allow starting from 0x0
      // Do this BEFORE setting width/height to 0px
      // Temporarily remove max-width to allow 0x0, but we'll restore it after animation
      modal.style.setProperty('min-width', '0px', 'important');
      modal.style.setProperty('min-height', '0px', 'important');
      modal.style.setProperty('max-width', 'none', 'important'); // Temporarily remove for animation
      modal.style.setProperty('max-height', 'none', 'important'); // Temporarily remove for animation
      
      // Set initial state: positioned at button center, starting from 0x0 dimensions
      modal.style.setProperty('opacity', '1', 'important');
      modal.style.setProperty('transform', 'none', 'important');
      modal.style.setProperty('top', `${initialTop}px`, 'important');
      modal.style.setProperty('left', `${initialLeft}px`, 'important');
      modal.style.setProperty('width', '0px', 'important');
      modal.style.setProperty('height', '0px', 'important');
      modal.style.setProperty('overflow', 'hidden', 'important');
      
      // Force a reflow to ensure 0x0 dimensions are applied
      void modal.offsetHeight;
      
      // Set transition AFTER initial state is set
      // Reduced animation time from 0.3s to 0.2s for faster animation
      modal.style.setProperty('transition', 'top 0.2s ease-out, left 0.2s ease-out, width 0.2s ease-out, height 0.2s ease-out', 'important');
      
      // Add purple outline to Ask AI button when modal is opened
      if (searchButton) {
        searchButton.style.setProperty('outline', '3px solid #9527F5', 'important');
        searchButton.style.setProperty('outline-offset', '4px', 'important');
        searchButton.style.setProperty('border-radius', '10px', 'important');
      }
      
      // Force a reflow to ensure initial position is set
      void modal.offsetHeight;
      
      // Animate to final position and dimensions
      // The modal expands from button center (0x0) to final position and size
      modal.style.setProperty('top', `${finalTop}px`, 'important');
      modal.style.setProperty('left', `${finalLeft}px`, 'important');
      modal.style.setProperty('width', `${modalWidth}px`, 'important');
      modal.style.setProperty('height', `${modalHeight}px`, 'important');
      
      // Set up repositionModal for future updates (after initial animation)
      // Don't call it immediately as it would override our animation
      // Add a flag to prevent immediate repositioning that could cause glitches
      modal.setAttribute('data-animation-complete', 'false');
      setTimeout(() => {
        if (modal) {
          // Mark animation as complete
          modal.setAttribute('data-animation-complete', 'true');
          // Lock the final position to prevent glitches
          // The position is already set correctly from our calculation above
          // Only set up repositioning for future content changes, not immediately
          // Use a small delay to ensure animation has fully settled
          setTimeout(() => {
            if (modal) {
              repositionModal();
            }
          }, 50); // Small delay to ensure animation is fully complete
        }
      }, 200); // Updated to match new animation duration
      
      // After animation completes, remove transition, restore overflow, and focus input
      setTimeout(() => {
        if (!modal) {
          return;
        }
        
        // Remove transition after animation completes
        modal.style.setProperty('transition', '', 'important');
        modal.style.setProperty('overflow', '', 'important');
        // Restore max-width and max-height to their CSS values
        modal.style.removeProperty('max-width'); // Remove inline override, let CSS take over
        modal.style.removeProperty('max-height'); // Remove inline override, let CSS take over
        modal.style.removeProperty('width'); // Remove explicit width, let CSS (90vw with max-width: 600px) take over
        modal.style.removeProperty('height'); // Remove explicit height
        modal.classList.add('visible');
        
        // Focus input after animation
        inputField.focus();
      }, 200); // 0.2s animation duration
    } catch (error) {
      console.error('[WordSelector] ✗ Error during Ask AI modal positioning:', error);
    }
  },
  
  /**
   * Close all open Ask AI modals
   * Called when word popup is closed to ensure Ask AI modals are also closed
   * @param {string} normalizedWord - Optional normalized word to match modals
   * @param {HTMLElement} wordElement - Optional word element for animation target (center of word)
   */
  closeAllAskAIModals(normalizedWord = null, wordElement = null) {
    const askAIModals = document.querySelectorAll('.word-web-search-modal');
    if (askAIModals.length === 0) {
      return; // No modals to close
    }
    
    console.log('[WordSelector] Closing all Ask AI modals (', askAIModals.length, 'found)');
    
    askAIModals.forEach(modal => {
      // Save chat history before closing
      const modalWord = modal.getAttribute('data-word');
      const modalNormalizedWord = modalWord ? modalWord.toLowerCase() : '';
      const chatHistoryJson = modal.getAttribute('data-chat-history') || '[]';
      const initialContext = modal.getAttribute('data-initial-context') || '';
      try {
        const chatHistory = JSON.parse(chatHistoryJson);
        if (modalNormalizedWord && this.explainedWords.has(modalNormalizedWord)) {
          const wordData = this.explainedWords.get(modalNormalizedWord);
          wordData.askAIChatHistory = chatHistory;
          wordData.askAIInitialContext = initialContext;
          console.log('[WordSelector] Saved chat history before closing Ask AI modal');
        }
      } catch (e) {
        console.error('[WordSelector] Error saving chat history:', e);
      }
      
      // Find the associated Ask AI button for this modal
      const wordPopup = document.querySelector(`.vocab-word-popup[data-word="${modalWord}"]`);
      if (wordPopup) {
        const askButton = wordPopup.querySelector('.vocab-word-popup-ask-button');
        if (askButton) {
          console.log('[WordSelector] Closing Ask AI modal with animation');
          // Use wordElement if provided and matches this modal's word, otherwise use null (animates to button center)
          const targetWordElement = (wordElement && normalizedWord && modalNormalizedWord === normalizedWord) ? wordElement : null;
          this.closeAskAIModalWithAnimation(modal, askButton, targetWordElement);
        } else {
          // Fallback: remove modal directly if button not found
          console.log('[WordSelector] Ask AI button not found, removing modal directly');
          modal.remove();
        }
      } else {
        // Fallback: remove modal directly if popup not found
        console.log('[WordSelector] Word popup not found, removing Ask AI modal directly');
        modal.remove();
      }
    });
  },
  
  /**
   * Animate Ask AI modal closing - simple smooth fade + scale animation (same as opening)
   * @param {HTMLElement} modal - The modal element
   * @param {HTMLElement} askButton - The Ask AI button element
   * @param {HTMLElement} wordElement - Optional word element. If provided, animate to word center instead of button center
   */
  closeAskAIModalWithAnimation(modal, askButton, wordElement = null) {
    console.log('[WordSelector] ===== ASK AI MODAL CLOSING ANIMATION - START =====');
    
    // Remove purple outline from Ask AI button when modal is closed
    if (askButton) {
      askButton.style.removeProperty('outline');
      askButton.style.removeProperty('outline-offset');
      askButton.style.removeProperty('border-radius');
    }
    
    // Check if already closing to prevent double-close
    if (modal.classList.contains('ask-ai-closing')) {
      console.log('[WordSelector] Modal is already closing, ignoring close request');
      return;
    }
    
    // Clean up any previous animation state
    modal.classList.remove('ask-ai-opening');
    
    // Force a reflow to ensure modal state is current
    void modal.offsetHeight;
    
    // Get current modal position and dimensions
    // Force a reflow to ensure we get accurate dimensions from the rendered state
    void modal.offsetHeight;
    
    // Get the actual rendered dimensions and position
    const currentModalRect = modal.getBoundingClientRect();
    
    // Get scroll offsets for converting viewport coordinates to document coordinates
    const scrollX = window.scrollX || window.pageXOffset || 0;
    const scrollY = window.scrollY || window.pageYOffset || 0;
    
    // Always use getBoundingClientRect() for dimensions - this gives us the actual rendered size
    // This is reliable even if width/height were removed after opening animation
    const currentWidth = currentModalRect.width;
    const currentHeight = currentModalRect.height;
    
    // Get position - prefer style values if explicitly set, otherwise use getBoundingClientRect
    // This handles cases where modal might have been repositioned
    let currentTop = parseFloat(modal.style.top);
    let currentLeft = parseFloat(modal.style.left);
    
    // If position not in style, calculate from getBoundingClientRect (viewport) + scroll offset
    if (isNaN(currentTop)) {
      currentTop = currentModalRect.top + scrollY;
    }
    if (isNaN(currentLeft)) {
      currentLeft = currentModalRect.left + scrollX;
    }
    
    console.log('[WordSelector] Closing animation - Modal dimensions (from rendered state):', {
      rectWidth: currentWidth,
      rectHeight: currentHeight,
      rectTop: currentModalRect.top,
      rectLeft: currentModalRect.left,
      styleTop: modal.style.top,
      styleLeft: modal.style.left,
      finalTop: currentTop,
      finalLeft: currentLeft,
      scrollX,
      scrollY
    });
    
    // Determine final destination: word center if wordElement provided, otherwise button center
    let finalLeft, finalTop;
    
    if (wordElement && document.body.contains(wordElement)) {
      // Animate to word center (same as word-meaning modal)
      const wordRect = wordElement.getBoundingClientRect();
      const wordCenterX = wordRect.left + wordRect.width / 2;
      const wordCenterY = wordRect.top + wordRect.height / 2;
      
      // Convert word center to document coordinates (for absolute positioning)
      finalLeft = wordCenterX + scrollX;
      finalTop = wordCenterY + scrollY;
      
      console.log('[WordSelector] Closing animation - Word center calculation:', {
        wordLeft: wordRect.left,
        wordRight: wordRect.right,
        wordTop: wordRect.top,
        wordBottom: wordRect.bottom,
        wordCenterX,
        wordCenterY,
        scrollX,
        scrollY,
        finalLeft,
        finalTop
      });
    } else {
      // Default: animate to button center
      // Get current button position (viewport coordinates) - get fresh position
      const buttonRect = askButton.getBoundingClientRect();
      const buttonLeft = buttonRect.left;
      const buttonRight = buttonRect.right;
      const buttonTop = buttonRect.top;
      const buttonBottom = buttonRect.bottom;
      
      // Calculate button center correctly (same calculation as opening animation)
      // Center X = left + (right - left) / 2 = left + width/2
      const buttonCenterX = buttonLeft + (buttonRight - buttonLeft) / 2;
      // Center Y = top + (bottom - top) / 2 = top + height/2
      const buttonCenterY = buttonTop + (buttonBottom - buttonTop) / 2;
      
      // Convert button center to document coordinates (for absolute positioning)
      // scrollX and scrollY are already defined above
      finalLeft = buttonCenterX + scrollX;
      finalTop = buttonCenterY + scrollY;
      
      console.log('[WordSelector] Closing animation - Button center calculation:', {
        buttonLeft,
        buttonRight,
        buttonTop,
        buttonBottom,
        buttonCenterX,
        buttonCenterY,
        scrollX,
        scrollY,
        finalLeft,
        finalTop
      });
    }
    
    // Set initial state for closing animation (current position and size)
    // CRITICAL: Set explicit width/height FIRST before removing min-width/min-height
    // This prevents the modal from expanding when constraints are removed
    modal.style.setProperty('opacity', '1', 'important');
    modal.style.setProperty('transform', 'none', 'important');
    modal.style.setProperty('top', `${currentTop}px`, 'important');
    modal.style.setProperty('left', `${currentLeft}px`, 'important');
    modal.style.setProperty('width', `${currentWidth}px`, 'important');
    modal.style.setProperty('height', `${currentHeight}px`, 'important');
    modal.style.setProperty('overflow', 'hidden', 'important');
    
    // Force a reflow to ensure width/height are applied before removing constraints
    void modal.offsetHeight;
    
    // NOW remove min-width/min-height constraints (after explicit dimensions are set)
    // This allows shrinking to 0px without causing expansion
    modal.style.setProperty('min-width', '0px', 'important');
    modal.style.setProperty('min-height', '0px', 'important');
    modal.style.setProperty('max-width', 'none', 'important');
    modal.style.setProperty('max-height', 'none', 'important');
    
    // Set transition AFTER all initial styles are set
    // Make width/height animation complete at the same time as position reaches center
    // Using same duration ensures dimensions are 0x0 when position reaches button center
    // Reduced animation time from 0.3s to 0.2s for faster animation
    modal.style.setProperty('transition', 'top 0.2s ease-out, left 0.2s ease-out, width 0.2s ease-out, height 0.2s ease-out', 'important');
    
    // Add closing class
    modal.classList.add('ask-ai-closing');
    modal.classList.remove('visible');
    
    // Force a reflow to ensure animation starts
    void modal.offsetHeight;
    
    // Animate to button center with 0x0 dimensions
    // All animations complete together - dimensions reach 0x0 exactly when position reaches button center
    modal.style.setProperty('top', `${finalTop}px`, 'important');
    modal.style.setProperty('left', `${finalLeft}px`, 'important');
    modal.style.setProperty('width', '0px', 'important');
    modal.style.setProperty('height', '0px', 'important');
    
    // Wait for animation to complete, then remove modal
    setTimeout(() => {
      if (!modal) {
        return;
      }
      
      // Clean up animation class
      modal.classList.remove('ask-ai-closing');
      
      // Cleanup positioning observers
      if (modal._cleanupPositioning) {
        modal._cleanupPositioning();
      }
      
      // Remove modal
      modal.remove();
      console.log('[WordSelector] ✓✓✓ ASK AI MODAL CLOSING ANIMATION COMPLETED ✓✓✓');
    }, 200); // 0.2s animation duration
  },
  
  /**
   * Perform web search and display results
   * @param {HTMLElement} modal - The modal element
   * @param {string} word - The word to search for
   * @param {string} meaning - The word meaning
   * @param {Array<string>} examples - Example sentences
   */
  async performWebSearch(modal, word, meaning, examples) {
    console.log('[WordSelector] Performing web search for:', word);
    
    const loadingIndicator = modal.querySelector('.word-web-search-loading');
    const metadataDiv = modal.querySelector('.word-web-search-metadata');
    const resultsList = modal.querySelector('.word-web-search-results-list');
    
    // Clear previous results
    resultsList.innerHTML = '';
    metadataDiv.style.display = 'none';
    metadataDiv.innerHTML = '';
    
    let searchContext = ''; // Will accumulate search results for initial_context
    
    const abortSearch = await ApiService.search({
      query: word,
      max_results: 10,
      region: 'wt-wt',
      onMetadata: (metadata) => {
        console.log('[WordSelector] Search metadata received:', metadata);
        
        // Display metadata
        const searchInfo = metadata.searchInformation || {};
        const totalResults = searchInfo.formattedTotalResults || searchInfo.totalResults || '0';
        const searchTime = searchInfo.formattedSearchTime || searchInfo.searchTime || '0';
        
        metadataDiv.innerHTML = `
          <div class="word-web-search-metadata-text">
            About ${totalResults} results (${searchTime} seconds)
          </div>
        `;
        metadataDiv.style.display = 'block';
        
        // Update explain button visibility when metadata is shown
        if (modal._updateExplainButtonVisibility) {
          modal._updateExplainButtonVisibility();
        }
      },
      onResult: (result) => {
        console.log('[WordSelector] Search result received:', result);
        
        // Hide loading indicator after first result
        if (loadingIndicator && loadingIndicator.parentNode) {
          loadingIndicator.style.display = 'none';
        }
        
        // Build search context from results
        if (searchContext) {
          searchContext += '\n\n';
        }
        searchContext += `Title: ${result.title}\n`;
        searchContext += `Link: ${result.link}\n`;
        searchContext += `Snippet: ${result.snippet || ''}\n`;
        
        // Create result item
        const resultItem = document.createElement('div');
        resultItem.className = 'word-web-search-result-item';
        
        // Create result content
        const resultContent = document.createElement('div');
        resultContent.className = 'word-web-search-result-content';
        
        // Title with link
        const titleLink = document.createElement('a');
        titleLink.href = result.link;
        titleLink.target = '_blank';
        titleLink.rel = 'noopener noreferrer';
        titleLink.className = 'word-web-search-result-title';
        titleLink.textContent = result.title;
        
        // Display link
        const displayLink = document.createElement('div');
        displayLink.className = 'word-web-search-result-link';
        displayLink.textContent = result.displayLink || new URL(result.link).hostname;
        
        // Snippet
        const snippet = document.createElement('div');
        snippet.className = 'word-web-search-result-snippet';
        snippet.textContent = result.snippet || '';
        
        // Image (if available)
        if (result.image && result.image.url) {
          const imageContainer = document.createElement('div');
          imageContainer.className = 'word-web-search-result-image-container';
          const image = document.createElement('img');
          image.src = result.image.url;
          image.alt = result.title;
          image.className = 'word-web-search-result-image';
          imageContainer.appendChild(image);
          resultContent.appendChild(imageContainer);
        }
        
        resultContent.appendChild(titleLink);
        resultContent.appendChild(displayLink);
        resultContent.appendChild(snippet);
        resultItem.appendChild(resultContent);
        
        // Add fade-in animation
        resultItem.style.opacity = '0';
        resultsList.appendChild(resultItem);
        
        // Animate in
        setTimeout(() => {
          resultItem.style.transition = 'opacity 0.3s ease';
          resultItem.style.opacity = '1';
          
          // Update explain button visibility when results are added
          if (modal._updateExplainButtonVisibility) {
            modal._updateExplainButtonVisibility();
          }
        }, 10);
      },
      onComplete: () => {
        console.log('[WordSelector] Web search completed');
        
        // Hide loading indicator
        if (loadingIndicator && loadingIndicator.parentNode) {
          loadingIndicator.style.display = 'none';
        }
        
        // Update explain button visibility after search completes
        if (modal._updateExplainButtonVisibility) {
          modal._updateExplainButtonVisibility();
        }
        
        // Store search context for chat (ensure it's never empty)
        const word = modal.getAttribute('data-word') || '';
        const finalContext = (searchContext && searchContext.trim() !== '') 
          ? searchContext 
          : `Word: ${word}`;
        modal.setAttribute('data-initial-context', finalContext);
        
        // If no results, show message
        if (resultsList.children.length === 0) {
          const noResults = document.createElement('div');
          noResults.className = 'word-web-search-no-results';
          noResults.textContent = 'No results found';
          resultsList.appendChild(noResults);
        }
      },
      onError: (error) => {
        console.error('[WordSelector] Web search error:', error);
        
        // Hide loading indicator
        if (loadingIndicator && loadingIndicator.parentNode) {
          loadingIndicator.style.display = 'none';
        }
        
        // Show error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'word-web-search-error';
        errorDiv.textContent = `Error: ${error.message}`;
        resultsList.appendChild(errorDiv);
      }
    });
    
    // Store abort function
    modal.setAttribute('data-search-abort', abortSearch.toString());
  },
  
  /**
   * Send chat message in web search modal
   * @param {HTMLElement} modal - The modal element
   * @param {string} word - The word
   * @param {HTMLElement} inputField - The input field element
   */
  async sendWebSearchChatMessage(modal, word, inputField) {
    // Store reference to WordSelector for use in nested functions
    const wordSelector = this;
    const question = inputField.value.trim();
    if (!question) return;
    
    console.log('[WordSelector] Sending chat message:', question);
    
    // Clear input
    inputField.value = '';
    inputField.style.height = 'auto';
    
    // Get chat history
    const chatHistoryJson = modal.getAttribute('data-chat-history') || '[]';
    let chatHistory = [];
    try {
      chatHistory = JSON.parse(chatHistoryJson);
    } catch (e) {
      console.error('[WordSelector] Error parsing chat history:', e);
      chatHistory = [];
    }
    
    // Get initial context from search results
    let initialContext = modal.getAttribute('data-initial-context') || '';
    
    // Ensure initialContext is never empty (API requires non-empty string)
    // If no search results yet, use the word as minimal context
    if (!initialContext || initialContext.trim() === '') {
      initialContext = `Word: ${word}`;
      console.log('[WordSelector] No search context available, using word as fallback context');
    }
    
    // Add prefix to user question (as per API contract requirement)
    const prefixedQuestion = `Here the word of interest is '${word}'. Based on the context given can you answer my question. Here is my question :- ${question}`;
    
    // Display user message (show original question without prefix for UI)
    const resultsList = modal.querySelector('.word-web-search-results-list');
    
    // Show results container when first message is added
    const resultsContainer = modal.querySelector('.word-web-search-results');
    if (resultsContainer) {
      resultsContainer.style.display = '';
    }
    
    const userMessageDiv = document.createElement('div');
    userMessageDiv.className = 'word-web-search-chat-message user-message';
    userMessageDiv.textContent = question;
    resultsList.appendChild(userMessageDiv);
    
    // Hide explain button after first message
    const explainBtn = modal.querySelector('.word-web-search-explain-btn');
    if (explainBtn) {
      explainBtn.style.setProperty('display', 'none', 'important');
    }
    
    // Update results visibility
    if (modal._updateResultsVisibility) {
      modal._updateResultsVisibility();
    }
    
    // Create AI response container
    const aiMessageDiv = document.createElement('div');
    aiMessageDiv.className = 'word-web-search-chat-message ai-message';
    const aiResponseText = document.createElement('div');
    aiResponseText.className = 'word-web-search-chat-response-text';
    aiMessageDiv.appendChild(aiResponseText);
    resultsList.appendChild(aiMessageDiv);
    
    // Scroll to bottom when user message is added
    this.scrollToBottom(resultsList, false, false);
    
    // Keep input enabled (always enabled)
    // inputField.disabled = true; // REMOVED - input should always be enabled
    const sendBtn = modal.querySelector('.word-web-search-send-btn');
    // Change icon to stop icon and update aria-label
    sendBtn.innerHTML = this.createStopIcon();
    sendBtn.setAttribute('aria-label', 'Stop request');
    
    // Show delete button if not already shown
    const deleteBtn = modal.querySelector('.word-web-search-delete-btn');
    if (deleteBtn) {
      deleteBtn.style.display = 'flex';
    }
    
    // Call v2/ask API
    // Note: chat_history should contain previous messages only (not current question)
    // The current question goes in the 'question' field
    let accumulatedText = '';
    const abortAsk = await ApiService.ask({
      initial_context: initialContext,
      chat_history: chatHistory, // Previous messages only
      question: prefixedQuestion, // Current question with prefix
      context_type: 'TEXT',
      onChunk: (chunk, accumulated) => {
        accumulatedText = accumulated || accumulatedText + chunk;
        aiResponseText.innerHTML = this.renderMarkdown(accumulatedText);
        
        // Auto-scroll during streaming (only if user is at bottom)
        this.scrollToBottom(resultsList, true, true);
      },
      onComplete: (updatedChatHistory, possibleQuestions) => {
        console.log('[WordSelector] Chat response completed');
        
        // Update chat history
        // The API returns the complete chat history including the current question and response
        let finalChatHistory = chatHistory;
        if (updatedChatHistory && Array.isArray(updatedChatHistory)) {
          finalChatHistory = updatedChatHistory;
          modal.setAttribute('data-chat-history', JSON.stringify(updatedChatHistory));
        } else {
          // Fallback: manually add user question and AI response to chat history
          chatHistory.push({
            role: 'user',
            content: prefixedQuestion
          });
          chatHistory.push({
            role: 'assistant',
            content: accumulatedText
          });
          finalChatHistory = chatHistory;
          modal.setAttribute('data-chat-history', JSON.stringify(chatHistory));
        }
        
        // IMPORTANT: Also save to explainedWords map for persistence
        const normalizedWord = word.toLowerCase();
        if (wordSelector.explainedWords.has(normalizedWord)) {
          const wordData = wordSelector.explainedWords.get(normalizedWord);
          wordData.askAIChatHistory = finalChatHistory;
          // Also ensure initial context is saved
          if (!wordData.askAIInitialContext) {
            wordData.askAIInitialContext = initialContext;
          }
          console.log('[WordSelector] Saved chat history to explainedWords map after message');
        }
        
        // Scroll to bottom when response is complete (always scroll to show full response)
        this.scrollToBottom(resultsList, false, false);
        
        // Input is always enabled, just restore send button icon
        // inputField.disabled = false; // REMOVED - input is always enabled
        // Clear abort function
        modal._currentAbortFn = null;
        // Restore send button icon
        sendBtn.innerHTML = this.createSendIcon();
        sendBtn.setAttribute('aria-label', 'Send message');
        sendBtn.disabled = false;
        
        // Update results visibility after AI response completes
        if (modal._updateResultsVisibility) {
          modal._updateResultsVisibility();
        }
        
        inputField.focus();
      },
      onError: (error) => {
        console.error('[WordSelector] Chat error:', error);
        aiResponseText.textContent = `Error: ${error.message}`;
        
        // Input is always enabled, just restore send button icon
        // inputField.disabled = false; // REMOVED - input is always enabled
        // Clear abort function
        modal._currentAbortFn = null;
        // Restore send button icon
        sendBtn.innerHTML = this.createSendIcon();
        sendBtn.setAttribute('aria-label', 'Send message');
        sendBtn.disabled = false;
        inputField.focus();
      }
    });
    
    // Store abort function on modal object (not as string attribute)
    modal._currentAbortFn = abortAsk;
  },
  
  /**
   * Check if user is at or near the bottom of the scrollable content
   * @param {HTMLElement} scrollableContent - The scrollable content container
   * @param {number} tolerance - Pixel tolerance for "near bottom" (default: 50px)
   * @returns {boolean} True if user is at or near the bottom
   */
  isAtBottom(scrollableContent, tolerance = 50) {
    if (!scrollableContent) return false;
    
    const currentScroll = scrollableContent.scrollTop;
    const maxScroll = scrollableContent.scrollHeight - scrollableContent.clientHeight;
    const distanceFromBottom = maxScroll - currentScroll;
    
    // User is at bottom if they're within tolerance pixels of the bottom
    return distanceFromBottom <= tolerance;
  },
  
  /**
   * Scroll the scrollable content container to bottom
   * @param {HTMLElement} element - The element (usually resultsList) to find scrollable container from
   * @param {boolean} immediate - If true, use immediate scroll (no smooth animation). Default: false
   * @param {boolean} onlyIfAtBottom - If true, only scroll if user is already at bottom. Default: false
   */
  scrollToBottom(element, immediate = false, onlyIfAtBottom = false) {
    if (!element) return;
    
    // Find the actual scrollable container (word-web-search-results)
    // This is the parent container that has overflow-y: auto
    let scrollableContent = element.closest('.word-web-search-results');
    
    // If not found via closest, try finding it from the parent
    if (!scrollableContent) {
      let parent = element.parentElement;
      while (parent && !scrollableContent) {
        if (parent.classList && parent.classList.contains('word-web-search-results')) {
          scrollableContent = parent;
          break;
        }
        parent = parent.parentElement;
      }
    }
    
    // Fallback: if still not found, use the element itself (for backward compatibility)
    if (!scrollableContent) {
      scrollableContent = element;
      console.warn('[WordSelector] scrollToBottom: Could not find scrollable container, using element directly');
    }
    
    // If onlyIfAtBottom is true, check if user is at bottom before scrolling
    if (onlyIfAtBottom && !this.isAtBottom(scrollableContent)) {
      console.log('[WordSelector] scrollToBottom: User has scrolled up, skipping auto-scroll');
      return;
    }
    
    console.log('[WordSelector] scrollToBottom: Scrolling to bottom, immediate:', immediate);
    
    // Function to perform the actual scroll
    const performScroll = () => {
      if (immediate) {
        // For immediate scroll (during streaming), use instant scroll
        scrollableContent.scrollTop = scrollableContent.scrollHeight;
      } else {
        // For normal scroll, use smooth behavior
        scrollableContent.scrollTo({
          top: scrollableContent.scrollHeight,
          behavior: 'smooth'
        });
      }
    };
    
    // Use requestAnimationFrame to ensure DOM updates are complete
    requestAnimationFrame(() => {
      performScroll();
      
      // Multiple scroll attempts to handle async DOM updates and layout recalculation
      // This is especially important during streaming when content is added word by word
      setTimeout(() => {
        performScroll();
      }, 0);
      
      setTimeout(() => {
        performScroll();
      }, 10);
      
      // Final check with a small delay to ensure we're at the bottom
      setTimeout(() => {
        const currentScroll = scrollableContent.scrollTop;
        const maxScroll = scrollableContent.scrollHeight - scrollableContent.clientHeight;
        // If we're not at the bottom (within 10px tolerance), scroll again
        if (Math.abs(currentScroll - maxScroll) > 10) {
          scrollableContent.scrollTop = scrollableContent.scrollHeight;
        }
      }, 50);
    });
  },
  
  /**
   * Simple markdown renderer for chat messages
   * @param {string} text - Markdown text
   * @returns {string} HTML string
   */
  renderMarkdown(text) {
    if (!text) return '';
    
    let html = text;
    
    // Escape HTML first
    html = html.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;');
    
    // Code blocks (```)
    html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
    
    // Inline code (`)
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Bold (**text** or __text__)
    html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    
    // Italic (*text* or _text_)
    html = html.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
    html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
    
    // Links [text](url)
    html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    
    // Headings
    html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
    
    // Line breaks
    html = html.replace(/\n\n/g, '<br><br>');
    html = html.replace(/\n/g, '<br>');
    
    // Lists
    html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
    html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
    html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
    
    // Wrap consecutive <li> in <ul>
    html = html.replace(/(<li>.*?<\/li>)/gs, '<ul>$1</ul>');
    
    return html;
  },
  
  /**
   * Clear chat history in web search modal
   * @param {HTMLElement} modal - The modal element
   */
  clearWebSearchChatHistory(modal) {
    console.log('[WordSelector] Clearing web search chat history');
    
    // Get word from modal to clear from persisted storage
    const word = modal.getAttribute('data-word') || '';
    const normalizedWord = word.toLowerCase();
    
    // Reset chat history in modal
    modal.setAttribute('data-chat-history', JSON.stringify([]));
    
    // Also clear from persisted storage (explainedWords map)
    if (this.explainedWords.has(normalizedWord)) {
      const wordData = this.explainedWords.get(normalizedWord);
      wordData.askAIChatHistory = [];
      console.log('[WordSelector] Cleared chat history from persisted storage for word:', word);
    }
    
    // Remove chat messages from results list
    const resultsList = modal.querySelector('.word-web-search-results-list');
    const chatMessages = resultsList.querySelectorAll('.word-web-search-chat-message');
    chatMessages.forEach(msg => msg.remove());
    
    // Hide delete button
    const deleteBtn = modal.querySelector('.word-web-search-delete-btn');
    if (deleteBtn) {
      deleteBtn.style.display = 'none';
    }
    
    // Update explain button visibility after clearing chat
    if (modal._updateExplainButtonVisibility) {
      modal._updateExplainButtonVisibility();
    }
    
    // Update results visibility
    if (modal._updateResultsVisibility) {
      modal._updateResultsVisibility();
    }
  },
  
  /**
   * Create send icon (upward arrow)
   */
  createSendIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 15V5M10 5L5 10M10 5L15 10" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Create stop icon (square purple)
   */
  createStopIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block !important; visibility: visible !important;">
        <rect x="4" y="4" width="12" height="12" fill="#9527F5" stroke="none" style="display: block !important; visibility: visible !important;"/>
      </svg>
    `;
  },
  
  /**
   * Create trash icon
   */
  createTrashIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 5h14M6.5 5V3.5a1.5 1.5 0 0 1 1.5-1.5h4a1.5 1.5 0 0 1 1.5 1.5V5M15 5v10.5a1.5 1.5 0 0 1-1.5 1.5h-7a1.5 1.5 0 0 1-1.5-1.5V5h10Z" stroke="#ef4444" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M8 9v5M12 9v5" stroke="#ef4444" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Position popup relative to word highlight
   * @param {HTMLElement} popup - The popup element
   * @param {HTMLElement} wordElement - The word highlight element
   */
  positionPopup(popup, wordElement) {
    console.log('[WordSelector] ===== POSITIONING POPUP =====');
    
    // Validate inputs
    if (!popup || !wordElement) {
      console.error('[WordSelector] ✗ Invalid inputs for positionPopup:', { popup, wordElement });
      return;
    }
    
    if (!document.body.contains(wordElement)) {
      console.error('[WordSelector] ✗ wordElement is not in DOM');
      return;
    }
    
    if (!document.body.contains(popup)) {
      console.error('[WordSelector] ✗ popup is not in DOM');
      return;
    }
    
    const rect = wordElement.getBoundingClientRect();
    console.log('[WordSelector] Word element bounding rect:', {
      top: rect.top,
      left: rect.left,
      bottom: rect.bottom,
      right: rect.right,
      width: rect.width,
      height: rect.height,
      scrollY: window.scrollY,
      scrollX: window.scrollX
    });
    
    // Check if element is visible
    if (rect.width === 0 || rect.height === 0) {
      console.warn('[WordSelector] ⚠ Word element has zero dimensions, may not be visible');
    }
    
    const popupHeight = popup.offsetHeight || 250; // Estimated height
    const popupWidth = popup.offsetWidth || 340;
    
    console.log('[WordSelector] Popup dimensions:', {
      width: popupWidth,
      height: popupHeight,
      offsetWidth: popup.offsetWidth,
      offsetHeight: popup.offsetHeight
    });
    
    // Calculate position (bottom-right of word, not overlapping)
    let top = rect.bottom + window.scrollY + 8; // 8px gap below word
    let left = rect.right + window.scrollX - popupWidth / 2; // Center horizontally with word
    
    console.log('[WordSelector] Initial calculated position:', { top, left });
    
    // Adjust if popup goes off-screen
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    console.log('[WordSelector] Viewport dimensions:', {
      width: viewportWidth,
      height: viewportHeight
    });
    
    // Horizontal adjustment
    if (left + popupWidth > viewportWidth + window.scrollX) {
      const oldLeft = left;
      left = viewportWidth + window.scrollX - popupWidth - 10;
      console.log('[WordSelector] Adjusted left (right edge):', { oldLeft, newLeft: left });
    }
    if (left < window.scrollX + 10) {
      const oldLeft = left;
      left = window.scrollX + 10;
      console.log('[WordSelector] Adjusted left (left edge):', { oldLeft, newLeft: left });
    }
    
    // Vertical adjustment (if not enough space below, show above)
    if (rect.bottom + popupHeight > viewportHeight + window.scrollY) {
      const oldTop = top;
      top = rect.top + window.scrollY - popupHeight - 8; // Show above
      console.log('[WordSelector] Adjusted top (showing above):', { oldTop, newTop: top });
    }
    
    popup.style.top = `${top}px`;
    popup.style.left = `${left}px`;
    
    console.log('[WordSelector] ✓ Final popup position set:', {
      top: `${top}px`,
      left: `${left}px`,
      styleTop: popup.style.top,
      styleLeft: popup.style.left
    });
  },
  
  /**
   * Show popup for word (hover or click)
   * @param {HTMLElement} wordElement - The word highlight element
   * @param {boolean} sticky - Whether popup should stay (click) or disappear on mouseleave (hover)
   */
  async showWordPopup(wordElement, sticky = false) {
    console.log('[WordSelector] ===== SHOW WORD POPUP CALLED =====');
    console.log('[WordSelector] Parameters:', {
      wordElement: wordElement,
      sticky: sticky,
      isInDOM: wordElement ? document.body.contains(wordElement) : false,
      elementClasses: wordElement ? wordElement.className : 'N/A',
      elementText: wordElement ? wordElement.textContent.trim() : 'N/A'
    });
    
    // Validate wordElement
    if (!wordElement) {
      console.error('[WordSelector] ✗ showWordPopup called with null/undefined wordElement');
      return;
    }
    
    if (!document.body.contains(wordElement)) {
      console.error('[WordSelector] ✗ wordElement is not in DOM');
      console.error('[WordSelector] Element:', wordElement);
      return;
    }
    
    // Remove any existing popups
    this.hideAllPopups();
    
    const word = wordElement.textContent.trim();
    const normalizedWord = word.toLowerCase();
    
    console.log('[WordSelector] Extracted word data:', {
      word: word,
      normalizedWord: normalizedWord,
      elementHasExplainedClass: wordElement.classList.contains('vocab-word-explained')
    });
    
    // Get word data from explainedWords map (this contains the most up-to-date data)
    let wordData = null;
    let meaning = '';
    let examples = [];
    let shouldAllowFetchMoreExamples = true; // Default to true
    let languageCode = null;
    
    if (this.explainedWords.has(normalizedWord)) {
      wordData = this.explainedWords.get(normalizedWord);
      meaning = wordData.meaning;
      examples = wordData.examples || [];
      languageCode = wordData.languageCode || null;
      
      // IMPORTANT: Always use original content from explainedWords, never use cached translations
      // The translation cache is only used when switching tabs, not for initial display
      
      // If get-more-explanations API has been called, use the field from response
      // Otherwise, show button by default
      if (wordData.hasCalledGetMoreExamples) {
        shouldAllowFetchMoreExamples = wordData.shouldAllowFetchMoreExamples || false;
      } else {
        shouldAllowFetchMoreExamples = true; // Show by default before first API call
      }
      
      console.log(`[WordSelector] ✓ Using updated data from explainedWords for "${word}":`, {
        meaning: meaning,
        examplesCount: examples.length,
        shouldAllowFetchMoreExamples: shouldAllowFetchMoreExamples,
        hasCalledGetMoreExamples: wordData.hasCalledGetMoreExamples,
        languageCode: languageCode
      });
    } else {
      // Fallback to DOM attributes if not found in explainedWords (shouldn't happen normally)
      console.warn(`[WordSelector] ⚠ Word "${word}" not found in explainedWords, using DOM attributes as fallback`);
      console.warn(`[WordSelector] Available words in explainedWords:`, Array.from(this.explainedWords.keys()));
      meaning = wordElement.getAttribute('data-meaning');
      const examplesJson = wordElement.getAttribute('data-examples');
      
      if (!meaning) {
        console.error('[WordSelector] ✗ No meaning found in DOM attributes either, cannot show popup');
        console.error('[WordSelector] Element attributes:', {
          dataWord: wordElement.getAttribute('data-word'),
          dataMeaning: wordElement.getAttribute('data-meaning'),
          dataExamples: wordElement.getAttribute('data-examples')
        });
        return;
      }
      
      try {
        examples = JSON.parse(examplesJson) || [];
      } catch (e) {
        console.error('[WordSelector] Error parsing examples:', e);
      }
    }
    
    if (!meaning) {
      console.error('[WordSelector] ✗ No meaning available, cannot show popup');
      return;
    }
    
    console.log('[WordSelector] ✓ Meaning found, proceeding to create popup');
    
    // Create popup
    console.log('[WordSelector] Creating popup element...');
    // Use languageCode from wordData (already extracted above)
    console.log('[WordSelector] Language code for popup:', languageCode);
    // IMPORTANT: Always pass original meaning and examples, never cached translations
    const popup = await this.createWordPopup(word, meaning, examples, shouldAllowFetchMoreExamples, languageCode);
    
    if (!popup) {
      console.error('[WordSelector] ✗ Failed to create popup element');
      return;
    }
    
    console.log('[WordSelector] ✓ Popup element created');
    
    // Mark as sticky or not
    if (sticky) {
      popup.classList.add('sticky');
      popup.setAttribute('data-sticky', 'true');
      console.log('[WordSelector] Popup marked as sticky');
    } else {
      popup.setAttribute('data-sticky', 'false');
      console.log('[WordSelector] Popup marked as non-sticky (hover mode)');
    }
    
    // Append to body
    console.log('[WordSelector] Appending popup to document.body...');
    try {
      document.body.appendChild(popup);
      console.log('[WordSelector] ✓ Popup appended to body');
    } catch (error) {
      console.error('[WordSelector] ✗ Failed to append popup to body:', error);
      return;
    }
    
    // Verify popup is in DOM
    if (!document.body.contains(popup)) {
      console.error('[WordSelector] ✗ Popup was not successfully added to DOM');
      return;
    }
    
    // Position it and animate from word element
    setTimeout(() => {
      console.log('[WordSelector] Positioning popup...');
      try {
        const wordRect = wordElement.getBoundingClientRect();
        console.log('[WordSelector] Word element position:', {
          top: wordRect.top,
          left: wordRect.left,
          bottom: wordRect.bottom,
          right: wordRect.right,
          width: wordRect.width,
          height: wordRect.height,
          isVisible: wordRect.width > 0 && wordRect.height > 0
        });
        
        // Calculate final position first
        this.positionPopup(popup, wordElement);
        
        // Get final position after positioning (in viewport coordinates)
        const popupRect = popup.getBoundingClientRect();
        const popupCenterX = popupRect.left + popupRect.width / 2;
        const popupCenterY = popupRect.top + popupRect.height / 2;
        
        // Calculate word element center (in viewport coordinates)
        const wordCenterX = wordRect.left + wordRect.width / 2;
        const wordCenterY = wordRect.top + wordRect.height / 2;
        
        // Calculate offset from popup's center to word center (in viewport coordinates)
        // Since transform translate() is relative to the element's position,
        // we need the offset from the popup's current center to the word center
        const startX = wordCenterX - popupCenterX;
        const startY = wordCenterY - popupCenterY;
        
        console.log('[WordSelector] Animation positions:', {
          wordRect: {
            left: wordRect.left,
            top: wordRect.top,
            width: wordRect.width,
            height: wordRect.height
          },
          wordCenter: {
            x: wordCenterX,
            y: wordCenterY
          },
          popupRect: {
            left: popupRect.left,
            top: popupRect.top,
            width: popupRect.width,
            height: popupRect.height
          },
          popupCenter: {
            x: popupCenterX,
            y: popupCenterY
          },
          startOffset: {
            x: startX,
            y: startY
          }
        });
        
        // Set CSS variables for animation
        popup.style.setProperty('--expand-start-transform', `translate(${startX}px, ${startY}px) scale(0)`);
        popup.style.setProperty('--expand-end-transform', `translate(0, 0) scale(1)`);
        
        // Force a reflow to ensure initial position is set
        popup.offsetHeight;
        
        // Add expanding class to trigger animation
        popup.classList.add('expanding');
        
        // Add visible class immediately (but animation will override transform)
        popup.classList.add('visible');
        
        // Ensure inline styles are set correctly for visibility
        popup.style.setProperty('opacity', '1', 'important');
        
        console.log('[WordSelector] ✓ Popup animation started');
        
        // Remove expanding class after animation completes and restore normal state
        setTimeout(() => {
          // Set final transform explicitly to ensure popup stays in position
          popup.style.setProperty('transform', 'translate(0, 0) scale(1)');
          // Remove expanding class after transform is set
          popup.classList.remove('expanding');
          // Restore transition for normal interactions
          popup.style.setProperty('transition', '');
          // Clean up CSS variables
          popup.style.removeProperty('--expand-start-transform');
          popup.style.removeProperty('--expand-end-transform');
          // Re-enable pointer events
          popup.style.setProperty('pointer-events', 'all', 'important');
          popup.style.setProperty('will-change', '');
          
          console.log('[WordSelector] ✓ Popup animation completed');
        }, 200); // Match animation duration (0.2s)
        
        // Verify popup is actually visible
        setTimeout(() => {
          const finalRect = popup.getBoundingClientRect();
          const finalStyle = window.getComputedStyle(popup);
          console.log('[WordSelector] Final popup state:', {
            isInDOM: document.body.contains(popup),
            hasVisibleClass: popup.classList.contains('visible'),
            display: finalStyle.display,
            visibility: finalStyle.visibility,
            opacity: finalStyle.opacity,
            zIndex: finalStyle.zIndex,
            position: finalStyle.position,
            top: finalStyle.top,
            left: finalStyle.left,
            width: finalRect.width,
            height: finalRect.height,
            isVisible: finalRect.width > 0 && finalRect.height > 0 && finalStyle.display !== 'none' && finalStyle.visibility !== 'hidden' && parseFloat(finalStyle.opacity) > 0
          });
          
          if (finalRect.width === 0 || finalRect.height === 0 || finalStyle.display === 'none' || finalStyle.visibility === 'hidden' || parseFloat(finalStyle.opacity) === 0) {
            console.error('[WordSelector] ✗ Popup is not visible! This might be due to website CSS interference.');
            console.error('[WordSelector] Check if website has CSS that hides elements or overrides z-index');
            console.error('[WordSelector] Attempting to force visibility with inline styles...');
            
            // Force visibility with inline styles
            popup.style.setProperty('display', 'block', 'important');
            popup.style.setProperty('visibility', 'visible', 'important');
            popup.style.setProperty('opacity', '1', 'important');
            popup.style.setProperty('z-index', '10000010', 'important');
            popup.style.setProperty('position', 'absolute', 'important');
          }
        }, 50);
      } catch (error) {
        console.error('[WordSelector] ✗ Error during popup positioning:', error);
      }
    }, 10);
    
    // Store reference
    wordElement.setAttribute('data-popup-id', 'active');
    
    // Set boolean flag to true (popup is now open)
    // normalizedWord is already declared above at line 2345
    this.wordPopupOpen.set(normalizedWord, true);
    
    console.log('[WordSelector] ✓ Popup reference stored on word element');
    console.log('[WordSelector] ✓ Popup open flag set to true for:', normalizedWord);
    
    // Add mouse event handlers to prevent popup from closing when moving cursor into it
    if (sticky) {
      popup.addEventListener('mouseenter', (e) => {
        e.stopPropagation();
        console.log('[WordSelector] Mouse entered sticky popup');
        // Mark popup as having mouse inside to prevent global click handler from closing it
        popup.setAttribute('data-mouse-inside', 'true');
      });
      
      popup.addEventListener('mouseleave', (e) => {
        e.stopPropagation();
        console.log('[WordSelector] Mouse left sticky popup');
        // Mark popup as not having mouse inside
        popup.setAttribute('data-mouse-inside', 'false');
        // For sticky popups, don't hide on mouseleave - only hide on outside click
      });
      
      popup.addEventListener('click', (e) => {
        e.stopPropagation();
        console.log('[WordSelector] Clicked inside sticky popup');
      });
      
      // Prevent any mouse events from bubbling up that might trigger hide
      popup.addEventListener('mousemove', (e) => {
        e.stopPropagation();
        // Ensure mouse inside flag is set when moving inside popup
        popup.setAttribute('data-mouse-inside', 'true');
      });
    }
    
    // If not sticky (hover mode), hide on mouseleave with delay
    if (!sticky) {
      let hideTimeout = null;
      
      const scheduleHide = () => {
        hideTimeout = setTimeout(() => {
          // Double-check it's still not sticky
          if (popup.getAttribute('data-sticky') !== 'true') {
            this.hideAllPopups();
          }
        }, 200); // 200ms delay to allow moving mouse to popup
      };
      
      const cancelHide = () => {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
      };
      
      // Hide when leaving word element
      wordElement.addEventListener('mouseleave', scheduleHide, { once: true });
      
      // Cancel hide when entering popup
      popup.addEventListener('mouseenter', () => {
        cancelHide();
      });
      
      // Schedule hide when leaving popup (only if not sticky)
      popup.addEventListener('mouseleave', () => {
        if (popup.getAttribute('data-sticky') !== 'true') {
          scheduleHide();
        }
      });
    }
    // If sticky, popup will only close on outside click (handled by global click listener)
  },
  
  /**
   * Hide all popups with animation (move to word position while scaling down)
   */
  hideAllPopups() {
    const popups = document.querySelectorAll('.vocab-word-popup');
    popups.forEach(popup => {
      // Find the associated word element
      const wordData = popup.getAttribute('data-word');
      let wordElement = null;
      
      if (wordData) {
        // Find word element with data-popup-id="active" and matching data-word
        // First try to find by data-popup-id="active"
        const activeWordElements = document.querySelectorAll('[data-popup-id="active"]');
        for (const element of activeWordElements) {
          const elementWord = element.getAttribute('data-word') || element.textContent.trim().toLowerCase();
          if (elementWord === wordData.toLowerCase()) {
            wordElement = element;
            break;
          }
        }
        
        // If not found, try to find any vocab-word-explained element with matching data-word
        if (!wordElement) {
          const allExplainedWords = document.querySelectorAll('.vocab-word-explained[data-word]');
          for (const element of allExplainedWords) {
            const elementWord = element.getAttribute('data-word');
            if (elementWord && elementWord.toLowerCase() === wordData.toLowerCase()) {
              wordElement = element;
              break;
            }
          }
        }
      }
      
      if (wordElement && document.body.contains(wordElement)) {
        // Animate popup closing: move to word position while scaling down
        this.animatePopupClose(popup, wordElement);
      } else {
        // Fallback: simple fade out if word element not found
        // Still need to clear the flag
        if (wordData) {
          const normalizedWord = wordData.toLowerCase();
          this.wordPopupOpen.set(normalizedWord, false);
          console.log('[WordSelector] ✓ Popup open flag set to false (fallback) for:', normalizedWord);
        }
        popup.classList.remove('visible');
        setTimeout(() => popup.remove(), 200);
      }
    });
    
    // Clear popup references after animation (already cleared in animatePopupClose, but keep this as fallback)
    setTimeout(() => {
      document.querySelectorAll('[data-popup-id="active"]').forEach(el => {
        el.removeAttribute('data-popup-id');
      });
      // Also remove any closing markers
      document.querySelectorAll('[data-closing="true"]').forEach(el => {
        el.removeAttribute('data-closing');
      });
    }, 200); // Match animation duration (0.2s)
  },
  
  /**
   * Animate popup closing: move to word position while scaling down
   * @param {HTMLElement} popup - The popup element
   * @param {HTMLElement} wordElement - The associated word element
   */
  animatePopupClose(popup, wordElement) {
    // Immediately remove the data-popup-id attribute to prevent reopening during animation
    wordElement.removeAttribute('data-popup-id');
    
    // Set boolean flag to false (popup is now closing/closed)
    const normalizedWord = wordElement.getAttribute('data-word') || wordElement.textContent.trim().toLowerCase();
    this.wordPopupOpen.set(normalizedWord, false);
    
    console.log('[WordSelector] ✓ Popup open flag set to false for:', normalizedWord);
    
    // Mark popup as closing to prevent reopening
    popup.setAttribute('data-closing', 'true');
    
    // Get current popup position
    const popupRect = popup.getBoundingClientRect();
    const popupCenterX = popupRect.left + popupRect.width / 2;
    const popupCenterY = popupRect.top + popupRect.height / 2;
    
    // Get word element position
    const wordRect = wordElement.getBoundingClientRect();
    const wordCenterX = wordRect.left + wordRect.width / 2;
    const wordCenterY = wordRect.top + wordRect.height / 2;
    
    // Calculate offset from popup center to word center
    const endX = wordCenterX - popupCenterX;
    const endY = wordCenterY - popupCenterY;
    
    console.log('[WordSelector] Closing animation positions:', {
      popupCenter: { x: popupCenterX, y: popupCenterY },
      wordCenter: { x: wordCenterX, y: wordCenterY },
      endOffset: { x: endX, y: endY }
    });
    
    // Set CSS variables for closing animation
    popup.style.setProperty('--close-start-transform', `translate(0, 0) scale(1)`);
    popup.style.setProperty('--close-end-transform', `translate(${endX}px, ${endY}px) scale(0)`);
    
    // Force a reflow
    popup.offsetHeight;
    
    // Add closing class to trigger animation
    popup.classList.add('closing');
    popup.classList.remove('visible');
    
    // Remove popup after animation completes
    setTimeout(() => {
      popup.remove();
      console.log('[WordSelector] ✓ Popup closing animation completed');
    }, 200); // Match animation duration (0.2s)
  },
  
  /**
   * Setup interaction handlers for explained words
   * This should be called after a word is explained
   * @param {HTMLElement} wordElement - The word highlight element
   */
  setupWordInteractions(wordElement) {
    console.log('[WordSelector] ===== SETUP WORD INTERACTIONS =====');
    console.log('[WordSelector] Setting up interactions for element:', {
      element: wordElement,
      isInDOM: document.body.contains(wordElement),
      classes: wordElement.className,
      hasExplainedClass: wordElement.classList.contains('vocab-word-explained'),
      textContent: wordElement.textContent.trim()
    });
    
    // Add mousedown handler to ensure click animation works
    wordElement.addEventListener('mousedown', (e) => {
      if (wordElement.classList.contains('vocab-word-explained')) {
        // Add a class to ensure the active state is visible
        wordElement.classList.add('vocab-word-clicking');
        setTimeout(() => {
          wordElement.classList.remove('vocab-word-clicking');
        }, 150);
      }
    });
    
    // Click: show popup (sticky) - stays visible until closed by close button or outside click
    // If popup is already open for this word, close it instead
    wordElement.addEventListener('click', (e) => {
      console.log('[WordSelector] ===== CLICK EVENT =====');
      console.log('[WordSelector] Element state:', {
        hasExplainedClass: wordElement.classList.contains('vocab-word-explained'),
        isInDOM: document.body.contains(wordElement),
        textContent: wordElement.textContent.trim(),
        eventTarget: e.target,
        eventCurrentTarget: e.currentTarget
      });
      
      if (!wordElement.classList.contains('vocab-word-explained')) {
        console.log('[WordSelector] Element does not have vocab-word-explained class, ignoring click');
        return;
      }
      
      e.stopPropagation();
      
      // Get normalized word to check popup state
      const normalizedWord = wordElement.getAttribute('data-word') || wordElement.textContent.trim().toLowerCase();
      const isPopupOpen = this.wordPopupOpen.get(normalizedWord) === true;
      
      console.log('[WordSelector] Popup state check:', {
        normalizedWord: normalizedWord,
        isPopupOpen: isPopupOpen
      });
      
      // If popup is already open for this word, close it (show closing animation)
      if (isPopupOpen) {
        console.log('[WordSelector] Popup is open for this word, closing it');
        this.hideAllPopups();
        // Also close any open Ask AI modals when closing word popup
        this.closeAllAskAIModals();
        return;
      }
      
      // If a popup is currently closing, don't open a new one
      const closingPopup = document.querySelector('.vocab-word-popup[data-closing="true"]');
      if (closingPopup) {
        console.log('[WordSelector] Popup is currently closing, ignoring click');
        return;
      }
      
      // If a sticky popup is already visible for a different word, close it first
      const activeStickyPopup = document.querySelector('.vocab-word-popup[data-sticky="true"]:not([data-closing="true"])');
      if (activeStickyPopup) {
        console.log('[WordSelector] Sticky popup already visible for different word, closing it first');
        this.hideAllPopups();
        // Also close any open Ask AI modals when closing word popup
        this.closeAllAskAIModals();
        // Small delay to ensure the previous popup is closed before showing the new one
        setTimeout(() => {
          console.log('[WordSelector] ✓ Showing sticky popup on click for new word');
          this.showWordPopup(wordElement, true);
        }, 50);
        return;
      }
      
      console.log('[WordSelector] ✓ Showing sticky popup on click (opening animation)');
      // Show sticky popup (opening animation)
      this.showWordPopup(wordElement, true);
    });
    
    console.log('[WordSelector] ✓ Word interactions setup complete');
  },
  
  /**
   * Create a green wireframe cross button for removing explained words
   * @param {string} word - The word this button will remove
   * @returns {HTMLElement}
   */
  createRemoveExplainedButton(word) {
    const normalizedWord = word.toLowerCase().trim();
    const btn = document.createElement('button');
    btn.className = 'vocab-word-remove-explained-btn';
    btn.setAttribute('aria-label', `Remove explanation for "${word}"`);
    btn.innerHTML = this.createGreenCrossIcon();
    
    // Add click handler - use normalized word for consistent lookup
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log(`[WordSelector] Green cross button clicked for word: "${word}" (normalized: "${normalizedWord}")`);
      this.removeExplainedWord(normalizedWord);
    });
    
    return btn;
  },
  
  /**
   * Create speaker icon SVG
   * @returns {string} SVG markup
   */
  createSpeakerIcon() {
    return `
      <svg width="14" height="14" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 8v4h3l4 4V4L5 8H2z" fill="white"/>
        <path d="M13 7c.6.6 1 1.4 1 2.3s-.4 1.7-1 2.3" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
        <path d="M15.5 4.5c1.2 1.2 2 2.8 2 4.6s-.8 3.4-2 4.6" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
      </svg>
    `;
  },

  /**
   * Create close icon SVG (X icon)
   * @returns {string} SVG markup
   */
  createCloseIcon() {
    return `
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M18 6L6 18M6 6l12 12" stroke="#A020F0" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },

  /**
   * Create bookmark icon SVG
   * @param {boolean} filled - Whether to show filled (bookmarked) or wireframe icon
   * @returns {string} SVG markup
   */
  createBookmarkIcon(filled = false) {
    if (filled) {
      // Solid filled purple bookmark icon (when bookmarked, show purple)
      return `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M17 3H7C5.9 3 5 3.9 5 5V21L12 18L19 21V5C19 3.9 18.1 3 17 3Z" stroke="#A020F0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="#A020F0"/>
        </svg>
      `;
    } else {
      // Wireframe bookmark icon (light purple) - matching chat icon thickness
      return `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M17 3H7C5.9 3 5 3.9 5 5V21L12 18L19 21V5C19 3.9 18.1 3 17 3Z" stroke="#D8B4FE" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </svg>
      `;
    }
  },

  createChatIcon() {
    // Chat dots icon from provided SVG (light purple) - converted to stroke for consistent thickness
    return `
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M13.0867 21.3877L13.7321 21.7697L13.0867 21.3877ZM13.6288 20.4718L12.9833 20.0898L13.6288 20.4718ZM10.3712 20.4718L9.72579 20.8539H9.72579L10.3712 20.4718ZM10.9133 21.3877L11.5587 21.0057L10.9133 21.3877ZM1.25 10.5C1.25 10.9142 1.58579 11.25 2 11.25C2.41421 11.25 2.75 10.9142 2.75 10.5H1.25ZM3.07351 15.6264C2.915 15.2437 2.47627 15.062 2.09359 15.2205C1.71091 15.379 1.52918 15.8177 1.68769 16.2004L3.07351 15.6264ZM7.78958 18.9915L7.77666 19.7413L7.78958 18.9915ZM5.08658 18.6194L4.79957 19.3123H4.79957L5.08658 18.6194ZM21.6194 15.9134L22.3123 16.2004V16.2004L21.6194 15.9134ZM16.2104 18.9915L16.1975 18.2416L16.2104 18.9915ZM18.9134 18.6194L19.2004 19.3123H19.2004L18.9134 18.6194ZM19.6125 2.7368L19.2206 3.37628L19.6125 2.7368ZM21.2632 4.38751L21.9027 3.99563V3.99563L21.2632 4.38751ZM4.38751 2.7368L3.99563 2.09732V2.09732L4.38751 2.7368ZM2.7368 4.38751L2.09732 3.99563H2.09732L2.7368 4.38751ZM9.40279 19.2098L9.77986 18.5615L9.77986 18.5615L9.40279 19.2098ZM13.7321 21.7697L14.2742 20.8539L12.9833 20.0898L12.4412 21.0057L13.7321 21.7697ZM9.72579 20.8539L10.2679 21.7697L11.5587 21.0057L11.0166 20.0898L9.72579 20.8539ZM12.4412 21.0057C12.2485 21.3313 11.7515 21.3313 11.5587 21.0057L10.2679 21.7697C11.0415 23.0767 12.9585 23.0767 13.7321 21.7697L12.4412 21.0057ZM10.5 2.75H13.5V1.25H10.5V2.75ZM21.25 10.5V11.5H22.75V10.5H21.25ZM7.8025 18.2416C6.54706 18.2199 5.88923 18.1401 5.37359 17.9265L4.79957 19.3123C5.60454 19.6457 6.52138 19.7197 7.77666 19.7413L7.8025 18.2416ZM1.68769 16.2004C2.27128 17.6093 3.39066 18.7287 4.79957 19.3123L5.3736 17.9265C4.33223 17.4951 3.50486 16.6678 3.07351 15.6264L1.68769 16.2004ZM21.25 11.5C21.25 12.6751 21.2496 13.5189 21.2042 14.1847C21.1592 14.8438 21.0726 15.2736 20.9265 15.6264L22.3123 16.2004C22.5468 15.6344 22.6505 15.0223 22.7007 14.2868C22.7504 13.5581 22.75 12.6546 22.75 11.5H21.25ZM16.2233 19.7413C17.4786 19.7197 18.3955 19.6457 19.2004 19.3123L18.6264 17.9265C18.1108 18.1401 17.4529 18.2199 16.1975 18.2416L16.2233 19.7413ZM20.9265 15.6264C20.4951 16.6678 19.6678 17.4951 18.6264 17.9265L19.2004 19.3123C20.6093 18.7287 21.7287 17.6093 22.3123 16.2004L20.9265 15.6264ZM13.5 2.75C15.1512 2.75 16.337 2.75079 17.2619 2.83873C18.1757 2.92561 18.7571 3.09223 19.2206 3.37628L20.0044 2.09732C19.2655 1.64457 18.4274 1.44279 17.4039 1.34547C16.3915 1.24921 15.1222 1.25 13.5 1.25V2.75ZM22.75 10.5C22.75 8.87781 22.7508 7.6085 22.6545 6.59611C22.5572 5.57256 22.3554 4.73445 21.9027 3.99563L20.6237 4.77938C20.9078 5.24291 21.0744 5.82434 21.1613 6.73809C21.2492 7.663 21.25 8.84876 21.25 10.5H22.75ZM19.2206 3.37628C19.7925 3.72672 20.2733 4.20752 20.6237 4.77938L21.9027 3.99563C21.4286 3.22194 20.7781 2.57144 20.0044 2.09732L19.2206 3.37628ZM10.5 1.25C8.87781 1.25 7.6085 1.24921 6.59611 1.34547C5.57256 1.44279 4.73445 1.64457 3.99563 2.09732L4.77938 3.37628C5.24291 3.09223 5.82434 2.92561 6.73809 2.83873C7.663 2.75079 8.84876 2.75 10.5 2.75V1.25ZM2.75 10.5C2.75 8.84876 2.75079 7.663 2.83873 6.73809C2.92561 5.82434 3.09223 5.24291 3.37628 4.77938L2.09732 3.99563C1.64457 4.73445 1.44279 5.57256 1.34547 6.59611C1.24921 7.6085 1.25 8.87781 1.25 10.5H2.75ZM3.99563 2.09732C3.22194 2.57144 2.57144 3.22194 2.09732 3.99563L3.37628 4.77938C3.72672 4.20752 4.20752 3.72672 4.77938 3.37628L3.99563 2.09732ZM11.0166 20.0898C10.8136 19.7468 10.6354 19.4441 10.4621 19.2063C10.2795 18.9559 10.0702 18.7304 9.77986 18.5615L9.02572 19.8582C9.07313 19.8857 9.13772 19.936 9.24985 20.0898C9.37122 20.2564 9.50835 20.4865 9.72579 20.8539L11.0166 20.0898ZM7.77666 19.7413C8.21575 19.7489 8.49387 19.7545 8.70588 19.7779C8.90399 19.7999 8.98078 19.832 9.02572 19.8582L9.77986 18.5615C9.4871 18.3912 9.18246 18.3215 8.87097 18.287C8.57339 18.2541 8.21375 18.2487 7.8025 18.2416L7.77666 19.7413ZM14.2742 20.8539C14.4916 20.4865 14.6287 20.2564 14.7501 20.0898C14.8622 19.936 14.9268 19.8857 14.9742 19.8582L14.2201 18.5615C13.9298 18.7304 13.7204 18.9559 13.5379 19.2063C13.3646 19.4441 13.1864 19.7468 12.9833 20.0898L14.2742 20.8539ZM16.1975 18.2416C15.7862 18.2487 15.4266 18.2541 15.129 18.287C14.8175 18.3215 14.5129 18.3912 14.2201 18.5615L14.9742 19.8582C15.0192 19.832 15.096 19.7999 15.2941 19.7779C15.5061 19.7545 15.7842 19.7489 16.2233 19.7413L16.1975 18.2416Z" stroke="#D8B4FE" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M8 11H8.009M11.991 11H12M15.991 11H16" stroke="#D8B4FE" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },

  createSparkleIcon() {
    // Simple sparkle icon (light purple) - matching chat icon thickness
    return `
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2L14.5 8.5L21 11L14.5 13.5L12 20L9.5 13.5L3 11L9.5 8.5L12 2Z" stroke="#D8B4FE" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>
    `;
  },

  /**
   * Handle bookmark button click
   * @param {string} word - The word to bookmark/unbookmark
   * @param {string} meaning - The meaning of the word
   * @param {HTMLElement} bookmarkBtn - The bookmark button element
   */
  async handleBookmarkClick(word, meaning, bookmarkBtn) {
    const normalizedWord = word.toLowerCase().trim();
    const isCurrentlyBookmarked = await BookmarkWordsService.isBookmarked(word);
    
    if (isCurrentlyBookmarked) {
      // Remove bookmark
      await BookmarkWordsService.removeBookmark(word);
      bookmarkBtn.classList.remove('bookmarked');
      bookmarkBtn.innerHTML = this.createBookmarkIcon(false);
      console.log('[WordSelector] Removed bookmark for:', word);
    } else {
      // Add bookmark
      const success = await BookmarkWordsService.addBookmark(word, meaning, window.location.href);
      if (success) {
        bookmarkBtn.classList.add('bookmarked');
        bookmarkBtn.innerHTML = this.createBookmarkIcon(true);
        console.log('[WordSelector] Added bookmark for:', word);
      } else {
        console.error('[WordSelector] Failed to add bookmark for:', word);
      }
    }
  },

  /**
   * Create loading spinner icon SVG
   * @returns {string} SVG markup
   */
  createLoadingSpinnerIcon() {
    return `
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="vocab-loading-spinner">
        <circle cx="12" cy="12" r="10" stroke="#9F7BDB" stroke-width="2" fill="none" opacity="0.3"/>
        <path d="M12 2a10 10 0 0 1 10 10" stroke="#9F7BDB" stroke-width="2" fill="none" stroke-linecap="round">
          <animateTransform attributeName="transform" type="rotate" dur="1s" repeatCount="indefinite" values="0 12 12;360 12 12"/>
        </path>
      </svg>
    `;
  },

  /**
   * Handle pronunciation button click
   * @param {string} word - The word to pronounce
   * @param {HTMLElement} button - The speaker button element
   */
  async handlePronunciation(word, button) {
    // Check if we already have cached audio for this word
    const cacheKey = `pronunciation_${word.toLowerCase()}`;
    const cachedAudio = this.pronunciationCache?.get(cacheKey);
    
    if (cachedAudio) {
      console.log('[WordSelector] Playing cached pronunciation for:', word);
      await this.playAudio(cachedAudio);
      return;
    }
    
    // Show loading state
    button.disabled = true;
    button.classList.add('loading');
    const originalIcon = button.innerHTML;
    button.innerHTML = this.createLoadingSpinnerIcon();
    
    try {
      console.log('[WordSelector] Fetching pronunciation for:', word);
      
      // Retry logic wrapper
      let retryCount = 0;
      const maxRetries = 1; // Only retry once to avoid infinite loops
      
      const makeRequest = async () => {
        // Get fresh headers for each request attempt (token may have been refreshed)
        const currentHeaders = {
          'Content-Type': 'application/json',
          ...(await ApiService.getUnauthenticatedUserIdHeader())
        };
        
        // Add Authorization header if access token is available
        await ApiService.addAuthorizationHeader(currentHeaders);
        
        return await fetch(`${ApiConfig.BASE_URL}/api/v2/pronunciation`, {
          method: 'POST',
          headers: currentHeaders,
          mode: 'cors',
          credentials: 'include',
          body: JSON.stringify({ 
            word: word,
            voice: 'alloy' // Default voice
          })
        });
      };
      
      let response = await makeRequest();
      
      // Store X-Unauthenticated-User-Id from response header
      await ApiService.storeUnauthenticatedUserId(response);
      
      if (!response.ok) {
        // Clone response for error handling (response body can only be read once)
        const responseClone = response.clone();
        const errorInfo = await ApiService.handleApiError(responseClone, 'PRONUNCIATION');
        
        // Check if token was refreshed and we should retry
        if (errorInfo.errorCode === 'TOKEN_REFRESHED' && errorInfo.shouldRetry && retryCount < maxRetries) {
          console.log('[WordSelector] Token refreshed, retrying pronunciation request (attempt', retryCount + 1, ')');
          retryCount++;
          
          // Retry the request with the new token
          response = await makeRequest();
          await ApiService.storeUnauthenticatedUserId(response);
          
          // Check if retry also failed
          if (!response.ok) {
            const retryResponseClone = response.clone();
            const retryErrorInfo = await ApiService.handleApiError(retryResponseClone, 'PRONUNCIATION');
            
            // Handle specific error cases
            if (retryErrorInfo.errorCode === 'LOGIN_REQUIRED') {
              throw new Error(retryErrorInfo.message || 'Please sign in to continue');
            } else if (response.status === 429) {
              throw new Error('Too many requests. Please wait a moment and try again.');
            } else if (response.status === 400) {
              try {
                const errorData = await response.json();
                throw new Error(`Invalid request: ${errorData.detail || retryErrorInfo.message}`);
              } catch (e) {
                throw new Error(retryErrorInfo.message || `Invalid request`);
              }
            } else if (response.status === 500) {
              throw new Error('Server error. Please try again later.');
            } else {
              throw new Error(retryErrorInfo.message || `HTTP ${response.status}: ${response.statusText}`);
            }
          }
        } else {
          // Handle specific error cases
          if (errorInfo.errorCode === 'LOGIN_REQUIRED') {
            throw new Error(errorInfo.message || 'Please sign in to continue');
          } else if (response.status === 429) {
            throw new Error('Too many requests. Please wait a moment and try again.');
          } else if (response.status === 400) {
            try {
              const errorData = await response.json();
              throw new Error(`Invalid request: ${errorData.detail || errorInfo.message}`);
            } catch (e) {
              throw new Error(errorInfo.message || `Invalid request`);
            }
          } else if (response.status === 500) {
            throw new Error('Server error. Please try again later.');
          } else {
            throw new Error(errorInfo.message || `HTTP ${response.status}: ${response.statusText}`);
          }
        }
      }
      
      const audioBlob = await response.blob();
      
      // Cache the audio
      if (!this.pronunciationCache) {
        this.pronunciationCache = new Map();
      }
      this.pronunciationCache.set(cacheKey, audioBlob);
      
      // Play the audio
      await this.playAudio(audioBlob);
      
      console.log('[WordSelector] Pronunciation played successfully for:', word);
      
    } catch (error) {
      console.error('[WordSelector] Pronunciation error:', error);
      this.showErrorBanner(error.message || 'Failed to play pronunciation');
    } finally {
      // Restore button state
      button.disabled = false;
      button.classList.remove('loading');
      button.innerHTML = originalIcon;
    }
  },

  /**
   * Play audio from blob
   * @param {Blob} audioBlob - The audio blob to play
   */
  async playAudio(audioBlob) {
    // Convert blob to base64 data URL to avoid CSP violations with blob URLs
    // This works around websites that block blob: URLs in their Content Security Policy
    const base64Url = await this.blobToDataURL(audioBlob);
    const audio = new Audio(base64Url);
    audio.volume = 1.0; // Maximum volume
    
    return new Promise((resolve, reject) => {
      audio.onended = () => {
        resolve();
      };
      
      audio.onerror = (error) => {
        console.error('[WordSelector] Audio playback error:', error);
        reject(new Error('Failed to play audio. This may be due to website Content Security Policy restrictions.'));
      };
      
      audio.play().catch((error) => {
        console.error('[WordSelector] Audio play() error:', error);
        reject(error);
      });
    });
  },
  
  /**
   * Convert blob to base64 data URL
   * @param {Blob} blob - The blob to convert
   * @returns {Promise<string>} Base64 data URL
   */
  async blobToDataURL(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = (error) => {
        reject(error);
      };
      reader.readAsDataURL(blob);
    });
  },

  /**
   * Show error banner
   * @param {string} message - Error message to display
   */
  showErrorBanner(message) {
    // Remove existing error banner if any
    const existingBanner = document.querySelector('.vocab-error-banner');
    if (existingBanner) {
      existingBanner.remove();
    }
    
    // Create error banner
    const banner = document.createElement('div');
    banner.className = 'vocab-error-banner';
    banner.innerHTML = `
      <div class="vocab-error-content">
        <span class="vocab-error-icon">⚠️</span>
        <span class="vocab-error-message">${message}</span>
        <button class="vocab-error-close" aria-label="Close error">×</button>
      </div>
    `;
    
    // Add close functionality
    const closeBtn = banner.querySelector('.vocab-error-close');
    closeBtn.addEventListener('click', () => {
      banner.remove();
    });
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (banner.parentNode) {
        banner.remove();
      }
    }, 5000);
    
    // Add to page
    document.body.appendChild(banner);
    
    // Animate in
    setTimeout(() => {
      banner.classList.add('visible');
    }, 10);
  },

  /**
   * Create green wireframe cross icon SVG
   * @returns {string} SVG markup
   */
  createGreenCrossIcon() {
    return `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 2L10 10M10 2L2 10" stroke="#15803d" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Remove an explained word (remove green background and from explainedWords container)
   * @param {string} word - The word to remove
   */
  removeExplainedWord(word) {
    const normalizedWord = word.toLowerCase().trim();
    
    console.log('[WordSelector] ===== REMOVING EXPLAINED WORD =====');
    console.log('[WordSelector] Original word:', word);
    console.log('[WordSelector] Normalized word:', normalizedWord);
    console.log('[WordSelector] Available explained words:', Array.from(this.explainedWords.keys()));
    
    // Get the word data from explainedWords
    const wordData = this.explainedWords.get(normalizedWord);
    
    if (!wordData) {
      console.warn('[WordSelector] ✗ Word not found in explainedWords:', normalizedWord);
      console.warn('[WordSelector] Available keys:', Array.from(this.explainedWords.keys()));
      return;
    }
    
    console.log('[WordSelector] ✓ Found word data in explainedWords:', wordData);
    
    // Remove green background and buttons from all highlights with smooth animations
    if (wordData.highlights) {
      wordData.highlights.forEach(highlight => {
        // Add disappearing animation classes (same 0.3s duration as purple highlights)
        highlight.classList.add('word-disappearing');
        
        // Add disappearing animation to green cross button
        const greenBtn = highlight.querySelector('.vocab-word-remove-explained-btn');
        if (greenBtn) {
          greenBtn.classList.add('button-disappearing');
        }
        
        // Wait for animation to complete before removing elements (0.3s same duration)
        setTimeout(() => {
          // Remove the green explained class
          highlight.classList.remove('vocab-word-explained', 'word-disappearing');
          
          // Remove the green cross button
          if (greenBtn) {
            greenBtn.remove();
          }
          
          // Remove data attributes
          highlight.removeAttribute('data-meaning');
          highlight.removeAttribute('data-examples');
          highlight.removeAttribute('data-popup-id');
          
          // Remove the highlight wrapper completely
          const parent = highlight.parentNode;
          if (parent) {
            // Move all child nodes out of the highlight wrapper
            while (highlight.firstChild) {
              parent.insertBefore(highlight.firstChild, highlight);
            }
            // Remove the empty highlight wrapper
            highlight.remove();
            // Normalize parent to merge text nodes
            parent.normalize();
          }
        }, 300); // Same duration as animation (0.3s)
      });
    }
    
    // Get word element for animation before deleting from explainedWords
    let wordElementForAnimation = null;
    if (wordData.highlights && wordData.highlights.size > 0) {
      // Get the first highlight element for animation target
      wordElementForAnimation = Array.from(wordData.highlights)[0];
    }
    
    // Remove from explainedWords Map
    this.explainedWords.delete(normalizedWord);
    
    // Remove from wordToHighlights Map
    this.wordToHighlights.delete(normalizedWord);
    
    // Also remove from selectedWords if present (to allow re-selection)
    if (this.selectedWords.has(normalizedWord)) {
      this.selectedWords.delete(normalizedWord);
      console.log('[WordSelector] Also removed from selectedWords:', normalizedWord);
    }
    
    // Also remove from analysis data structure for current tab
    ButtonPanel.removeWordFromAnalysisData(normalizedWord);
    
    // Hide any open popups for this word
    this.hideAllPopups();
    
    // Also close any open Ask AI modals when removing explained word
    // Pass wordElementForAnimation so animation targets the word center instead of button center
    this.closeAllAskAIModals(normalizedWord, wordElementForAnimation);
    
    console.log('[WordSelector] Explained word removed:', word);
    console.log('[WordSelector] Remaining explained words:', this.explainedWords.size);
    console.log('[WordSelector] Remaining selected words:', this.selectedWords.size);
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Inject CSS styles for word highlights
   */
  injectStyles() {
    const styleId = 'vocab-word-selector-styles';
    
    // Check if styles already injected
    if (document.getElementById(styleId)) {
      return;
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      /* Word highlight wrapper */
      .vocab-word-highlight {
        position: relative;
        display: inline;
        background-color: rgba(149, 39, 245, 0.15);
        padding: 0 4px;
        border-radius: 8px;
        border: none;
        transition: background-color 0.2s ease;
        cursor: pointer;
        line-height: inherit;
        box-decoration-break: clone;
        -webkit-box-decoration-break: clone;
        /* DO NOT set font properties - preserve all formatting from child elements */
        /* Child elements (bold, italic, spans with different font sizes) will maintain their formatting */
        /* Text nodes will inherit naturally from their original parent context */
      }
      
      .vocab-word-highlight:hover {
        background-color: rgba(149, 39, 245, 0.25);
      }
      
      /* Remove button - Clean cross icon without circle */
      .vocab-word-remove-btn {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 18px;
        height: 18px;
        background-color: #FFFFFF !important; /* Fully opaque white background */
        background: #FFFFFF !important; /* Fully opaque white background */
        border: 1px solid #9527F5 !important; /* Thin purple border */
        border-radius: 50% !important; /* Circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 1 !important; /* Fully opaque */
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, scale 0.3s ease-in-out, background-color 0.2s ease, border-color 0.2s ease;
        padding: 0;
        z-index: 999999;
        box-shadow: 0 1px 3px rgba(149, 39, 245, 0.2);
        box-sizing: border-box;
      }
      
      .vocab-word-highlight:hover .vocab-word-remove-btn {
        opacity: 1 !important;
      }
      
      .vocab-word-remove-btn:hover {
        transform: scale(1.15);
        opacity: 1 !important; /* Fully opaque on hover */
        background-color: #FFFFFF !important; /* Keep fully opaque white background on hover */
        background: #FFFFFF !important; /* Keep fully opaque white background on hover */
        border-color: #7a1fd9 !important; /* Slightly darker purple border on hover */
      }
      
      .vocab-word-remove-btn:active {
        transform: scale(0.95);
      }
      
      .vocab-word-remove-btn svg {
        pointer-events: none;
        display: block;
        width: 10px;
        height: 10px;
      }
      
      /* Make sure highlight doesn't interfere with text flow */
      .vocab-word-highlight * {
        box-sizing: border-box;
      }
      
      /* Pulsating purple animation for words being processed */
      @keyframes vocab-word-loading-breathe {
        0%, 100% {
          background-color: rgba(196, 181, 253, 0.7); /* Purple with slight transparency - lighter shade */
        }
        50% {
          background-color: rgba(167, 139, 250, 0.8); /* Purple with slight transparency - darker shade */
        }
      }
      
      .vocab-word-loading {
        animation: vocab-word-loading-breathe 0.75s ease-in-out infinite;
      }
      
      /* Loading spinner container - positioned above the word */
      .vocab-word-loading-spinner-container {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        width: 24px;
        height: 24px;
        background-color: #FFFFFF;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000000;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      
      /* Purple spinner animation */
      @keyframes vocab-spinner-rotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      .vocab-word-loading-spinner {
        width: 16px;
        height: 16px;
        border: 2px solid rgba(149, 39, 245, 0.2);
        border-top-color: #9527F5;
        border-radius: 50%;
        animation: vocab-spinner-rotate 0.8s linear infinite;
      }
      
      /* Word span without background (pending state before API call) */
      /* Must match .vocab-word-highlight exactly except for background color and box-decoration-break */
      .vocab-word-span-pending {
        position: relative;
        display: inline;
        /* No background color - transparent */
        padding: 0;
        border-radius: 0;
        border: none;
        transition: none;
        cursor: default;
        line-height: inherit;
        /* Don't use box-decoration-break since there's no background to break */
        /* This prevents layout issues and line breaks */
        /* DO NOT set font properties - preserve all formatting from child elements */
        /* Child elements (bold, italic, spans with different font sizes) will maintain their formatting */
        /* Text nodes will inherit naturally from their original parent context */
      }
      
      /* Magic meaning button container - positioned above the word */
      .vocab-word-magic-button-container {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2147483647; /* Maximum z-index to ensure visibility */
        pointer-events: auto;
        /* Ensure button is not clipped by parent overflow */
        visibility: visible;
        opacity: 1;
      }
      
      /* Magic meaning button */
      .vocab-word-magic-meaning-btn {
        width: 28px;
        height: 28px;
        background-color: #FFFFFF;
        border: none;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        padding: 0;
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        pointer-events: auto;
      }
      
      .vocab-word-magic-meaning-btn:hover {
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4);
      }
      
      .vocab-word-magic-meaning-btn:active {
        transform: scale(0.9);
      }
      
      .vocab-word-magic-meaning-btn img,
      .vocab-word-magic-meaning-btn svg {
        width: 20px !important;
        height: 20px !important;
        pointer-events: none !important;
        object-fit: contain !important;
        display: block !important;
        flex-shrink: 0 !important;
        max-width: 20px !important;
        max-height: 20px !important;
        visibility: visible !important;
        opacity: 1 !important;
        position: relative !important;
        z-index: 1 !important;
      }
      
      .vocab-word-magic-meaning-btn svg path {
        visibility: visible !important;
        opacity: 1 !important;
        display: block !important;
      }
      
      /* Breathing animation for magic button */
      .magic-meaning-breathing {
        animation: magicButtonBreathing 3s ease-in-out infinite;
      }
      
      @keyframes magicButtonBreathing {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
      
      /* Appearing animation for word button */
      @keyframes magicWordButtonAppear {
        from {
          transform: scale(0);
        }
        to {
          transform: scale(1);
        }
      }
      
      /* Disappearing animation for word button */
      @keyframes magicWordButtonDisappear {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(0);
        }
      }
      
      .vocab-word-magic-meaning-btn.magic-meaning-appearing {
        animation: magicWordButtonAppear 0.2s ease-out forwards;
      }
      
      .vocab-word-magic-meaning-btn.magic-meaning-disappearing {
        animation: magicWordButtonDisappear 0.2s ease-in forwards;
      }
      
      /* Loading state for magic button */
      .magic-meaning-loading {
        animation: none !important; /* Disable breathing animation during loading */
      }
      
      .magic-meaning-loading img {
        width: 18px;
        height: 18px;
      }
      
      /* Green background for explained words */
      .vocab-word-explained {
        background-color: rgba(240, 253, 244, 0.5) !important; /* Very light green, semi-transparent */
        cursor: pointer;
        border-radius: 8px;
        border: 0.5px solid #22c55e !important; /* Green border (not light green) */
        padding: 0 2px;
        margin-top: 0 !important; /* Prevent top margin from affecting line spacing */
        margin-bottom: 0 !important; /* Prevent bottom margin from affecting line spacing */
        display: inline-block !important; /* Use inline-block for transform support */
        width: auto !important; /* Prevent width from expanding to full line */
        max-width: fit-content !important; /* Ensure it only wraps the text content */
        min-width: auto !important; /* Prevent min-width from forcing expansion */
        user-select: none;
        -webkit-user-select: none;
        transition: background-color 0.3s ease-in-out, opacity 0.3s ease-in-out;
        box-decoration-break: clone; /* Ensure background wraps correctly on line breaks */
        -webkit-box-decoration-break: clone;
        line-height: normal !important; /* Use normal line height to prevent expansion */
        vertical-align: middle !important; /* Align to middle to minimize line height impact */
        height: auto !important; /* Ensure height doesn't expand */
        max-height: none !important; /* Remove max-height constraints */
        box-sizing: border-box !important; /* Include padding in width calculation */
        margin: 0 !important; /* Remove any margins that could affect spacing */
      }
      
      /* Breathing animation for green word when it first appears - breathes twice (same as book icon) */
      .vocab-word-explained.word-breathing {
        display: inline-block !important; /* Need inline-block for transform animation */
        width: auto !important; /* Prevent width from expanding */
        max-width: fit-content !important; /* Ensure it only wraps the text content */
        animation: wordGreenBreathing 0.8s ease-in-out;
      }
      
      @keyframes wordGreenBreathing {
        0% {
          transform: scale(1);
        }
        25% {
          transform: scale(1.15);
        }
        50% {
          transform: scale(1);
        }
        75% {
          transform: scale(1.15);
        }
        100% {
          transform: scale(1);
        }
      }
      
      /* Green pulsation animation for URL param words - pulsates 3 times */
      .xplaino-word-pulsate {
        animation: xplainoWordPulsate 1.5s ease-in-out;
      }
      
      @keyframes xplainoWordPulsate {
        0%, 100% {
          background-color: rgba(240, 253, 244, 0.5);
        }
        16.66% {
          background-color: rgba(34, 197, 94, 0.8);
        }
        33.33% {
          background-color: rgba(240, 253, 244, 0.5);
        }
        50% {
          background-color: rgba(34, 197, 94, 0.8);
        }
        66.66% {
          background-color: rgba(240, 253, 244, 0.5);
        }
        83.33% {
          background-color: rgba(34, 197, 94, 0.8);
        }
      }
      
      /* Popup animation for green word when it first appears - pops twice to show clickable entity */
      .vocab-word-explained.word-popup {
        display: inline-block !important; /* Need inline-block for transform animation */
        width: auto !important; /* Prevent width from expanding */
        max-width: fit-content !important; /* Ensure it only wraps the text content */
        will-change: transform !important; /* Optimize for animation */
        transition: none !important; /* Disable transition during animation */
        animation: wordPopup 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) !important;
      }
      
      @keyframes wordPopup {
        0% {
          transform: scale(1);
        }
        20% {
          transform: scale(1.3);
        }
        40% {
          transform: scale(1);
        }
        60% {
          transform: scale(1.3);
        }
        80% {
          transform: scale(1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      .vocab-word-explained:hover {
        background-color: rgba(187, 247, 208, 0.75) !important; /* Darker green on hover to show clickable */
      }
      
      .vocab-word-explained:active,
      .vocab-word-explained.vocab-word-clicking {
        transform: scale(0.97) !important; /* Reduced scale-down animation - less pronounced */
        background-color: rgba(167, 243, 208, 0.8) !important; /* Darker green on active/click to show interaction */
      }
      
      /* Smooth animation for green word highlight disappearance - 0.3s duration */
      .vocab-word-explained.word-disappearing {
        animation: wordFadeOut 0.3s ease-in-out forwards;
      }
      
      @keyframes wordFadeOut {
        0% {
          background-color: rgba(240, 253, 244, 0.5); /* Very light green, semi-transparent */
          opacity: 1;
        }
        100% {
          background-color: transparent;
          opacity: 0;
        }
      }
      
      /* Green cross button for explained words - white circular background with thin green border */
      .vocab-word-remove-explained-btn {
        position: absolute !important;
        top: -10px !important;
        right: -10px !important;
        width: 18px !important;
        height: 18px !important;
        min-width: 18px !important;
        min-height: 18px !important;
        max-width: 18px !important;
        max-height: 18px !important;
        background: white !important; /* White circular non-transparent background */
        border: 1px solid #4ade80 !important; /* Thin green border */
        border-radius: 50% !important; /* Circular shape */
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        opacity: 0.9 !important;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, scale 0.3s ease-in-out, background-color 0.2s ease, border-color 0.2s ease !important;
        padding: 0 !important;
        z-index: 999999 !important;
        box-shadow: 0 1px 3px rgba(34, 197, 94, 0.2) !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
      }
      
      /* Smooth animation for green cross button disappearance - 0.3s duration */
      .vocab-word-remove-explained-btn.button-disappearing {
        animation: greenButtonFadeOut 0.3s ease-in-out forwards;
      }
      
      @keyframes greenButtonFadeOut {
        0% {
          opacity: 0.8;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(0.8);
        }
      }
      
      .vocab-word-explained:hover .vocab-word-remove-explained-btn {
        opacity: 1;
      }
      
      .vocab-word-remove-explained-btn:hover {
        transform: scale(1.15);
        opacity: 1;
        background-color: #f0fdf4 !important; /* Light green tint on hover */
        border-color: #22c55e !important; /* Slightly darker green border on hover */
      }
      
      .vocab-word-remove-explained-btn:active {
        transform: scale(0.95);
      }
      
      .vocab-word-remove-explained-btn svg {
        pointer-events: none !important;
        display: block !important;
        width: 10px !important;
        height: 10px !important;
        min-width: 10px !important;
        min-height: 10px !important;
        max-width: 10px !important;
        max-height: 10px !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-word-remove-explained-btn svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      /* Contextual Meaning Popup Card */
      .vocab-word-popup {
        position: absolute;
        background: white;
        border-radius: 30px;
        padding: 24px;
        box-shadow: 0 8px 24px rgba(149, 39, 245, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 10000010;
        max-width: 380px;
        min-width: 300px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        opacity: 0;
        transform: none;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }
      
      /* Reduce padding and margin when "Get more examples" button is hidden */
      .vocab-word-popup.no-more-examples-button {
        padding: 24px; /* Consistent padding when button is hidden */
      }
      
      .vocab-word-popup.no-more-examples-button .vocab-word-popup-examples-container {
        margin-bottom: 60px; /* Keep margin for tab group even when button is hidden */
      }
      
      .vocab-word-popup.visible {
        opacity: 1;
        transform: none;
        pointer-events: all;
      }
      
      /* Expanding animation - scale up from word element position */
      .vocab-word-popup.expanding {
        animation: expandWordPopupFromWord 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        transition: none !important; /* Disable transition during animation */
        pointer-events: none !important;
        will-change: transform !important; /* Optimize for animation */
        opacity: 1 !important;
      }
      
      .vocab-word-popup.expanding.visible {
        animation: expandWordPopupFromWord 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        transition: none !important;
      }
      
      @keyframes expandWordPopupFromWord {
        0% {
          transform: var(--expand-start-transform, translate(0, 0) scale(0)) !important;
          opacity: 1;
        }
        100% {
          transform: var(--expand-end-transform, translate(0, 0) scale(1)) !important;
          opacity: 1;
        }
      }
      
      /* Closing animation - move to word position while scaling down */
      .vocab-word-popup.closing {
        animation: closeWordPopupToWord 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        transition: none !important;
        pointer-events: none !important;
        will-change: transform !important;
        opacity: 1 !important;
      }
      
      @keyframes closeWordPopupToWord {
        0% {
          transform: var(--close-start-transform, translate(0, 0) scale(1)) !important;
          opacity: 1;
        }
        100% {
          transform: var(--close-end-transform, translate(0, 0) scale(0)) !important;
          opacity: 0;
        }
      }
      
      .vocab-word-popup.sticky {
        pointer-events: all;
      }
      
      .vocab-word-popup-header {
        text-align: center;
        color: #A020F0;
        font-weight: 600;
        font-size: 16px;
        margin-bottom: 14px;
      }
      
      .vocab-word-popup-meaning {
        color: #333;
        font-size: 15px;
        line-height: 1.5;
        margin-bottom: 14px;
        padding-top: 0; /* No padding by default */
      }
      
      /* No padding-top needed since speaker icon is now in bottom container */
      
      .vocab-word-popup-meaning .word-bold {
        font-weight: 600;
        color: #A020F0;
      }
      
      /* Examples container with scrolling */
      .vocab-word-popup-examples-container {
        overflow-y: auto;
        margin-bottom: 70px; /* Increased margin to prevent overlap with tab group and button */
        margin-top: 16px; /* Space above separator line */
        padding-top: 16px; /* Space below separator line */
        padding-bottom: 8px; /* Additional padding at bottom */
        max-height: none; /* Flexible height based on content */
        position: relative;
        z-index: 1;
        border-top: 0.5px solid rgba(149, 39, 245, 0.3); /* Light purple thin separator line */
      }
      
      .vocab-word-popup-examples-container::-webkit-scrollbar {
        width: 4px;
      }
      
      .vocab-word-popup-examples-container::-webkit-scrollbar-track {
        background: #F8F2FC;
        border-radius: 2px;
      }
      
      .vocab-word-popup-examples-container::-webkit-scrollbar-thumb {
        background: #D8C1E8;
        border-radius: 4px;
      }
      
      .vocab-word-popup-examples {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .vocab-word-popup-examples li {
        position: relative;
        padding-left: 18px;
        margin-bottom: 10px;
        color: #333;
        font-size: 14px;
        line-height: 1.4;
      }
      
      .vocab-word-popup-examples li:last-child {
        margin-bottom: 0;
      }
      
      .vocab-word-popup-examples li:before {
        content: '';
        position: absolute;
        left: 0;
        top: 7px;
        width: 6px;
        height: 6px;
        background: #A020F0;
        border-radius: 50%;
      }
      
      .vocab-word-popup-examples li .word-bold {
        font-weight: 600;
        color: #A020F0;
      }
      
      /* Bottom container for speaker icon, tab group, and button */
      .vocab-word-popup-bottom-container {
        position: absolute;
        bottom: 24px;
        left: 24px;
        right: 24px;
        display: flex;
        justify-content: flex-end;
        align-items: center;
        z-index: 20;
        gap: 12px;
        background: white;
        padding: 4px 0;
      }
      
      /* Language tab group - left side */
      .vocab-word-popup-tab-group {
        display: inline-flex;
        gap: 0;
        background: #e5e7eb;
        border-radius: 10px;
        padding: 3px;
        position: relative;
        width: auto;
        min-width: 120px;
        flex-shrink: 0;
      }
      
      .vocab-word-popup-tab-group::before {
        content: '';
        position: absolute;
        top: 3px;
        left: 3px;
        height: calc(100% - 6px);
        background: #A020F0;
        border-radius: 10px;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 0;
        width: calc(50% - 3px);
        transform: translateX(0);
      }
      
      .vocab-word-popup-tab-group[data-active-tab="EN"]::before {
        transform: translateX(calc(100% + 3px));
      }
      
      .vocab-word-popup-tab {
        padding: 6px 12px;
        border: none;
        border-radius: 5px;
        background: transparent;
        color: #6b7280;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        transition: color 0.2s ease;
        text-align: center;
        width: 50%;
        box-sizing: border-box;
        min-width: 36px;
        flex: 0 0 auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 1;
        white-space: nowrap;
      }
      
      .vocab-word-popup-tab.vocab-word-popup-tab-active {
        color: white;
      }
      
      .vocab-word-popup-tab:hover:not(.loading):not(.vocab-word-popup-tab-active) {
        color: #4b5563;
      }
      
      .vocab-word-popup-tab:active:not(.loading) {
        transform: scale(0.95);
      }
      
      .vocab-word-popup-tab.loading {
        cursor: not-allowed;
        pointer-events: none;
      }
      
      .vocab-word-popup-tab.loading .vocab-loading-spinner {
        width: 8px;
        height: 8px;
        border: 1.5px solid white;
        border-top-color: transparent;
        border-radius: 50%;
        animation: vocab-spin 0.8s linear infinite;
      }
      
      /* Ask button - square shaped with chat icon */
      .vocab-word-popup-ask-button {
        width: 40px;
        height: 40px;
        padding: 0;
        border: none;
        border-radius: 8px;
        background: none;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        position: relative;
      }
      
      .vocab-word-popup-ask-button[title]:hover::after {
        content: attr(title);
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: #1C274C;
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        white-space: nowrap;
        z-index: 100000;
        pointer-events: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }
      
      .vocab-word-popup-ask-button[title]:hover::before {
        content: '';
        position: absolute;
        bottom: calc(100% + 2px);
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: #1C274C;
        z-index: 100001;
        pointer-events: none;
      }
      
      .vocab-word-popup-ask-button svg {
        width: 20px;
        height: 20px;
        pointer-events: none;
        transition: stroke 0.2s ease, fill 0.2s ease;
      }
      
      .vocab-word-popup-ask-button:hover:not(.loading) {
        background: #E9D5FF;
      }
      
      .vocab-word-popup-ask-button:hover:not(.loading) svg path {
        stroke: #A020F0;
        fill: #A020F0;
      }
      
      .vocab-word-popup-ask-button:active:not(.loading) {
        transform: scale(0.9);
      }
      
      .vocab-word-popup-ask-button.loading {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      .vocab-word-popup-ask-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      .vocab-word-popup-ask-button:focus,
      .vocab-word-popup-ask-button:focus-visible {
        outline-offset: 2px;
      }
      
      /* View more button - square shaped with sparkle icon */
      .vocab-word-popup-button {
        width: 40px;
        height: 40px;
        padding: 0;
        border: none;
        border-radius: 8px;
        background: none;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        position: relative;
      }
      
      .vocab-word-popup-button[title]:hover::after {
        content: attr(title);
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: #1C274C;
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        white-space: nowrap;
        z-index: 100000;
        pointer-events: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }
      
      .vocab-word-popup-button[title]:hover::before {
        content: '';
        position: absolute;
        bottom: calc(100% + 2px);
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: #1C274C;
        z-index: 100001;
        pointer-events: none;
      }
      
      .vocab-word-popup-button svg {
        width: 20px;
        height: 20px;
        pointer-events: none;
        transition: stroke 0.2s ease;
      }
      
      .vocab-word-popup-button:hover:not(.loading) {
        background: #E9D5FF;
      }
      
      .vocab-word-popup-button:hover:not(.loading) svg path {
        stroke: #A020F0;
      }
      
      .vocab-word-popup-button:active:not(.loading) {
        transform: scale(0.9);
      }
      
      .vocab-word-popup-button.loading {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      .vocab-word-popup-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      /* Web Search Modal */
      .word-web-search-modal {
        position: absolute !important;
        background: white !important;
        border-radius: 30px;
        box-shadow: 0 8px 32px rgba(149, 39, 245, 0.2), 0 2px 8px rgba(149, 39, 245, 0.15) !important;
        z-index: 10000020 !important;
        max-width: 600px !important;
        width: 90vw !important;
        max-height: 49vh !important; /* Reduced to 70% of original 70vh */
        display: flex !important;
        flex-direction: column !important;
        opacity: 1 !important;
        transform: scale(1) !important;
        transition: opacity 0.2s ease, transform 0.2s ease;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
        visibility: visible !important;
        pointer-events: all !important;
        overflow: hidden !important;
      }
      
      .word-web-search-modal.dragging {
        cursor: grabbing !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }
      
      .word-web-search-modal.visible {
        opacity: 1 !important;
        transform: scale(1) !important;
      }
      
      /* Ask AI modal opening animation - smooth fade + scale in */
      .word-web-search-modal.ask-ai-opening {
        animation: askAIModalOpen 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        transition: none !important;
        pointer-events: none !important;
        will-change: transform, opacity !important;
        z-index: 10000020 !important;
      }
      
      .word-web-search-modal.ask-ai-opening.visible {
        animation: askAIModalOpen 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        transition: none !important;
      }
      
      @keyframes askAIModalOpen {
        0% {
          transform: scale(0.8) !important;
          opacity: 0 !important;
        }
        100% {
          transform: scale(1) !important;
          opacity: 1 !important;
        }
      }
      
      /* Ask AI modal closing animation - smooth fade + scale out */
      .word-web-search-modal.ask-ai-closing {
        animation: askAIModalClose 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        transition: none !important;
        pointer-events: none !important;
        will-change: transform, opacity !important;
        z-index: 10000020 !important;
      }
      
      @keyframes askAIModalClose {
        0% {
          transform: scale(1) !important;
          opacity: 1 !important;
        }
        100% {
          transform: scale(0.8) !important;
          opacity: 0 !important;
        }
      }
      
      .word-ask-ai-modal-content {
        display: flex;
        flex-direction: column;
        padding: 20px 0 10px 0;
        height: 100%;
        max-height: 49vh; /* Reduced to 70% of original 70vh */
        border-radius: 30px;
        position: relative;
        box-sizing: border-box !important;
        overflow: hidden !important;
        /* Disable text selection in the modal */
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }
      
      /* Disable text selection for all elements inside the modal */
      .word-web-search-modal * {
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }
      
      /* Ensure all SVG elements are visible and properly rendered */
      .word-web-search-modal svg,
      .word-web-search-send-btn svg,
      .word-web-search-explain-btn svg {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        position: relative !important;
        overflow: visible !important;
        pointer-events: auto !important;
      }
      
      .word-web-search-modal svg * {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Re-enable text selection for input and textarea */
      .word-web-search-modal input,
      .word-web-search-modal textarea {
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }
      
      /* Prevent double-click text selection */
      .word-web-search-modal {
        -webkit-touch-callout: none !important;
        -webkit-user-select: none !important;
        -khtml-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
      }
      
      /* Re-enable for input fields */
      .word-web-search-modal .word-web-search-input {
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }
      
      .word-web-search-modal-header {
        display: flex;
        justify-content: flex-start;
        padding: 12px 16px;
        border-bottom: none;
        cursor: default;
      }
      
      /* Header area should show move cursor, but close button should show pointer */
      .word-web-search-modal-header .word-web-search-modal-close {
        cursor: pointer !important;
      }
      
      /* Chat content areas should NOT show move cursor */
      .word-web-search-results,
      .word-web-search-results-list,
      .word-web-search-input-area,
      .word-web-search-chat-message,
      .word-web-search-chat-response-text {
        cursor: default !important;
      }
      
      /* Reset cursor for interactive elements */
      .word-web-search-modal input,
      .word-web-search-modal textarea {
        cursor: text !important;
      }
      
      .word-web-search-modal button,
      .word-web-search-modal a {
        cursor: pointer !important;
      }
      
      .word-web-search-modal .word-web-search-send-btn,
      .word-web-search-modal .word-web-search-delete-btn,
      .word-web-search-modal .word-web-search-modal-close {
        cursor: pointer !important;
      }
      
      .word-web-search-modal-close {
        width: 28px;
        height: 28px;
        border: none;
        background: transparent;
        font-size: 24px;
        color: #A020F0;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s ease;
      }
      
      .word-web-search-modal-close:hover {
        background: rgba(160, 32, 240, 0.1);
      }
      
      .word-web-search-results {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        min-height: 0;
        position: relative;
      }
      
      /* Fade-out effect at top and bottom using pseudo-elements - REMOVED */
      .word-ask-ai-modal-content::before,
      .word-ask-ai-modal-content::after {
        display: none !important;
      }
      
      .word-web-search-loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        gap: 16px;
      }
      
      .word-web-search-loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid #f3f4f6;
        border-top-color: #A020F0;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      .word-web-search-loading-text {
        color: #6b7280;
        font-size: 14px;
      }
      
      .word-web-search-metadata {
        padding: 8px 0;
        margin-bottom: 16px;
        color: #6b7280;
        font-size: 14px;
        border-bottom: none;
      }
      
      .word-web-search-metadata-text {
        color: #6b7280;
      }
      
      .word-web-search-results-list {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }
      
      .word-web-search-result-item {
        padding: 12px 0;
        border-bottom: 1px solid #f3f4f6;
      }
      
      .word-web-search-result-item:last-child {
        border-bottom: none;
      }
      
      .word-web-search-result-content {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .word-web-search-result-image-container {
        float: right;
        margin-left: 16px;
        margin-bottom: 8px;
      }
      
      .word-web-search-result-image {
        width: 120px;
        height: auto;
        border-radius: 8px;
        object-fit: cover;
      }
      
      .word-web-search-result-title {
        font-size: 18px;
        font-weight: 400;
        color: #1a0dab;
        text-decoration: none;
        line-height: 1.3;
        cursor: pointer;
      }
      
      .word-web-search-result-title:hover {
        text-decoration: underline;
      }
      
      .word-web-search-result-link {
        font-size: 14px;
        color: #006621;
        line-height: 1.3;
      }
      
      .word-web-search-result-snippet {
        font-size: 14px;
        color: #545454;
        line-height: 1.5;
        margin-top: 4px;
      }
      
      .word-web-search-no-results,
      .word-web-search-error {
        padding: 40px 20px;
        text-align: center;
        color: #6b7280;
        font-size: 14px;
      }
      
      .word-web-search-error {
        color: #ef4444;
      }
      
      /* Chat messages in web search modal - matching vocab-chat-message-content styles */
      .word-web-search-chat-message {
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.5;
        max-width: 85%;
        word-wrap: break-word;
        white-space: pre-wrap;
        margin-bottom: 12px;
      }
      
      .word-web-search-chat-message.user-message {
        background: #f3e8ff;
        color: #374151;
        align-self: flex-end;
        margin-left: auto;
      }
      
      .word-web-search-chat-message.ai-message {
        padding: 16px;
        background: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        line-height: 1.6;
        color: #374151;
        word-wrap: break-word;
        overflow-wrap: break-word;
        box-shadow: none;
        max-width: none;
        width: auto;
        align-self: flex-start;
      }
      
      .word-web-search-chat-response-text {
        line-height: 1.6;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      
      /* Markdown Styling in AI Messages - matching vocab-chat styles */
      .word-web-search-chat-message.ai-message code {
        background: #f3f4f6;
        color: #9527F5;
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'Courier New', Courier, monospace;
        font-size: 13px;
      }
      
      .word-web-search-chat-message.ai-message pre {
        background: #f3f4f6;
        padding: 12px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 8px 0;
      }
      
      .word-web-search-chat-message.ai-message pre code {
        background: transparent;
        padding: 0;
        font-size: 12px;
        line-height: 1.5;
      }
      
      .word-web-search-chat-message.ai-message p {
        margin: 0 0 12px 0;
      }
      
      .word-web-search-chat-message.ai-message p:last-child {
        margin-bottom: 0;
      }
      
      .word-web-search-chat-message.ai-message strong {
        font-weight: 600;
        color: #1f2937;
      }
      
      .word-web-search-chat-message.ai-message em {
        font-style: italic;
      }
      
      .word-web-search-chat-message.ai-message a {
        color: #9527F5;
        text-decoration: underline;
      }
      
      .word-web-search-chat-message.ai-message a:hover {
        color: #7a1fd9;
      }
      
      .word-web-search-chat-message.ai-message h1,
      .word-web-search-chat-message.ai-message h2,
      .word-web-search-chat-message.ai-message h3 {
        font-weight: 600;
        margin: 8px 0;
        color: #1f2937;
      }
      
      .word-web-search-chat-message.ai-message h1 {
        font-size: 18px;
      }
      
      .word-web-search-chat-message.ai-message h2 {
        font-size: 16px;
      }
      
      .word-web-search-chat-message.ai-message h3 {
        font-size: 15px;
      }
      
      .word-web-search-chat-message.ai-message ul {
        margin: 8px 0;
        padding-left: 20px;
      }
      
      .word-web-search-chat-message.ai-message li {
        margin: 4px 0;
      }
      
      /* Input area */
      .word-web-search-input-area {
        display: flex;
        gap: 8px;
        padding: 16px;
        // border-top: 1px solid #e5e7eb;
        background: white;
        align-items: center;
        position: relative; /* Enable absolute positioning for explain button */
      }
      
      .word-web-search-input {
        flex: 1;
        padding: 10px 12px !important;
        border: 1px solid #e5e7eb !important;
        border-radius: 15px !important;
        font-size: 14px !important;
        font-family: inherit !important;
        resize: none !important;
        outline: none !important;
        transition: border-color 0.2s ease !important;
        min-height: 40px !important;
        max-height: 120px !important;
        color: #1f2937 !important;
        caret-color: #9527F5 !important;
        background-color: white !important;
        box-sizing: border-box !important;
      }
      
      .word-web-search-input:focus {
        border-color: #9527F5;
        color: #1f2937 !important;
        caret-color: #9527F5 !important;
      }
      
      .word-web-search-input::placeholder {
        color: #9ca3af !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      .word-web-search-input::-webkit-input-placeholder {
        color: #9ca3af !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      .word-web-search-input::-moz-placeholder {
        color: #9ca3af !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      .word-web-search-input:-ms-input-placeholder {
        color: #9ca3af !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      .word-web-search-explain-btn {
        padding: 8px 16px !important;
        background: #9527F5 !important;
        color: white !important;
        border: none !important;
        border-radius: 12px !important;
        font-size: 14px !important;
        font-weight: 500 !important;
        cursor: pointer !important;
        transition: transform 0.2s ease !important;
        flex-shrink: 0 !important;
        font-family: inherit !important;
        position: absolute !important;
        right: 65px !important; /* Shifted left to avoid overlapping text area border */
        top: 50% !important;
        transform: translateY(-50%) !important;
        z-index: 10 !important;
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.3) !important;
        width: auto !important;
        height: auto !important;
        min-width: auto !important;
        min-height: auto !important;
        max-width: none !important;
        max-height: none !important;
        white-space: nowrap !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        box-sizing: border-box !important;
      }
      
      .word-web-search-explain-btn:hover {
        transform: translateY(-50%) scale(1.05);
      }
      
      .word-web-search-explain-btn:active {
        transform: translateY(-50%) scale(0.98);
      }
      
      .word-web-search-send-btn {
        width: 30px !important;
        height: 30px !important;
        background: white !important;
        border: 2px solid #9527F5 !important;
        border-radius: 50% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        transition: all 0.2s ease !important;
        flex-shrink: 0 !important;
        position: relative !important;
        overflow: visible !important;
      }
      
      .word-web-search-send-btn svg {
        width: 20px !important;
        height: 20px !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        position: relative !important;
        flex-shrink: 0 !important;
        max-width: 20px !important;
        max-height: 20px !important;
        min-width: 20px !important;
        min-height: 20px !important;
      }
      
      .word-web-search-send-btn svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      .word-web-search-send-btn:hover {
        background: #f0e6ff;
        border-color: #7a1fd9;
        transform: translateY(-1px);
      }
      
      .word-web-search-send-btn:active {
        transform: translateY(0) scale(0.95);
      }
      
      .word-web-search-send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .word-web-search-delete-btn {
        width: 30px;
        height: 30px;
        background: white;
        border: 2px solid #ef4444;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }
      
      .word-web-search-delete-btn:hover {
        background: #fef2f2;
        border-color: #dc2626;
        transform: translateY(-1px);
      }
      
      .word-web-search-delete-btn:active {
        transform: translateY(0) scale(0.95);
      }
      
      /* Close button for popup */
      .vocab-word-popup-close {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 22px;
        height: 22px;
        border: none;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.8;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 10;
      }
      
      .vocab-word-popup-close:hover {
        opacity: 1;
        transform: scale(1.2);
      }
      
      .vocab-word-popup-close:active {
        transform: scale(0.9);
      }
      
      .vocab-word-popup-close svg {
        width: 16px;
        height: 16px;
      }
      
      /* Speaker icon for pronunciation - now in bottom container */
      .vocab-word-popup-speaker {
        position: relative;
        width: 28px;
        height: 28px;
        background: #9527F5;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        opacity: 1;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.3);
      }
      
      .vocab-word-popup-speaker:hover:not(.loading) {
        background: #7B1FA2;
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.4);
      }
      
      .vocab-word-popup-speaker:active:not(.loading) {
        transform: scale(0.95);
        background: #6A1B9A;
      }
      
      .vocab-word-popup-speaker.loading {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
      }
      
      .vocab-word-popup-speaker svg {
        width: 14px;
        height: 14px;
        pointer-events: none;
      }
      
      /* Bookmark icon button */
      .vocab-word-popup-bookmark {
        position: relative;
        width: 40px;
        height: 40px;
        background: none;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        opacity: 1;
        transition: background-color 0.2s ease, transform 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        padding: 0;
      }
      
      .vocab-word-popup-bookmark[title]:hover::after {
        content: attr(title);
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: #1C274C;
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        white-space: nowrap;
        z-index: 100000;
        pointer-events: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }
      
      .vocab-word-popup-bookmark[title]:hover::before {
        content: '';
        position: absolute;
        bottom: calc(100% + 2px);
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: #1C274C;
        z-index: 100001;
        pointer-events: none;
      }
      
      .vocab-word-popup-bookmark svg {
        width: 20px;
        height: 20px;
        pointer-events: none;
        transition: stroke 0.2s ease, fill 0.2s ease;
      }
      
      .vocab-word-popup-bookmark:hover {
        background: #E9D5FF;
      }
      
      .vocab-word-popup-bookmark:hover:not(.bookmarked) svg path {
        stroke: #A020F0;
      }
      
      .vocab-word-popup-bookmark:active {
        transform: scale(0.9);
      }
      
      .vocab-word-popup-bookmark.bookmarked {
        background: none;
      }
      
      .vocab-word-popup-bookmark.bookmarked svg path {
        stroke: #A020F0;
        fill: #A020F0;
      }
      
      .vocab-word-popup-bookmark.bookmarked:hover {
        background: #E9D5FF;
      }
      
      .vocab-word-popup-bookmark.bookmarked:hover svg path {
        stroke: #A020F0;
        fill: #A020F0;
      }
      
      /* Loading spinner animation */
      .vocab-loading-spinner {
        animation: vocab-spin 1s linear infinite;
      }
      
      @keyframes vocab-spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      
      /* Error banner */
      .vocab-error-banner {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fee2e2;
        color: #dc2626;
        border: 1px solid #dc2626;
        border-radius: 8px;
        box-shadow: none;
        z-index: 1000000;
        opacity: 0;
        transform: translateX(100%);
        transition: opacity 0.3s ease, transform 0.3s ease;
        max-width: 400px;
      }
      
      .vocab-error-banner.visible {
        opacity: 1;
        transform: translateX(0);
      }
      
      .vocab-error-content {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        gap: 8px;
      }
      
      .vocab-error-icon {
        font-size: 16px;
        flex-shrink: 0;
      }
      
      .vocab-error-message {
        flex: 1;
        font-size: 14px;
        font-weight: 500;
        line-height: 1.4;
      }
      
      .vocab-error-close {
        background: none;
        border: none;
        color: #dc2626;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s ease, transform 0.2s ease;
        flex-shrink: 0;
      }
      
      .vocab-error-close:hover {
        background: rgba(220, 38, 38, 0.2);
      }
    `;
    
    document.head.appendChild(style);
  }
};

// ===================================
// Text Selector Module - Handles text selection and highlighting
// ===================================
const TextSelector = {
  // Use Set for O(1) insertion, deletion, and lookup
  selectedTexts: new Set(),
  
  // Map to store text -> highlight element
  textToHighlights: new Map(),
  
  // Map to store textKey -> {textStartIndex, textLength, text, range}
  textPositions: new Map(),
  
  // Map to store ranges for textKeys that haven't been highlighted yet (button shown but no span)
  pendingRanges: new Map(),
  
  // Map to store button wrappers for pending selections (before span is created)
  buttonWrappers: new Map(),
  
  // Container for texts that have been asked (moved from selectedTexts)
  askedTexts: new Map(), // Map of textKey -> {text, textKey, highlight, simplifiedText}
  
  // Container for simplified texts metadata
  simplifiedTexts: new Map(), // Map of textKey -> {textStartIndex, textLength, text, simplifiedText, previousSimplifiedTexts: Array, shouldAllowSimplifyMore}
  
  // Track if the feature is enabled
  isEnabled: false,
  
  // Counter for generating unique IDs
  highlightIdCounter: 0,
  
  // Store bound handler for proper cleanup
  boundMouseUpHandler: null,
  
  // Inline purple logo SVG content (no fetch needed)
  purpleLogoSvgContent: `<svg xmlns="http://www.w3.org/2000/svg" width="293" height="277" viewBox="0 0 293 277"><g><path d="M 186.57 204.25 C187.92,206.31 188.69,207.96 188.26,207.91 C187.84,207.85 184.19,205.88 180.15,203.51 C161.17,192.42 147.56,192.19 128.25,202.64 C123.71,205.10 120.00,206.74 119.99,206.30 C119.99,205.86 122.22,201.00 124.95,195.50 C134.11,177.05 134.05,168.68 124.63,149.75 C121.69,143.84 119.51,139.00 119.80,139.00 C120.08,139.00 125.31,141.46 131.41,144.46 C145.26,151.27 150.99,152.43 160.47,150.30 C168.62,148.48 173.88,146.34 182.13,141.50 C185.42,139.58 188.26,138.00 188.46,138.00 C188.65,138.00 186.82,141.49 184.38,145.75 C173.12,165.50 172.39,176.08 181.04,194.11 C182.73,197.63 185.21,202.19 186.57,204.25 ZM 126.41 199.85 C127.40,201.46 128.35,201.30 131.27,199.00 C132.67,197.90 134.53,197.00 135.41,197.00 C136.28,197.00 137.00,196.60 137.00,196.11 C137.00,193.77 161.30,192.53 167.00,194.57 C170.73,195.91 174.93,196.94 176.39,196.87 C176.88,196.85 177.63,197.41 178.07,198.11 C180.06,201.34 177.37,189.80 174.78,184.02 C172.34,178.57 171.98,176.74 172.51,172.52 C173.45,165.02 175.89,155.79 177.39,154.04 C179.16,151.98 179.94,148.52 178.98,146.96 C178.39,146.01 176.88,146.44 172.80,148.74 C168.46,151.19 165.76,151.92 158.95,152.45 C154.27,152.82 148.49,152.67 146.00,152.13 C136.90,150.13 132.44,148.63 130.06,146.80 C127.93,145.15 127.52,145.11 126.77,146.44 C126.20,147.47 126.81,149.54 128.61,152.73 C131.43,157.71 131.80,159.51 132.64,172.24 C133.06,178.62 132.77,181.01 130.97,185.74 C129.78,188.91 128.84,192.58 128.90,193.89 C128.95,195.20 128.26,196.82 127.35,197.49 C126.44,198.15 126.01,199.21 126.41,199.85 ZM 150.15 242.32 C147.37,244.57 121.03,243.49 112.82,240.78 C105.12,238.24 93.05,229.53 89.27,223.79 C80.49,210.46 78.00,195.19 81.57,176.50 C82.40,172.10 83.30,167.15 83.55,165.50 C83.80,163.84 85.12,161.68 86.50,160.67 C88.18,159.43 89.00,157.87 89.00,155.89 C89.00,154.04 90.08,151.75 91.93,149.72 C96.79,144.37 100.91,138.25 100.18,137.44 C99.81,137.02 100.02,136.98 100.66,137.34 C101.35,137.74 102.96,136.18 104.66,133.47 C106.22,130.98 108.52,128.68 109.77,128.36 C111.01,128.04 112.92,126.64 114.02,125.25 C115.11,123.87 116.00,123.03 116.00,123.40 C116.00,124.15 117.85,122.76 121.85,119.00 C123.31,117.63 125.40,116.01 126.50,115.40 C134.97,110.72 138.51,109.00 141.76,107.99 C143.82,107.35 146.92,106.19 148.65,105.41 C150.38,104.64 153.08,103.99 154.65,103.99 C156.22,103.98 159.86,103.35 162.75,102.58 C165.65,101.81 168.80,101.33 169.75,101.51 C170.71,101.70 171.84,101.88 172.25,101.92 C172.66,101.97 173.00,102.38 173.00,102.85 C173.00,103.32 169.74,103.99 165.75,104.34 C129.65,107.47 93.23,139.14 84.01,175.41 C81.65,184.69 81.35,198.99 83.36,206.50 C87.73,222.85 102.75,236.93 119.65,240.51 C146.77,246.26 177.44,234.65 200.50,209.90 C228.52,179.84 232.86,139.22 210.34,117.88 C202.12,110.07 195.47,106.92 182.00,104.43 L 175.50 103.22 L 181.07 103.11 C189.32,102.95 200.71,106.97 206.25,112.00 C207.77,113.38 209.20,114.28 209.43,114.00 C209.67,113.72 210.92,115.07 212.21,117.00 C213.49,118.93 215.55,120.94 216.77,121.49 C218.16,122.10 219.23,123.70 219.61,125.74 C219.95,127.53 220.55,129.00 220.96,129.00 C221.36,129.00 222.93,134.00 224.44,140.11 C226.74,149.43 227.07,152.36 226.48,158.36 C226.10,162.29 225.14,167.30 224.36,169.50 C223.58,171.70 222.68,175.52 222.36,178.00 C222.04,180.48 221.18,183.18 220.46,184.00 C219.74,184.82 217.76,188.29 216.07,191.69 C214.39,195.09 212.54,198.17 211.96,198.52 C211.39,198.88 209.80,200.94 208.44,203.10 C205.21,208.21 194.10,219.30 186.50,225.00 C183.20,227.47 180.27,229.72 180.00,230.00 C178.26,231.75 163.42,238.20 158.00,239.57 C154.43,240.48 150.89,241.71 150.15,242.32 ZM 173.96 258.56 C165.33,260.73 160.70,261.25 147.50,261.52 C147.11,261.53 146.72,261.54 146.35,261.54 C137.70,261.72 133.80,261.81 129.96,261.38 C126.63,261.01 123.35,260.26 117.06,258.86 C105.19,256.23 96.80,253.10 86.03,247.31 C63.46,235.16 43.99,215.04 33.82,193.35 C31.72,188.87 30.00,184.88 30.00,184.48 C30.00,182.36 33.11,186.88 36.03,193.25 C38.93,199.57 42.32,205.39 44.03,207.00 C44.33,207.27 46.23,210.04 48.27,213.14 C55.35,223.96 69.06,236.14 81.00,242.24 C84.03,243.78 88.30,246.15 90.50,247.51 C92.70,248.86 95.42,249.97 96.55,249.98 C97.68,249.99 99.03,250.39 99.55,250.87 C100.07,251.35 102.75,252.52 105.50,253.47 C108.25,254.43 111.40,255.56 112.50,255.98 C118.27,258.21 126.62,259.24 139.35,259.29 C153.54,259.35 171.76,257.71 175.50,256.02 C179.32,254.31 192.84,250.00 194.42,250.00 C195.29,250.00 196.00,249.55 196.00,249.00 C196.00,248.45 196.83,248.00 197.85,248.00 C198.86,248.00 200.73,247.10 202.00,246.00 C203.27,244.90 204.70,244.00 205.17,244.00 C206.01,244.00 213.99,239.10 215.00,237.96 C215.27,237.65 217.22,236.10 219.32,234.53 C228.30,227.78 245.00,209.40 245.00,206.25 C245.00,204.64 251.67,198.34 252.50,199.17 C253.55,200.22 240.48,217.65 233.06,225.08 C215.89,242.28 197.68,252.60 173.96,258.56 ZM 264.62 165.64 C263.82,169.41 262.71,173.62 262.15,175.00 C261.24,177.23 261.12,176.99 261.06,172.81 C261.03,170.23 261.48,167.82 262.06,167.46 C262.66,167.09 262.85,165.57 262.48,163.93 C262.07,162.05 262.40,160.27 263.43,158.80 C264.67,157.02 265.00,153.70 265.00,142.84 C265.00,134.77 264.59,128.86 264.00,128.50 C263.45,128.16 263.00,126.14 263.00,124.00 C263.00,121.86 262.55,119.84 262.00,119.50 C261.45,119.16 261.00,117.52 261.00,115.86 C261.00,112.50 257.53,103.11 252.35,92.50 C247.05,81.61 244.24,77.38 239.61,73.29 C237.25,71.20 234.75,68.38 234.06,67.00 C232.48,63.87 223.27,55.00 221.61,55.00 C220.93,55.00 219.05,53.59 217.44,51.87 C215.82,50.16 211.84,47.47 208.58,45.92 C205.33,44.36 202.41,42.67 202.08,42.17 C201.31,40.97 191.42,36.00 189.78,35.99 C189.08,35.99 187.15,35.27 185.50,34.39 C183.85,33.51 179.35,32.19 175.50,31.45 C171.65,30.72 166.70,29.56 164.50,28.88 C162.30,28.21 153.30,27.38 144.50,27.03 L 128.50 26.40 L 143.64 26.20 C165.93,25.90 183.58,29.87 202.17,39.36 C234.18,55.70 257.14,85.95 264.46,121.47 C266.58,131.70 266.66,156.00 264.62,165.64 ZM 37.96 88.90 C37.90,91.26 34.52,97.19 33.71,96.37 C32.72,95.39 40.21,81.82 46.19,73.75 C52.52,65.20 65.30,53.27 75.00,46.84 C83.17,41.43 98.17,33.91 104.51,32.06 C114.11,29.25 118.82,28.14 123.50,27.58 L 128.50 26.98 L 123.50 28.56 C120.75,29.43 117.03,30.39 115.24,30.68 C113.45,30.98 111.73,31.62 111.43,32.11 C111.13,32.60 109.59,33.00 108.00,33.00 C106.41,33.00 104.86,33.42 104.55,33.92 C104.23,34.43 102.74,35.12 101.23,35.45 C96.02,36.59 74.10,48.76 70.18,52.68 C69.43,53.43 67.62,54.67 66.16,55.44 C63.21,56.98 55.00,65.29 55.00,66.73 C55.00,67.23 53.09,69.47 50.75,71.71 C45.30,76.93 42.00,81.00 42.00,82.50 C42.00,83.16 41.10,84.50 40.00,85.50 C38.90,86.50 37.98,88.03 37.96,88.90 ZM 27.43 168.50 C27.71,170.15 27.59,172.05 27.17,172.73 C25.56,175.33 22.99,157.67 23.00,144.00 C23.00,129.27 24.51,119.30 28.55,107.25 C31.64,98.05 32.92,95.52 32.97,98.56 C32.99,99.69 32.34,101.49 31.53,102.56 C30.72,103.63 30.05,105.75 30.03,107.29 C30.01,108.82 29.38,111.07 28.62,112.29 C27.86,113.50 27.19,116.44 27.13,118.81 C27.06,121.17 26.57,123.94 26.02,124.96 C24.28,128.22 24.53,157.64 26.36,163.63 C26.67,164.66 27.15,166.85 27.43,168.50 ZM 28.98 176.97 C29.61,178.14 29.98,180.06 29.81,181.23 C29.57,182.90 29.22,182.56 28.16,179.60 C26.66,175.42 27.21,173.66 28.98,176.97 Z" fill="rgb(135,89,231)"/><path d="M 264.62 165.64 C264.71,165.24 264.79,164.81 264.86,164.36 C264.03,170.01 262.75,174.56 260.94,178.50 C258.97,182.82 253.81,195.61 253.28,197.50 C253.15,197.99 252.90,198.61 252.56,199.31 C252.55,199.25 252.53,199.20 252.50,199.17 C251.67,198.34 245.00,204.64 245.00,206.25 C245.00,209.40 228.30,227.78 219.32,234.53 C217.22,236.10 215.27,237.65 215.00,237.96 C213.99,239.10 206.01,244.00 205.17,244.00 C204.70,244.00 203.27,244.90 202.00,246.00 C200.73,247.10 198.86,248.00 197.85,248.00 C196.83,248.00 196.00,248.45 196.00,249.00 C196.00,249.55 195.29,250.00 194.42,250.00 C192.84,250.00 179.32,254.31 175.50,256.02 C171.76,257.71 153.54,259.35 139.35,259.29 C126.62,259.24 118.27,258.21 112.50,255.98 C111.40,255.56 108.25,254.43 105.50,253.47 C102.75,252.52 100.07,251.35 99.55,250.87 C99.03,250.39 97.68,249.99 96.55,249.98 C95.42,249.97 92.70,248.86 90.50,247.51 C88.30,246.15 84.03,243.78 81.00,242.24 C69.06,236.14 55.35,223.96 48.27,213.14 C46.23,210.04 44.33,207.27 44.03,207.00 C42.32,205.39 38.93,199.57 36.03,193.25 C33.11,186.88 30.00,182.36 30.00,184.48 C30.00,184.50 30.00,184.52 30.01,184.55 C29.67,183.62 29.33,182.67 29.01,181.72 C29.44,182.56 29.65,182.34 29.81,181.23 C29.98,180.06 29.61,178.14 28.98,176.97 C27.81,174.78 27.18,174.81 27.31,176.28 C26.94,174.99 26.58,173.67 26.24,172.34 C26.57,173.02 26.88,173.19 27.17,172.73 C27.59,172.05 27.71,170.15 27.43,168.50 C27.15,166.85 26.67,164.66 26.36,163.63 C24.53,157.64 24.28,128.22 26.02,124.96 C26.57,123.94 27.06,121.17 27.13,118.81 C27.19,116.44 27.86,113.50 28.62,112.29 C29.38,111.07 30.01,108.82 30.03,107.29 C30.05,105.75 30.72,103.63 31.53,102.56 C32.34,101.49 32.99,99.69 32.97,98.56 C32.95,97.29 32.72,96.99 32.22,97.75 C34.88,91.68 38.05,85.87 41.69,80.37 C37.06,87.69 32.96,95.63 33.71,96.37 C34.52,97.19 37.90,91.26 37.96,88.90 C37.98,88.03 38.90,86.50 40.00,85.50 C41.10,84.50 42.00,83.16 42.00,82.50 C42.00,81.00 45.30,76.93 50.75,71.71 C53.09,69.47 55.00,67.23 55.00,66.73 C55.00,65.29 63.21,56.98 66.16,55.44 C67.62,54.67 69.43,53.43 70.18,52.68 C74.10,48.76 96.02,36.59 101.23,35.45 C102.74,35.12 104.23,34.43 104.55,33.92 C104.86,33.42 106.41,33.00 108.00,33.00 C109.59,33.00 111.13,32.60 111.43,32.11 C111.73,31.62 113.45,30.98 115.24,30.68 C117.03,30.39 120.75,29.43 123.50,28.56 L 128.50 26.98 L 123.50 27.58 C122.86,27.66 122.21,27.74 121.55,27.85 C122.18,27.72 122.83,27.60 123.50,27.48 C125.71,27.07 128.41,26.75 131.39,26.52 L 144.50 27.03 C153.30,27.38 162.30,28.21 164.50,28.88 C166.70,29.56 171.65,30.72 175.50,31.45 C179.35,32.19 183.85,33.51 185.50,34.39 C187.15,35.27 189.08,35.99 189.78,35.99 C191.42,36.00 201.31,40.97 202.08,42.17 C202.41,42.67 205.33,44.36 208.58,45.92 C211.84,47.47 215.82,50.16 217.44,51.87 C219.05,53.59 220.93,55.00 221.61,55.00 C223.27,55.00 232.48,63.87 234.06,67.00 C234.75,68.38 237.25,71.20 239.61,73.29 C244.24,77.38 247.05,81.61 252.35,92.50 C257.53,103.11 261.00,112.50 261.00,115.86 C261.00,117.52 261.45,119.16 262.00,119.50 C262.55,119.84 263.00,121.86 263.00,124.00 C263.00,126.14 263.45,128.16 264.00,128.50 C264.59,128.86 265.00,134.77 265.00,142.84 C265.00,153.70 264.67,157.02 263.43,158.80 C262.40,160.27 262.07,162.05 262.48,163.93 C262.85,165.57 262.66,167.09 262.06,167.46 C261.48,167.82 261.03,170.23 261.06,172.81 C261.12,176.99 261.24,177.23 262.15,175.00 C262.71,173.62 263.82,169.41 264.62,165.64 ZM 150.15 242.32 C150.89,241.71 154.43,240.48 158.00,239.57 C163.42,238.20 178.26,231.75 180.00,230.00 C180.27,229.72 183.20,227.47 186.50,225.00 C194.10,219.30 205.21,208.21 208.44,203.10 C209.80,200.94 211.39,198.88 211.96,198.52 C212.54,198.17 214.39,195.09 216.07,191.69 C217.76,188.29 219.74,184.82 220.46,184.00 C221.18,183.18 222.04,180.48 222.36,178.00 C222.68,175.52 223.58,171.70 224.36,169.50 C225.14,167.30 226.10,162.29 226.48,158.36 C227.07,152.36 226.74,149.43 224.44,140.11 C222.93,134.00 221.36,129.00 220.96,129.00 C220.55,129.00 219.95,127.53 219.61,125.74 C219.23,123.70 218.16,122.10 216.77,121.49 C215.55,120.94 213.49,118.93 212.21,117.00 C210.92,115.07 209.67,113.72 209.43,114.00 C209.20,114.28 207.77,113.38 206.25,112.00 C200.71,106.97 189.32,102.95 181.07,103.11 L 175.50 103.22 L 182.00 104.43 C183.55,104.71 185.01,105.01 186.39,105.32 C179.01,104.15 167.70,104.10 159.37,105.18 C161.49,104.80 163.62,104.52 165.75,104.34 C169.74,103.99 173.00,103.32 173.00,102.85 C173.00,102.38 172.66,101.97 172.25,101.92 C171.84,101.88 170.71,101.70 169.75,101.51 C168.80,101.33 165.65,101.81 162.75,102.58 C159.86,103.35 156.22,103.98 154.65,103.99 C153.08,103.99 150.38,104.64 148.65,105.41 C146.92,106.19 143.82,107.35 141.76,107.99 C138.51,109.00 134.97,110.72 126.50,115.40 C125.40,116.01 123.31,117.63 121.85,119.00 C117.85,122.76 116.00,124.15 116.00,123.40 C116.00,123.03 115.11,123.87 114.02,125.25 C112.92,126.64 111.01,128.04 109.77,128.36 C108.52,128.68 106.22,130.98 104.66,133.47 C102.96,136.18 101.35,137.74 100.66,137.34 C100.02,136.98 99.81,137.02 100.18,137.44 C100.91,138.25 96.79,144.37 91.93,149.72 C90.08,151.75 89.00,154.04 89.00,155.89 C89.00,157.87 88.18,159.43 86.50,160.67 C85.12,161.68 83.80,163.84 83.55,165.50 C83.30,167.15 82.40,172.10 81.57,176.50 C78.00,195.19 80.49,210.46 89.27,223.79 C93.05,229.53 105.12,238.24 112.82,240.78 C121.03,243.49 147.37,244.57 150.15,242.32 ZM 126.41 199.85 C126.01,199.21 126.44,198.15 127.35,197.49 C128.26,196.82 128.95,195.20 128.90,193.89 C128.84,192.58 129.78,188.91 130.97,185.74 C132.77,181.01 133.06,178.62 132.64,172.24 C131.80,159.51 131.43,157.71 128.61,152.73 C126.81,149.54 126.20,147.47 126.77,146.44 C127.52,145.11 127.93,145.15 130.06,146.80 C132.44,148.63 136.90,150.13 146.00,152.13 C148.49,152.67 154.27,152.82 158.95,152.45 C165.76,151.92 168.46,151.19 172.80,148.74 C176.88,146.44 178.39,146.01 178.98,146.96 C179.94,148.52 179.16,151.98 177.39,154.04 C175.89,155.79 173.45,165.02 172.51,172.52 C171.98,176.74 172.34,178.57 174.78,184.02 C177.37,189.80 180.06,201.34 178.07,198.11 C177.63,197.41 176.88,196.85 176.39,196.87 C174.93,196.94 170.73,195.91 167.00,194.57 C161.30,192.53 137.00,193.77 137.00,196.11 C137.00,196.60 136.28,197.00 135.41,197.00 C134.53,197.00 132.67,197.90 131.27,199.00 C128.35,201.30 127.40,201.46 126.41,199.85 ZM 172.63 28.75 C163.61,26.87 154.14,26.06 143.64,26.20 L 134.16 26.33 C145.30,25.68 159.32,26.10 167.14,27.58 C168.97,27.93 170.80,28.32 172.63,28.75 ZM 228.50 57.72 C221.32,51.08 213.28,45.32 204.53,40.60 C209.11,43.00 213.43,45.63 217.36,48.44 C221.09,51.10 224.85,54.25 228.50,57.72 ZM 60.38 228.90 C68.13,236.07 76.82,242.35 86.03,247.31 C87.96,248.35 89.81,249.30 91.62,250.18 C80.11,244.77 69.53,237.58 60.38,228.90 ZM 26.16 115.27 C23.90,124.10 23.00,132.63 23.00,144.00 C22.99,150.47 23.57,157.83 24.34,163.52 C22.49,151.60 22.48,133.21 24.49,122.70 C24.97,120.19 25.53,117.71 26.16,115.27 ZM 84.01 175.41 C85.99,167.64 89.21,160.08 93.41,152.96 C87.65,162.81 83.83,173.43 82.52,184.14 C82.85,181.01 83.35,178.01 84.01,175.41 ZM 264.29 120.66 C262.80,113.67 260.70,106.89 258.05,100.38 C261.04,107.51 263.04,113.90 264.29,120.66 ZM 140.00 241.68 C161.31,239.75 183.14,228.53 200.50,209.90 C183.07,228.60 161.30,239.80 140.00,241.68 ZM 30.80 186.63 C31.50,188.30 32.60,190.74 33.82,193.35 C35.68,197.31 37.84,201.22 40.28,205.03 C36.45,199.16 33.35,193.13 30.80,186.63 ZM 91.41 222.38 C92.45,223.67 93.60,224.97 94.85,226.28 C99.00,230.63 104.02,234.30 109.26,236.91 C102.33,233.53 96.13,228.46 91.41,222.38 ZM 82.03 194.28 C82.15,199.82 82.76,204.50 84.03,208.73 C83.78,207.99 83.56,207.25 83.36,206.50 C82.51,203.34 82.08,198.97 82.03,194.28 ZM 94.54 36.12 C90.34,38.10 85.69,40.51 81.54,42.86 C84.75,40.97 88.08,39.20 91.51,37.55 C92.56,37.05 93.57,36.57 94.54,36.12 ZM 114.43 29.32 C111.89,29.95 108.89,30.78 105.12,31.88 C108.01,30.92 111.00,30.10 114.43,29.32 ZM 233.07 225.08 C228.30,229.85 223.46,234.09 218.45,237.85 C223.46,234.09 228.30,229.85 233.06,225.08 C236.08,222.06 240.04,217.38 243.60,212.82 C240.17,217.29 236.36,221.78 233.07,225.08 ZM 254.48 92.46 C253.05,89.57 251.51,86.75 249.86,83.99 C251.59,86.83 253.14,89.65 254.46,92.41 ZM 193.87 107.42 C196.36,108.29 198.59,109.29 200.71,110.50 C198.70,109.38 196.50,108.41 193.87,107.42 ZM 64.30 55.05 C61.88,57.13 59.47,59.33 57.17,61.55 C59.45,59.30 61.83,57.13 64.30,55.05 ZM 266.06 140.25 C266.00,137.36 265.88,134.52 265.70,131.86 C265.90,134.52 266.01,137.30 266.06,140.25 ZM 28.81 106.47 C28.73,106.73 28.64,106.99 28.55,107.25 C28.10,108.59 27.68,109.91 27.29,111.20 C27.77,109.61 28.27,108.04 28.81,106.47 Z" fill="rgb(140,82,253)"/><path d="M 0.00 138.50 L 0.00 0.00 L 146.50 0.00 L 293.00 0.00 L 293.00 138.50 L 293.00 277.00 L 146.50 277.00 L 0.00 277.00 L 0.00 138.50 ZM 173.96 258.56 C197.68,252.60 215.88,242.29 233.07,225.08 C241.01,217.12 251.99,202.15 253.28,197.50 C253.81,195.61 258.97,182.82 260.94,178.50 C264.53,170.67 266.06,160.42 266.08,143.97 C266.12,123.24 263.37,111.03 254.46,92.41 C246.88,76.57 231.91,58.82 217.36,48.44 C203.63,38.64 185.29,31.03 167.14,27.58 C156.45,25.56 134.19,25.51 123.50,27.48 C109.20,30.12 102.77,32.14 91.51,37.55 C55.90,54.64 31.61,85.50 24.49,122.70 C22.26,134.39 22.52,155.82 25.03,167.26 C30.21,190.79 39.11,207.05 56.84,225.39 C72.90,242.02 94.01,253.75 117.06,258.86 C130.92,261.94 130.20,261.88 147.50,261.52 C160.70,261.25 165.33,260.73 173.96,258.56 ZM 119.18 240.47 C110.62,238.61 101.59,233.35 94.85,226.28 C85.39,216.36 82.03,207.51 82.01,192.41 C81.96,155.66 113.09,117.95 153.00,106.42 C162.24,103.75 183.26,103.73 191.00,106.39 C199.89,109.44 204.05,111.91 210.34,117.88 C232.86,139.22 228.52,179.84 200.50,209.90 C177.39,234.70 146.35,246.37 119.18,240.47 ZM 186.57 204.25 C185.21,202.19 182.73,197.63 181.04,194.11 C172.39,176.08 173.12,165.50 184.38,145.75 C186.82,141.49 188.65,138.00 188.46,138.00 C188.26,138.00 185.42,139.58 182.13,141.50 C173.88,146.34 168.62,148.48 160.47,150.30 C150.99,152.43 145.26,151.27 131.41,144.46 C125.31,141.46 120.08,139.00 119.80,139.00 C119.51,139.00 121.69,143.84 124.63,149.75 C134.05,168.68 134.11,177.05 124.95,195.50 C122.22,201.00 119.99,205.86 119.99,206.30 C120.00,206.74 123.71,205.10 128.25,202.64 C147.56,192.19 161.17,192.42 180.15,203.51 C184.19,205.88 187.84,207.85 188.26,207.91 C188.69,207.96 187.92,206.31 186.57,204.25 Z" fill="rgb(254,254,254)"/></g></svg>`,
  
  /**
   * Initialize text selector
   */
  async init() {
    console.log('[TextSelector] Initializing...');
    
    // SVG is now inline, no fetch needed
    console.log('[TextSelector] Purple logo SVG available inline');
    // Update any existing buttons
    this.updateAllMagicMeaningButtons();
    
    // Bind the handler once for proper cleanup
    this.boundMouseUpHandler = this.handleMouseUp.bind(this);
    
    // Inject styles for text highlights
    this.injectStyles();
    
    // Check if extension is enabled for current domain
    const isExtensionEnabled = await this.checkExtensionEnabled();
    
    if (isExtensionEnabled) {
      this.enable();
    }
    
    console.log('[TextSelector] Initialized. Enabled:', isExtensionEnabled);
  },
  
  /**
   * Check if extension is enabled from storage
   * @returns {Promise<boolean>}
   */
  async checkExtensionEnabled() {
    try {
      const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
      const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
      let isEnabled = result[GLOBAL_STORAGE_KEY];
      
      // If not found, create it and set to true (enabled by default)
      if (isEnabled === undefined) {
        isEnabled = true;
        await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: isEnabled });
        console.log('[TextSelector] Global toggle state not found, created with default value: true');
      }
      
      return isEnabled;
    } catch (error) {
      console.error('[TextSelector] Error checking global extension state:', error);
      return true; // Default to true (enabled) on error
    }
  },
  
  /**
   * Enable text selector
   */
  enable() {
    if (this.isEnabled) return;
    
    this.isEnabled = true;
    document.addEventListener('mouseup', this.boundMouseUpHandler);
    console.log('[TextSelector] Enabled');
  },
  
  /**
   * Disable text selector
   */
  disable() {
    if (!this.isEnabled) return;
    
    this.isEnabled = false;
    document.removeEventListener('mouseup', this.boundMouseUpHandler);
    console.log('[TextSelector] Disabled');
  },
  
  /**
   * Check if an element or range is within allowed selection areas
   * Allowed: Main website content and .vocab-custom-content-editor-content
   * Disallowed: All other extension UI components
   * @param {Element|Range} elementOrRange - The element or range to check
   * @returns {boolean} True if selection is allowed, false otherwise
   */
  isSelectionAllowed(elementOrRange) {
    // Get the container element from element or range
    let containerElement = null;
    
    if (elementOrRange instanceof Range) {
      // For range, check the common ancestor container
      containerElement = elementOrRange.commonAncestorContainer;
      // If it's a text node, get its parent
      if (containerElement && containerElement.nodeType === Node.TEXT_NODE) {
        containerElement = containerElement.parentElement;
      } else if (containerElement && containerElement.nodeType === Node.ELEMENT_NODE) {
        containerElement = containerElement;
      }
    } else if (elementOrRange instanceof Element) {
      containerElement = elementOrRange;
    } else if (elementOrRange instanceof Node) {
      // For other node types (like text nodes), get parent element
      if (elementOrRange.nodeType === Node.TEXT_NODE) {
        containerElement = elementOrRange.parentElement;
      } else if (elementOrRange.nodeType === Node.ELEMENT_NODE) {
        containerElement = elementOrRange;
      }
    }
    
    // Ensure we have an Element (not a Text node or null)
    if (!containerElement || !(containerElement instanceof Element)) {
      return false;
    }
    
    // First check: If inside .vocab-custom-content-editor-content, allow it
    // This is the exception - even though it's inside vocab-custom-content-modal,
    // we want to allow selection in the editor content
    const editorContent = containerElement.closest('.vocab-custom-content-editor-content');
    if (editorContent) {
      return true;
    }
    
    // Second check: If inside any extension UI component, disallow it
    // List of extension UI component selectors
    const extensionUISelectors = [
      '.vocab-helper-panel',
      '.vocab-topics-modal',
      '.vocab-topics-modal-overlay',
      '.vocab-chat-dialog',
      '.vocab-custom-content-modal',
      '.vocab-custom-content-info-banner',
      '.vocab-word-popup',
      '.vocab-notification'
    ];
    
    // Check if the container is inside any extension UI component
    for (const selector of extensionUISelectors) {
      if (containerElement.closest(selector)) {
        return false;
      }
    }
    
    // If not in extension UI and not in editor content, it's main website content - allow it
    return true;
  },
  
  /**
   * Handle mouse up event (after text selection)
   * @param {MouseEvent} event
   */
  handleMouseUp(event) {
    // CRITICAL: Check if feature is enabled
    if (!this.isEnabled) {
      return;
    }
    
    // Allow button clicks to proceed - don't interfere with button interactions
    if (event.target.closest('button') || event.target.tagName === 'BUTTON') {
      return;
    }
    
    // Check if clicking on existing highlights - allow interaction with them
    if (event.target.closest('.vocab-text-highlight') ||
        event.target.closest('.vocab-word-highlight')) {
      return;
    }
    
    // Check if selection is allowed in the clicked area
    if (!this.isSelectionAllowed(event.target)) {
      console.log('[TextSelector] Selection not allowed - clicked in extension UI');
      return;
    }
    
    // Small delay to ensure selection is complete
    setTimeout(() => {
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();
      
      // Check if text was selected
      if (!selectedText || selectedText.length === 0) {
        return;
      }
      
      // Must have at least one space (to differentiate from single words)
      // Or be longer than typical word length
      if (!(/\s/.test(selectedText)) && selectedText.length < 15) {
        return; // Let WordSelector handle single words
      }
      
      // Check if text has at least 3 words
      const wordCount = selectedText.split(/\s+/).filter(word => word.length > 0).length;
      if (wordCount < 3) {
        console.log('[TextSelector] Not enough words selected:', wordCount);
        this.showNotification("Select atleast 3 words");
        selection.removeAllRanges();
        return;
      }
      
      // Get the range and validate
      if (selection.rangeCount === 0) {
        return;
      }
      
      const range = selection.getRangeAt(0);
      
      // IMPORTANT: Also validate the selection range itself
      // This ensures the selected text is not from extension UI
      if (!this.isSelectionAllowed(range)) {
        console.log('[TextSelector] Selection not allowed - range is in extension UI');
        selection.removeAllRanges();
        return;
      }
      
      // Check if this exact text is already selected
      const textKey = this.getContextualTextKey(selectedText);
      if (this.selectedTexts.has(textKey)) {
        console.log('[TextSelector] Text already selected');
        selection.removeAllRanges();
        return;
      }
      
      // Check if the range overlaps with any existing highlight (text or words)
      if (this.hasOverlap(range)) {
        console.log('[TextSelector] Selection overlaps with existing highlight');
        this.showNotification("Can't select an already selected text");
        selection.removeAllRanges();
        return;
      }
      
      // Add text to selected set with range for position tracking (O(1) operation)
      this.addText(selectedText, range);
      
      // Capture mouse release coordinates for button positioning
      const mouseReleaseX = event.clientX;
      const mouseReleaseY = event.clientY;
      
      // Store the range for later use (when button is clicked)
      // Don't create span wrapper - just show the magic-meaning button
      this.showMagicMeaningButton(range, selectedText, textKey, { x: mouseReleaseX, y: mouseReleaseY });
      
      // IMPORTANT: Preserve Chrome's default selection (yellow background)
      // Do NOT clear the selection - let users copy the text
      // The selection will be cleared naturally when user clicks elsewhere (Chrome's default behavior)
      
      console.log('[TextSelector] Text selected:', selectedText.substring(0, 50) + '...');
      console.log('[TextSelector] Total selected texts:', this.selectedTexts.size);
      console.log('[TextSelector] Selection preserved - yellow background should remain visible');
    }, 10);
  },
  
  /**
   * Check if a range overlaps with any existing text highlights
   * (Word selections and text selections are independent)
   * @param {Range} range - The range to check
   * @returns {boolean} True if overlap detected
   */
  hasOverlap(range) {
    // Get all existing text highlight elements (only check text, not words)
    const existingTextHighlights = document.querySelectorAll('.vocab-text-highlight');
    
    for (const highlight of existingTextHighlights) {
      // Create a range for the existing highlight
      const highlightRange = document.createRange();
      try {
        highlightRange.selectNodeContents(highlight);
        
        // Check if ranges intersect
        // Ranges overlap if: (start1 < end2) AND (start2 < end1)
        const rangesIntersect = 
          range.compareBoundaryPoints(Range.START_TO_END, highlightRange) > 0 &&
          range.compareBoundaryPoints(Range.END_TO_START, highlightRange) < 0;
        
        if (rangesIntersect) {
          return true; // Overlap detected
        }
      } catch (error) {
        console.warn('[TextSelector] Error checking text highlight overlap:', error);
      }
    }
    
    return false; // No overlap
  },
  
  /**
   * Show notification banner at top right corner
   * @param {string} message - Message to display
   */
  showNotification(message) {
    // Check if notification already exists
    const existingNotification = document.getElementById('vocab-text-selector-notification');
    if (existingNotification) {
      existingNotification.remove();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.id = 'vocab-text-selector-notification';
    notification.className = 'vocab-notification vocab-notification-error';
    
    // Create close button
    const closeBtn = document.createElement('button');
    closeBtn.className = 'vocab-notification-close';
    closeBtn.setAttribute('aria-label', 'Close notification');
    closeBtn.innerHTML = `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M9 3L3 9M3 3l6 6" stroke="#dc2626" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    
    // Close button click handler
    closeBtn.addEventListener('click', () => {
      notification.classList.remove('visible');
      setTimeout(() => {
        notification.remove();
      }, 300);
    });
    
    // Create message text
    const messageText = document.createElement('span');
    messageText.className = 'vocab-notification-message';
    messageText.textContent = message;
    
    // Append close button and message
    notification.appendChild(closeBtn);
    notification.appendChild(messageText);
    
    // Add to body
    document.body.appendChild(notification);
    
    // Trigger animation
    setTimeout(() => {
      notification.classList.add('visible');
    }, 10);
    
    // Auto-dismiss after 3 seconds
    setTimeout(() => {
      notification.classList.remove('visible');
      setTimeout(() => {
        notification.remove();
      }, 300);
    }, 3000);
  },
  
  /**
   * Get a unique key for the text (normalized)
   * @param {string} text - The text
   * @returns {string}
   */
  getTextKey(text) {
    return text.toLowerCase().replace(/\s+/g, ' ').trim();
  },

  /**
   * Generate contextual textKey based on current content context
   * @param {string} text - The text to generate key for
   * @returns {string} Contextual textKey
   */
  getContextualTextKey(text) {
    const normalizedText = this.getTextKey(text);
    
    // Check if we're in custom content context
    if (window.ButtonPanel && window.ButtonPanel.topicsModal && 
        window.ButtonPanel.topicsModal.customContentModal && 
        window.ButtonPanel.topicsModal.customContentModal.activeTabId) {
      
      const activeTabId = window.ButtonPanel.topicsModal.customContentModal.activeTabId;
      const activeContent = window.ButtonPanel.topicsModal.customContentModal.getContentByTabId(parseInt(activeTabId));
      
      if (activeContent) {
        // Generate contextual textKey for custom content
        const contextualTextKey = `${activeContent.contentType}-${activeTabId}-${normalizedText}`;
        console.log('[TextSelector] Generated contextual textKey:', contextualTextKey, 'for text:', normalizedText);
        return contextualTextKey;
      }
    }
    
    // Default to main page textKey
    console.log('[TextSelector] Generated main page textKey:', normalizedText);
    return normalizedText;
  },
  
  /**
   * Calculate text position in document (approximate position in plain text)
   * @param {Range} range - The range to calculate position for
   * @returns {{textStartIndex: number, textLength: number, text: string}}
   */
  calculateTextPosition(range) {
    const text = range.toString();
    const textLength = text.length;
    
    // Get the full text content of the body up to the start of the range
    const bodyText = document.body.innerText || document.body.textContent || '';
    
    // Find the approximate position by searching for the text in the body
    // This is approximate as we're using innerText which may differ from actual positions
    const rangeText = range.toString();
    const textStartIndex = bodyText.indexOf(rangeText);
    
    return {
      textStartIndex: textStartIndex >= 0 ? textStartIndex : 0,
      textLength: textLength,
      text: text
    };
  },
  
  /**
   * Add a text to the selected texts set
   * @param {string} text - The text to add
   * @param {Range} range - The range object (optional, for position tracking)
   */
  addText(text, range = null) {
    // Generate contextual textKey based on current context
    const textKey = this.getContextualTextKey(text);
    this.selectedTexts.add(textKey); // O(1) operation
    
    // Store position information if range is provided
    if (range) {
      const positionData = this.calculateTextPosition(range);
      this.textPositions.set(textKey, positionData);
    }
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Remove a text from the selected texts set
   * @param {string} text - The text to remove
   */
  removeText(text) {
    const textKey = this.getContextualTextKey(text);
    
    // Get the highlight for this text
    const highlight = this.textToHighlights.get(textKey);
    
    if (highlight) {
      // Remove highlight element
      this.removeHighlight(highlight);
      
      // Clean up the mapping
      this.textToHighlights.delete(textKey); // O(1) operation
    }
    
    // Remove from selected texts set
    this.selectedTexts.delete(textKey); // O(1) operation
    
    // Clean up position data
    this.textPositions.delete(textKey);
    
    console.log('[TextSelector] Text removed');
    console.log('[TextSelector] Remaining selected texts:', this.selectedTexts.size);
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Show magic-meaning button without wrapping text in a span
   * @param {Range} range - The range of selected text
   * @param {string} text - The selected text
   * @param {string} textKey - The text key
   * @param {Object} mouseReleaseCoords - Mouse release coordinates {x, y} in viewport coordinates
   */
  showMagicMeaningButton(range, text, textKey, mouseReleaseCoords = null) {
    // Store the range for later use (when button is clicked)
    this.pendingRanges.set(textKey, range.cloneRange());
    
    // Create icons wrapper for the magic meaning button
    const iconsWrapper = document.createElement('div');
    iconsWrapper.className = 'vocab-text-icons-wrapper vocab-text-icons-wrapper-magic';
    iconsWrapper.setAttribute('data-text-key', textKey);
    iconsWrapper.id = `vocab-button-wrapper-${textKey.replace(/\s+/g, '-').substring(0, 20)}`;
    
    // Determine context and set appropriate data attribute
    const isInModal = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE 
      ? range.commonAncestorContainer.closest('.vocab-custom-content-modal')
      : range.commonAncestorContainer.parentElement?.closest('.vocab-custom-content-modal');
    iconsWrapper.setAttribute('data-icon-context', isInModal ? 'custom-content-modal' : 'main-webpage');
    
    // Create and add magic meaning button
    const magicBtn = this.createMagicMeaningButton(textKey);
    // Remove breathing class temporarily and add appearing animation
    magicBtn.classList.remove('magic-meaning-breathing');
    magicBtn.classList.add('magic-meaning-appearing');
    iconsWrapper.appendChild(magicBtn);
    // Remove appearing class after animation completes and restore breathing animation
    setTimeout(() => {
      magicBtn.classList.remove('magic-meaning-appearing');
      magicBtn.classList.add('magic-meaning-breathing');
    }, 200);
    
    // Position button absolutely relative to document (so it scrolls with page)
    iconsWrapper.style.setProperty('position', 'absolute', 'important');
    iconsWrapper.style.setProperty('display', 'flex', 'important');
    iconsWrapper.style.setProperty('margin', '0', 'important');
    iconsWrapper.style.setProperty('padding', '0', 'important');
    iconsWrapper.style.setProperty('z-index', '10000000', 'important');
    iconsWrapper.style.setProperty('pointer-events', 'auto', 'important');
    
    // Helper function to perform cleanup (will be defined after handlers, but declared here for scope)
    let performCleanup;
    
    // Click handler: remove button when clicking anywhere except on the button itself
    const handleGlobalClick = (event) => {
      console.log('[handleGlobalClick] Event triggered, type:', event.type);
      
      // Check if magic-meaning button is visible
      if (!iconsWrapper || !iconsWrapper.parentNode) {
        console.log('[handleGlobalClick] Early return: iconsWrapper not found');
        return; // Button already removed, nothing to do
      }
      
      // Check if click is on the magic-meaning button or its wrapper
      if (event.target && (
        event.target.closest('.vocab-text-magic-meaning-btn') ||
        event.target.closest('.vocab-text-icons-wrapper')
      )) {
        console.log('[handleGlobalClick] Early return: click is on button');
        // Click is on the button - don't remove it, let the button's own click handler handle it
        return;
      }
      
      // IMPORTANT: Don't remove button if it's in loading state (spinner is showing)
      // The spinner should only disappear when the first API event is received
      const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
      if (magicBtn && magicBtn.classList.contains('magic-meaning-loading')) {
        console.log('[handleGlobalClick] Early return: button is in loading state');
        // Button is in loading state - don't remove it
        return;
      }
      
      console.log('[handleGlobalClick] Setting timeout for OUTSIDE_CLICK');
      
      // Click is anywhere else (not on button) - remove the button
      // Use a small delay to ensure the button's click handler can execute first if needed
      setTimeout(() => {
        console.log('[handleGlobalClick] Timeout callback executed');
        
        // Double-check button still exists (might have been removed by button's own handler)
        if (!iconsWrapper || !iconsWrapper.parentNode) {
          console.log('[handleGlobalClick] Timeout early return: iconsWrapper removed');
          return;
        }
        
        // Double-check button is not in loading state before removing
        const checkMagicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
        if (checkMagicBtn && checkMagicBtn.classList.contains('magic-meaning-loading')) {
          console.log('[handleGlobalClick] Timeout early return: button is loading');
          // Button is in loading state - don't remove it
          return;
        }
        
        // Remove the button when clicking outside
        console.log('OUTSIDE_CLICK');
        performCleanup();
      }, 10);
    };
    
    // Helper function to calculate button position (used for initial and scroll updates)
    const calculateButtonPosition = (useMouseCoords = true) => {
      // Get current scroll offsets
      const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
      const scrollY = window.pageYOffset || document.documentElement.scrollTop;
      
      const buttonWidth = 32; // Button width
      const buttonHeight = 32; // Button height
      
      let newLeft, newTop;
      
      // Priority 1: Use mouse release coordinates if available (user's preference)
      if (useMouseCoords && mouseReleaseCoords) {
        newLeft = mouseReleaseCoords.x + scrollX - 50; // Offset to center button on cursor
        newTop = mouseReleaseCoords.y + scrollY;
      } else {
        // Priority 2: Fallback to selection bounding rect
        const rect = range.getBoundingClientRect();
        const offsetX = 8; // Space between text and button
        const offsetY = 0; // Vertical offset (align with top of text)
        
        // Calculate absolute position in document coordinates
        newLeft = rect.right + scrollX + offsetX;
        newTop = rect.top + scrollY + offsetY;
      }
      
      // Get viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Check if button would go out of viewport and adjust position
      const buttonRight = newLeft + buttonWidth;
      const buttonBottom = newTop + buttonHeight;
      
      // If button goes beyond right edge, adjust position
      if (buttonRight > scrollX + viewportWidth - 10) {
        // Try positioning to the left of the text if using mouse coords
        if (useMouseCoords && mouseReleaseCoords) {
          const rect = range.getBoundingClientRect();
          newLeft = rect.left + scrollX - buttonWidth - 8;
        } else {
          const rect = range.getBoundingClientRect();
          newLeft = rect.left + scrollX - buttonWidth - 8;
        }
      }
      
      // If button goes beyond left edge, adjust position
      if (newLeft < scrollX + 10) {
        if (useMouseCoords && mouseReleaseCoords) {
          // Keep mouse position but ensure it's visible
          newLeft = scrollX + 10;
        } else {
          const rect = range.getBoundingClientRect();
          newLeft = rect.right + scrollX + 8;
          // If still doesn't fit, position it at the right edge of viewport
          if (newLeft + buttonWidth > scrollX + viewportWidth - 10) {
            newLeft = scrollX + viewportWidth - buttonWidth - 10;
          }
        }
      }
      
      // If button goes beyond bottom edge, adjust vertical position
      if (buttonBottom > scrollY + viewportHeight - 10) {
        newTop = scrollY + viewportHeight - buttonHeight - 10;
      }
      
      // If button goes beyond top edge, adjust vertical position
      if (newTop < scrollY + 10) {
        newTop = scrollY + 10;
      }
      
      // Ensure button stays within document bounds
      const documentWidth = document.documentElement.scrollWidth;
      const documentHeight = document.documentElement.scrollHeight;
      
      if (newLeft + buttonWidth > documentWidth) {
        newLeft = documentWidth - buttonWidth - 10;
      }
      if (newLeft < 0) {
        newLeft = 10;
      }
      if (newTop + buttonHeight > documentHeight) {
        newTop = documentHeight - buttonHeight - 10;
      }
      if (newTop < 0) {
        newTop = 10;
      }
      
      return { left: newLeft, top: newTop };
    };
    
    // Calculate and set initial position (use mouse coordinates if available)
    const initialPosition = calculateButtonPosition(true);
    const initialLeft = initialPosition.left;
    const initialTop = initialPosition.top;
    
    // Calculate the initial offset relative to the selection's position
    // This allows us to maintain the same relative position when scrolling
    const initialSelectionRect = range.getBoundingClientRect();
    const initialScrollX = window.pageXOffset || document.documentElement.scrollLeft;
    const initialScrollY = window.pageYOffset || document.documentElement.scrollTop;
    
    // Calculate offset from selection's top-left corner in document coordinates
    const selectionLeftInDoc = initialSelectionRect.left + initialScrollX;
    const selectionTopInDoc = initialSelectionRect.top + initialScrollY;
    const offsetX = initialLeft - selectionLeftInDoc;
    const offsetY = initialTop - selectionTopInDoc;
    
    // Set initial position
    iconsWrapper.style.setProperty('left', `${initialLeft}px`, 'important');
    iconsWrapper.style.setProperty('top', `${initialTop}px`, 'important');
    iconsWrapper.style.setProperty('right', 'auto', 'important');
    
    // REQUIREMENT 2: Track scroll position to move button by scroll delta
    let lastScrollX = window.pageXOffset || document.documentElement.scrollLeft;
    let lastScrollY = window.pageYOffset || document.documentElement.scrollTop;
    
    // Function to update button position on scroll (maintains relative position to selection)
    // This works for both normal button state and spinner state
    // Track consecutive zero-size rects to avoid premature cleanup during scroll
    let zeroSizeRectCount = 0;
    const MAX_ZERO_SIZE_RECTS = 3; // Allow up to 3 consecutive zero-size rects before cleanup
    
    const updateButtonPosition = () => {
      try {
        // Check if button wrapper still exists
        if (!iconsWrapper || !iconsWrapper.parentNode) {
          console.log('[TextSelector] updateButtonPosition: iconsWrapper no longer exists, skipping');
          return;
        }
        
        // Check if button is in loading state (spinner showing) - don't cleanup during loading
        const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
        const isInLoadingState = magicBtn && magicBtn.classList.contains('magic-meaning-loading');
        
        console.log('[TextSelector] updateButtonPosition called - isInLoadingState:', isInLoadingState, 'textKey:', textKey);
        
        // Check if range is still valid
        if (!range || !range.commonAncestorContainer || 
            !document.contains(range.commonAncestorContainer)) {
          console.log('[TextSelector] updateButtonPosition: Range is invalid');
          // Range is invalid, cleanup button (but not if loading)
          if (!isInLoadingState && performCleanup) {
            console.log('[TextSelector] updateButtonPosition: Cleaning up due to invalid range');
            performCleanup();
          }
          return;
        }
        
        // Get current selection position
        const currentSelectionRect = range.getBoundingClientRect();
        const currentScrollX = window.pageXOffset || document.documentElement.scrollLeft;
        const currentScrollY = window.pageYOffset || document.documentElement.scrollTop;
        
        console.log('[TextSelector] updateButtonPosition: Selection rect:', {
          width: currentSelectionRect.width,
          height: currentSelectionRect.height,
          left: currentSelectionRect.left,
          top: currentSelectionRect.top
        });
        
        // Check if selection rect is zero-size (might be temporary during scroll)
        const isZeroSize = currentSelectionRect.width === 0 && currentSelectionRect.height === 0;
        
        if (isZeroSize) {
          zeroSizeRectCount++;
          console.log('[TextSelector] updateButtonPosition: Zero-size rect detected, count:', zeroSizeRectCount);
          
          // If button is in loading state, don't cleanup even if rect is zero
          // This prevents spinner from disappearing during scroll on some websites
          if (isInLoadingState) {
            console.log('[TextSelector] updateButtonPosition: Button is loading, skipping cleanup despite zero-size rect');
            // Still try to maintain last known position
            if (iconsWrapper.style.left && iconsWrapper.style.top) {
              // Keep current position, don't update
              return;
            }
          } else if (zeroSizeRectCount >= MAX_ZERO_SIZE_RECTS) {
            // Only cleanup if not loading and we've seen multiple consecutive zero-size rects
            console.log('[TextSelector] updateButtonPosition: Cleaning up due to multiple zero-size rects');
            if (performCleanup) performCleanup();
            return;
          } else {
            // Reset counter if we get a valid rect again
            zeroSizeRectCount = 0;
          }
        } else {
          // Reset counter when we get a valid rect
          zeroSizeRectCount = 0;
        }
        
        // Calculate selection's position in document coordinates
        const selectionLeftInDoc = currentSelectionRect.left + currentScrollX;
        const selectionTopInDoc = currentSelectionRect.top + currentScrollY;
        
        // Apply the same offset to maintain relative position
        let newLeft = selectionLeftInDoc + offsetX;
        let newTop = selectionTopInDoc + offsetY;
        
        // Get viewport dimensions for boundary checks
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const buttonWidth = 32;
        const buttonHeight = 32;
        
        // Ensure button stays within viewport bounds (adjust if needed)
        if (newLeft + buttonWidth > currentScrollX + viewportWidth - 10) {
          newLeft = currentScrollX + viewportWidth - buttonWidth - 10;
        }
        if (newLeft < currentScrollX + 10) {
          newLeft = currentScrollX + 10;
        }
        if (newTop + buttonHeight > currentScrollY + viewportHeight - 10) {
          newTop = currentScrollY + viewportHeight - buttonHeight - 10;
        }
        if (newTop < currentScrollY + 10) {
          newTop = currentScrollY + 10;
        }
        
        // Update button position (using absolute positioning)
        iconsWrapper.style.setProperty('position', 'absolute', 'important');
        iconsWrapper.style.setProperty('left', `${newLeft}px`, 'important');
        iconsWrapper.style.setProperty('top', `${newTop}px`, 'important');
        iconsWrapper.style.setProperty('right', 'auto', 'important');
        
        console.log('[TextSelector] updateButtonPosition: Updated position to', newLeft, newTop);
        
        // Update last scroll position for tracking
        lastScrollX = currentScrollX;
        lastScrollY = currentScrollY;
      } catch (error) {
        console.warn('[TextSelector] Error updating button position:', error);
        // If error persists and button is not loading, cleanup button
        const magicBtn = iconsWrapper?.querySelector('.vocab-text-magic-meaning-btn');
        const isInLoadingState = magicBtn && magicBtn.classList.contains('magic-meaning-loading');
        if (!isInLoadingState && performCleanup) {
          performCleanup();
        }
      }
    };
    
    // Append to body (not to the text, since we're not wrapping it)
    document.body.appendChild(iconsWrapper);
    
    // Store reference to the wrapper for cleanup
    this.buttonWrappers.set(textKey, iconsWrapper);
    
    // Store the button's absolute position for later use (when spinner needs to be positioned)
    iconsWrapper._buttonPosition = {
      left: initialLeft,
      top: initialTop,
      mouseReleaseCoords: mouseReleaseCoords,
      range: range.cloneRange() // Store range for scroll updates
    };
    
    console.log('[TextSelector] Magic meaning button shown for text (no span wrapper):', textKey);
    
    // Update position on scroll and resize
    const scrollHandler = () => updateButtonPosition();
    const resizeHandler = () => updateButtonPosition();
    
    // Helper function to find all scrollable containers
    const findScrollableContainers = (element) => {
      const scrollableContainers = [];
      // Ensure we start with an Element (not a text node)
      let current = element;
      if (current && current.nodeType === Node.TEXT_NODE) {
        current = current.parentElement;
      }
      
      while (current && current !== document.body && current !== document.documentElement) {
        // Only process Element nodes (not text nodes or other node types)
        if (current.nodeType === Node.ELEMENT_NODE) {
          try {
            const style = window.getComputedStyle(current);
            const overflowY = style.overflowY;
            const overflowX = style.overflowX;
            const overflow = style.overflow;
            
            // Check if element is scrollable
            if (overflow === 'auto' || overflow === 'scroll' || 
                overflowY === 'auto' || overflowY === 'scroll' ||
                overflowX === 'auto' || overflowX === 'scroll') {
              const hasScrollableContent = current.scrollHeight > current.clientHeight || 
                                           current.scrollWidth > current.clientWidth;
              if (hasScrollableContent) {
                scrollableContainers.push(current);
              }
            }
          } catch (e) {
            // If getComputedStyle fails, skip this element and continue
            console.warn('[TextSelector] Error getting computed style for element:', e);
          }
        }
        
        current = current.parentElement;
      }
      
      return scrollableContainers;
    };
    
    // Find scrollable containers for the selected text
    const scrollableContainers = findScrollableContainers(range.commonAncestorContainer);
    const scrollableContainerHandlers = new Map();
    
    // Define performCleanup function after handlers are created
    performCleanup = () => {
      // Clean up fixed scroll handler if it exists (for spinner)
      if (iconsWrapper && iconsWrapper._fixedScrollHandler) {
        window.removeEventListener('scroll', iconsWrapper._fixedScrollHandler);
        iconsWrapper._fixedScrollHandler = null;
        iconsWrapper._fixedPosition = null;
      }
      
      // Remove button with disappearing animation
      if (iconsWrapper && iconsWrapper.parentNode) {
        const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
        if (magicBtn) {
          // Add disappearing animation
          magicBtn.classList.remove('magic-meaning-breathing');
          magicBtn.classList.add('magic-meaning-disappearing');
          // Remove after animation completes
          setTimeout(() => {
            if (iconsWrapper && iconsWrapper.parentNode) {
              iconsWrapper.remove();
            }
          }, 200);
        } else {
          // If button not found, remove immediately
          iconsWrapper.remove();
        }
      }
      
      // Clean up event listeners
      window.removeEventListener('scroll', scrollHandler);
      window.removeEventListener('resize', resizeHandler);
      document.removeEventListener('click', handleGlobalClick, true);
      document.removeEventListener('touchend', handleGlobalClick, true);
      
      // Clean up scroll listeners on all scrollable containers
      scrollableContainerHandlers.forEach((handler, container) => {
        container.removeEventListener('scroll', handler);
      });
      scrollableContainerHandlers.clear();
      
      // Clean up data - IMPORTANT: Remove from selectedTexts so the same text can be selected again
      this.buttonWrappers?.delete(textKey);
      this.pendingRanges.delete(textKey);
      this.selectedTexts.delete(textKey); // Remove from selectedTexts to allow reselection
      this.textPositions.delete(textKey); // Also clean up position data
      
      // Note: We don't remove from textToHighlights here because:
      // - If no span was created (just button shown), there's no highlight in textToHighlights
      // - If span was created (button was clicked), the highlight should remain for the simplified text
      // The hasOverlap check will handle existing highlights appropriately
      
      // Update button states
      if (typeof ButtonPanel !== 'undefined' && ButtonPanel.updateButtonStatesFromSelections) {
        ButtonPanel.updateButtonStatesFromSelections();
      }
      
      console.log('[TextSelector] Magic meaning button removed and text cleared from selectedTexts');
    };
    
    // Add scroll listeners to window and all scrollable containers
    window.addEventListener('scroll', scrollHandler, { passive: true });
    window.addEventListener('resize', resizeHandler, { passive: true });
    
    // Add scroll listeners to all scrollable containers
    // Track scroll positions for each container to calculate deltas
    const containerScrollPositions = new Map();
    scrollableContainers.forEach(container => {
      // Store initial scroll position for this container
      containerScrollPositions.set(container, {
        scrollLeft: container.scrollLeft,
        scrollTop: container.scrollTop
      });
      
      const handler = () => {
        // Maintain relative position to selection when container scrolls
        // Use the same offset-based approach as the main scroll handler
        try {
          // Check if button wrapper still exists
          if (!iconsWrapper || !iconsWrapper.parentNode) {
            return;
          }
          
          // Check if button is in loading state (spinner showing)
          const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
          const isInLoadingState = magicBtn && magicBtn.classList.contains('magic-meaning-loading');
          
          if (!range || !range.commonAncestorContainer || 
              !document.contains(range.commonAncestorContainer)) {
            // Don't update position if range is invalid, but don't cleanup (let main handler do it)
            return;
          }
          
          // Get current selection position
          const currentSelectionRect = range.getBoundingClientRect();
          
          // If selection rect is zero-size and button is loading, skip update but don't cleanup
          if ((currentSelectionRect.width === 0 && currentSelectionRect.height === 0) && isInLoadingState) {
            // Keep current position during loading state
            return;
          }
          
          const currentScrollX = window.pageXOffset || document.documentElement.scrollLeft;
          const currentScrollY = window.pageYOffset || document.documentElement.scrollTop;
          
          // Calculate selection's position in document coordinates
          const selectionLeftInDoc = currentSelectionRect.left + currentScrollX;
          const selectionTopInDoc = currentSelectionRect.top + currentScrollY;
          
          // Apply the same offset to maintain relative position
          let newLeft = selectionLeftInDoc + offsetX;
          let newTop = selectionTopInDoc + offsetY;
          
          // Get viewport dimensions for boundary checks
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const buttonWidth = 32;
          const buttonHeight = 32;
          
          // Ensure button stays within viewport bounds (adjust if needed)
          if (newLeft + buttonWidth > currentScrollX + viewportWidth - 10) {
            newLeft = currentScrollX + viewportWidth - buttonWidth - 10;
          }
          if (newLeft < currentScrollX + 10) {
            newLeft = currentScrollX + 10;
          }
          if (newTop + buttonHeight > currentScrollY + viewportHeight - 10) {
            newTop = currentScrollY + viewportHeight - buttonHeight - 10;
          }
          if (newTop < currentScrollY + 10) {
            newTop = currentScrollY + 10;
          }
          
          // Update button position
          iconsWrapper.style.setProperty('left', `${newLeft}px`, 'important');
          iconsWrapper.style.setProperty('top', `${newTop}px`, 'important');
          iconsWrapper.style.setProperty('right', 'auto', 'important');
          
          // Update stored scroll position for tracking
          containerScrollPositions.set(container, {
            scrollLeft: container.scrollLeft,
            scrollTop: container.scrollTop
          });
        } catch (error) {
          console.warn('[TextSelector] Error updating button position on container scroll:', error);
        }
      };
      
      container.addEventListener('scroll', handler, { passive: true });
      scrollableContainerHandlers.set(container, handler);
    });
    
    // Listen for all click events globally (use capture phase to catch all clicks)
    // Attach listeners immediately to catch all clicks
    document.addEventListener('click', handleGlobalClick, true);
    document.addEventListener('touchend', handleGlobalClick, true);
    
    // Store cleanup handlers for later removal
    iconsWrapper._cleanupHandlers = {
      scroll: scrollHandler,
      resize: resizeHandler,
      cleanup: performCleanup
    };
  },
  
  /**
   * Highlight a range with a styled span
   * @param {Range} range - The range to highlight
   * @param {string} text - The text being highlighted
   * @param {Object} mouseReleaseCoords - Mouse release coordinates {x, y} in viewport coordinates
   */
  highlightRange(range, text, mouseReleaseCoords = null) {
    const textKey = this.getContextualTextKey(text);
    
    // Create highlight wrapper
    // DO NOT apply any font/text styles to the wrapper - let child elements preserve their own formatting
    // The highlight span should only provide the underline decoration, not override text formatting
    const highlight = document.createElement('span');
    highlight.className = 'vocab-text-highlight';
    highlight.setAttribute('data-text-key', textKey);
    highlight.setAttribute('data-highlight-id', `text-highlight-${this.highlightIdCounter++}`);
    
    // Hide underline initially - only show magic meaning button
    highlight.style.setProperty('text-decoration', 'none', 'important');
    highlight.style.setProperty('text-decoration-line', 'none', 'important');
    
    // Ensure the highlight span doesn't interfere with child formatting
    // Set display to inline to preserve text flow (will be adjusted if block elements are detected)
    highlight.style.setProperty('display', 'inline', 'important');
    highlight.style.setProperty('position', 'relative', 'important');
    // DO NOT set any font properties - let children inherit or use their own styles
    
    console.log('[TextSelector] Highlight element created with data-text-key:', textKey);
    console.log('[TextSelector] Preserving all formatting from selected range - no font overrides applied');
    
    // Wrap the selected range FIRST
    // This preserves all formatting (bold, italic, font sizes, colors, etc.) from the original content
    try {
      // Check if range might contain formatting elements by checking the HTML
      const rangeClone = range.cloneContents();
      const hasFormattingElements = rangeClone.querySelector('b, strong, em, i, u, span, font, a, h1, h2, h3, h4, h5, h6');
      const listItems = rangeClone.querySelectorAll('li');
      const listContainers = rangeClone.querySelectorAll('ul, ol');
      // Check for block-level elements that need to maintain their spacing
      const blockElements = rangeClone.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6, section, article, aside, header, footer, nav, main, blockquote, pre, address');
      
      // Check if range contains list items
      if (listItems.length > 0 || listContainers.length > 0) {
        // Range contains list items - we need to handle this carefully
        // List items MUST be direct children of ul/ol, so we can't wrap them in a span
        // Instead, we should wrap the parent ul/ol container, or wrap content inside each li
        
        // Find the common ancestor that is a ul/ol, or find all ul/ol containers in the range
        const startContainer = range.startContainer;
        const endContainer = range.endContainer;
        
        // Helper function to find the nearest ul/ol ancestor
        const findListContainer = (node) => {
          let current = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
          while (current && current !== document.body) {
            if (current.tagName === 'UL' || current.tagName === 'OL') {
              return current;
            }
            current = current.parentElement;
          }
          return null;
        };
        
        // Check if we can find a common ul/ol container
        const startListContainer = findListContainer(startContainer);
        const endListContainer = findListContainer(endContainer);
        
        // If both start and end are in the same list container, wrap that container
        if (startListContainer && endListContainer && startListContainer === endListContainer) {
          // Wrap the entire list container
          console.log('[TextSelector] Range contains list items within same list container - wrapping parent list');
          highlight.style.setProperty('display', 'block', 'important');
          const listContainer = startListContainer;
          const parent = listContainer.parentNode;
          const nextSibling = listContainer.nextSibling;
          // Move the list container into the highlight
          highlight.appendChild(listContainer);
          // Insert the highlight where the list container was
          parent.insertBefore(highlight, nextSibling);
          console.log('[TextSelector] Wrapped parent list container - list structure preserved');
        } else {
          // Range spans multiple lists or partial list items - wrap only text content inside each li
          // This is more complex - we need to wrap content within each li, not the li itself
          console.log('[TextSelector] Range contains list items - wrapping content within list items to preserve structure');
          highlight.style.setProperty('display', 'contents', 'important');
          
          // Use extractContents but then restructure to avoid breaking list semantics
          const extractedContents = range.extractContents();
          
          // If extracted contents contain complete list items, we need to handle them differently
          const extractedListItems = extractedContents.querySelectorAll('li');
          if (extractedListItems.length > 0) {
            // We have extracted list items - this will break the structure
            // Instead, we need to wrap the parent ul/ol if it exists in the range
            const extractedListContainers = extractedContents.querySelectorAll('ul, ol');
            if (extractedListContainers.length > 0) {
              // We have complete list containers - wrap them
              highlight.style.setProperty('display', 'block', 'important');
              highlight.appendChild(extractedContents);
              range.insertNode(highlight);
            } else {
              // We have list items but no container - this is problematic
              // Find the parent ul/ol of the first list item and wrap that
              const firstListItem = listItems[0] || extractedListItems[0];
              if (firstListItem) {
                const parentList = firstListItem.closest('ul, ol');
                if (parentList && range.intersectsNode(parentList)) {
                  // Wrap the entire parent list
                  highlight.style.setProperty('display', 'block', 'important');
                  const parent = parentList.parentNode;
                  const nextSibling = parentList.nextSibling;
                  highlight.appendChild(parentList);
                  parent.insertBefore(highlight, nextSibling);
                  console.log('[TextSelector] Wrapped parent list to preserve structure');
                } else {
                  // Fallback: use display contents
                  highlight.style.setProperty('display', 'contents', 'important');
                  highlight.appendChild(extractedContents);
                  range.insertNode(highlight);
                }
              } else {
                highlight.style.setProperty('display', 'contents', 'important');
                highlight.appendChild(extractedContents);
                range.insertNode(highlight);
              }
            }
          } else {
            // No complete list items extracted - safe to use normal wrapping
            highlight.style.setProperty('display', 'contents', 'important');
            highlight.appendChild(extractedContents);
            range.insertNode(highlight);
          }
          console.log('[TextSelector] Used extractContents with special list handling - list structure preserved');
        }
      } else if (blockElements.length > 0) {
        // Range contains block-level elements (p, div, h1-h6, etc.) - need to preserve block behavior
        // Block elements inside an inline span lose their margins and spacing
        // Change display to block to allow block-level children to maintain their spacing
        console.log('[TextSelector] Range contains block-level elements - using block display to preserve spacing');
        highlight.style.setProperty('display', 'block', 'important');
        const extractedContents = range.extractContents();
        highlight.appendChild(extractedContents);
        range.insertNode(highlight);
        console.log('[TextSelector] Used extractContents with block display - block element spacing preserved');
      } else if (hasFormattingElements) {
        // Range contains formatting elements - use extractContents to preserve structure
        console.log('[TextSelector] Range contains formatting elements - using extractContents to preserve formatting');
        const extractedContents = range.extractContents();
        highlight.appendChild(extractedContents);
        range.insertNode(highlight);
        console.log('[TextSelector] Used extractContents - formatting preserved');
      } else {
        // No formatting elements - try surroundContents
        range.surroundContents(highlight);
        console.log('[TextSelector] Used surroundContents - formatting preserved');
      }
    } catch (error) {
      // surroundContents failed - use extractContents which preserves DOM structure
      console.warn('[TextSelector] surroundContents failed, using extractContents:', error);
      const rangeClone = range.cloneContents();
      const listItems = rangeClone.querySelectorAll('li');
      const listContainers = rangeClone.querySelectorAll('ul, ol');
      const blockElements = rangeClone.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6, section, article, aside, header, footer, nav, main, blockquote, pre, address');
      
      if (listItems.length > 0 || listContainers.length > 0) {
        // If it contains list items, try to wrap the parent list container
        const startContainer = range.startContainer;
        const findListContainer = (node) => {
          let current = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
          while (current && current !== document.body) {
            if (current.tagName === 'UL' || current.tagName === 'OL') {
              return current;
            }
            current = current.parentElement;
          }
          return null;
        };
        
        const listContainer = findListContainer(startContainer);
        if (listContainer && range.intersectsNode(listContainer)) {
          highlight.style.setProperty('display', 'block', 'important');
          const parent = listContainer.parentNode;
          const nextSibling = listContainer.nextSibling;
          highlight.appendChild(listContainer);
          parent.insertBefore(highlight, nextSibling);
          console.log('[TextSelector] Wrapped parent list in fallback - list structure preserved');
        } else {
          highlight.style.setProperty('display', 'contents', 'important');
          const extractedContents = range.extractContents();
          highlight.appendChild(extractedContents);
          range.insertNode(highlight);
        }
      } else if (blockElements.length > 0) {
        // Range contains block-level elements - use block display to preserve spacing
        highlight.style.setProperty('display', 'block', 'important');
        const extractedContents = range.extractContents();
        highlight.appendChild(extractedContents);
        range.insertNode(highlight);
        console.log('[TextSelector] Used extractContents with block display (fallback) - block element spacing preserved');
      } else {
        // For inline text (no block elements), ensure display stays inline to prevent line breaks
        highlight.style.setProperty('display', 'inline', 'important');
        const extractedContents = range.extractContents();
        highlight.appendChild(extractedContents);
        range.insertNode(highlight);
      }
      console.log('[TextSelector] Used extractContents (fallback) - formatting preserved');
    }
    
    // After wrapping, ensure inline text highlights remain inline (prevent newline after selection)
    // Check if highlight contains only inline content (no block elements)
    const hasBlockElements = highlight.querySelector('p, div, h1, h2, h3, h4, h5, h6, section, article, aside, header, footer, nav, main, blockquote, pre, address, ul, ol, li');
    if (!hasBlockElements) {
      // Force inline display for inline text to prevent line breaks
      highlight.style.setProperty('display', 'inline', 'important');
    }
    
    // After wrapping, ensure all child elements with color classes or inline styles maintain their colors
    // This is a safety measure in case CSS doesn't work as expected
    setTimeout(() => {
      const colorElements = highlight.querySelectorAll('[class*="user-"], [class*="rated-"], [style*="color"], [style*="Color"]');
      colorElements.forEach(element => {
        const computedStyle = window.getComputedStyle(element);
        const originalColor = computedStyle.color;
        // If the element has a color class or inline style, ensure it's preserved
        if (element.classList.contains('user-orange') || element.classList.contains('rated-user') || 
            element.hasAttribute('style') && element.getAttribute('style').includes('color')) {
          // The color should already be preserved, but log for debugging
          console.log('[TextSelector] Color element found:', element.className, 'computed color:', originalColor);
        }
      });
    }, 0);
    
    // Store the highlight in our map (O(1) operation)
    this.textToHighlights.set(textKey, highlight);
    
    // Create and add magic meaning button (no underline, no cross icon, no API call)
    // Add a small delay to ensure DOM is ready
    setTimeout(() => {
      // Check if we're processing magic meaning (spinner is showing) - if so, don't create magic button
      // The magic button should only appear when text is selected, not when processing
      if (highlight.hasAttribute('data-processing-magic-meaning')) {
        console.log('[TextSelector] Skipping magic meaning button creation - processing in progress');
        return;
      }
      
      // Create icons wrapper for the magic meaning button
      const iconsWrapper = document.createElement('div');
      iconsWrapper.className = 'vocab-text-icons-wrapper vocab-text-icons-wrapper-magic';
      iconsWrapper.setAttribute('data-text-key', textKey);
      
      // Determine context and set appropriate data attribute
      const isInModal = highlight.closest('.vocab-custom-content-modal');
      iconsWrapper.setAttribute('data-icon-context', isInModal ? 'custom-content-modal' : 'main-webpage');
      
      // Create and add magic meaning button
      const magicBtn = this.createMagicMeaningButton(textKey);
      // Remove breathing class temporarily and add appearing animation
      magicBtn.classList.remove('magic-meaning-breathing');
      magicBtn.classList.add('magic-meaning-appearing');
      iconsWrapper.appendChild(magicBtn);
      
      // Append wrapper to highlight
      highlight.appendChild(iconsWrapper);
      // Remove appearing class after animation completes and restore breathing animation
      setTimeout(() => {
        magicBtn.classList.remove('magic-meaning-appearing');
        magicBtn.classList.add('magic-meaning-breathing');
      }, 200);
      
      // Position icons relative to highlight - on the left side, outside text content
      iconsWrapper.style.setProperty('position', 'absolute', 'important');
      iconsWrapper.style.setProperty('display', 'flex', 'important');
      iconsWrapper.style.setProperty('margin', '0', 'important');
      iconsWrapper.style.setProperty('padding', '0', 'important');
      
      if (isInModal) {
        // In modal context: position to the left with sufficient margin to avoid overlap
        iconsWrapper.style.setProperty('left', '-50px', 'important');
        iconsWrapper.style.setProperty('right', 'auto', 'important');
        iconsWrapper.style.setProperty('top', '-2px', 'important');
      } else {
        // In main webpage context: position to the left, outside text content
        iconsWrapper.style.setProperty('left', '-45px', 'important');
        iconsWrapper.style.setProperty('right', 'auto', 'important');
        iconsWrapper.style.setProperty('top', '0px', 'important');
      }
      
      console.log('[TextSelector] Magic meaning button added for text:', textKey);
    }, 100);
    
    // Return the highlight element so selection can be restored
    return highlight;
  },
  
  /**
   * Create a remove button for the highlight
   * @param {string} text - The text this button will remove
   * @returns {HTMLElement}
   */
  createRemoveButton(text) {
    const btn = document.createElement('button');
    btn.className = 'vocab-text-remove-btn button-appearing';
    btn.setAttribute('aria-label', `Remove highlight for selected text`);
    btn.innerHTML = this.createCloseIcon();
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.removeText(text);
    });
    
    // Remove the appearing class after animation completes (0.3s same as underline)
    setTimeout(() => {
      btn.classList.remove('button-appearing');
    }, 300);
    
    return btn;
  },
  
  /**
   * Create close/cross icon SVG - Purple cross icon
   * @returns {string} SVG markup
   */
  createCloseIcon() {
    return `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 2L10 10M10 2L2 10" stroke="#9527F5" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },

  /**
   * Create green cross icon for text removal
   * @returns {string} SVG markup
   */
  createGreenRemoveIcon() {
    return `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 2L10 10M10 2L2 10" stroke="#22c55e" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Remove a highlight element and restore original text
   * @param {HTMLElement} highlight - The highlight element to remove
   */
  removeHighlight(highlight) {
    const parent = highlight.parentNode;
    if (!parent) return;
    
    // Add disappearing animation classes (same 0.3s duration)
    // Only add if not already present (might be added by removeFromSimplifiedTexts)
    const btn = highlight.querySelector('.vocab-text-remove-btn');
    if (btn && !btn.classList.contains('button-disappearing')) {
      btn.classList.add('button-disappearing');
    }
    if (!highlight.classList.contains('underline-disappearing')) {
      highlight.classList.add('underline-disappearing');
    }
    
    // Wait for animation to complete before removing (0.3s same duration for both)
    setTimeout(() => {
      // Remove button first
      if (btn) {
        btn.remove();
      }
      
      // Remove icons wrapper and magic meaning button before moving child nodes
      const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
      if (iconsWrapper) {
        iconsWrapper.remove();
      }
      
      // Also remove any magic meaning button that might be directly in highlight
      const magicBtn = highlight.querySelector('.vocab-text-magic-meaning-btn');
      if (magicBtn) {
        magicBtn.remove();
      }
      
      // Move all remaining child nodes back to parent (only text content, not UI elements)
      while (highlight.firstChild) {
        parent.insertBefore(highlight.firstChild, highlight);
      }
      
      // Remove the empty highlight span
      highlight.remove();
      
      // Normalize the parent to merge adjacent text nodes
      parent.normalize();
    }, 300); // Same duration as animation (0.3s)
  },
  
  /**
   * Get all selected texts
   * @returns {Set<string>}
   */
  getSelectedTexts() {
    return new Set(this.selectedTexts); // Return a copy
  },
  
  /**
   * Clear all selections
   */
  clearAll() {
    // Remove all highlights
    this.textToHighlights.forEach((highlight) => {
      this.removeHighlight(highlight);
    });
    
    // Clear data structures (O(1) for Set clear)
    this.selectedTexts.clear();
    this.textToHighlights.clear();
    
    console.log('[TextSelector] All selections cleared');
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },

  /**
   * Clear only selections (purple highlights) but preserve meanings (green highlights and chat icons)
   */
  clearSelectionsOnly() {
    console.log('[TextSelector] Clearing only selections, preserving meanings');
    
    // Only clear selected texts (purple highlights)
    this.selectedTexts.forEach(textKey => {
      const highlight = this.textToHighlights.get(textKey);
      if (highlight) {
        // Only remove if it's a selection highlight (purple), not asked/simplified (green)
        if (highlight.classList.contains('vocab-text-highlight') && 
            !highlight.classList.contains('vocab-text-simplified') &&
            !highlight.querySelector('.vocab-text-chat-btn')) {
          this.removeHighlight(highlight);
        }
      }
    });
    
    // Clear only selection data structures
    this.selectedTexts.clear();
    this.textPositions.clear();
    
    // Keep askedTexts, simplifiedTexts, and their highlights intact
    
    console.log('[TextSelector] Selections cleared, meanings preserved');
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
  },
  
  /**
   * Move text from selectedTexts to askedTexts
   * @param {string} textKey - The text key
   * @returns {boolean} Success status
   */
  moveToAskedTexts(textKey) {
    const highlight = this.textToHighlights.get(textKey);
    
    if (!highlight) {
      console.warn('[TextSelector] No highlight found for textKey:', textKey);
      return false;
    }
    
    // Get the original text
    const originalText = highlight.textContent.replace(/\s+/g, ' ').trim();
    
    // Remove from selectedTexts
    this.selectedTexts.delete(textKey);
    
    // Move to askedTexts
    this.askedTexts.set(textKey, {
      text: originalText,
      textKey: textKey,
      highlight: highlight
    });
    
    // Remove existing button (purple cross)
    const existingBtn = highlight.querySelector('.vocab-text-remove-btn');
    if (existingBtn) {
      existingBtn.remove();
    }
    
    // Remove underline by changing text-decoration to none
    highlight.style.textDecoration = 'none';
    
    // Create wrapper for icons
    const iconsWrapper = document.createElement('div');
    iconsWrapper.className = 'vocab-text-icons-wrapper';
    iconsWrapper.setAttribute('data-text-key', textKey);
    
    // Determine context and set appropriate data attribute
    const isInModal = highlight.closest('.vocab-custom-content-modal');
    iconsWrapper.setAttribute('data-icon-context', isInModal ? 'custom-content-modal' : 'main-webpage');
    
    // Add chat icon button first (top position)
    const chatBtn = this.createChatButton(textKey, true); // true = green color
    iconsWrapper.appendChild(chatBtn);
    
    // Add green remove button second (bottom position)
    const greenRemoveBtn = this.createGreenRemoveButtonForAskedText(textKey);
    iconsWrapper.appendChild(greenRemoveBtn);
    
    // Append wrapper to highlight
    highlight.appendChild(iconsWrapper);
    
    // Position icons relative to highlight - on the left side, outside text content
    // Force absolute positioning to ensure it's always outside the text
    iconsWrapper.style.setProperty('position', 'absolute', 'important');
    iconsWrapper.style.setProperty('display', 'flex', 'important');
    iconsWrapper.style.setProperty('margin', '0', 'important');
    iconsWrapper.style.setProperty('padding', '0', 'important');
    
    const highlightRect = highlight.getBoundingClientRect();
    
    if (isInModal) {
      // In modal context: position to the left with sufficient margin to avoid overlap
      iconsWrapper.style.setProperty('left', '-50px', 'important'); // 50px to the left with !important
      iconsWrapper.style.setProperty('right', 'auto', 'important');
      // Align upper border with text upper border by adjusting top position
      iconsWrapper.style.setProperty('top', '-2px', 'important'); // Slight adjustment to align upper borders
    } else {
      // In main webpage context: position to the left, outside text content
      iconsWrapper.style.setProperty('left', '-45px', 'important'); // 45px to the left of the highlight
      iconsWrapper.style.setProperty('right', 'auto', 'important');
      iconsWrapper.style.setProperty('top', '0px', 'important'); // Align with top edge of selected text
    }
    
    // Pulsate the text once with green color
    this.pulsateText(highlight, true); // true = green pulsate
    
    // Update button states
    ButtonPanel.updateButtonStatesFromSelections();
    
    console.log('[TextSelector] Text moved to askedTexts:', textKey);
    return true;
  },
  
  /**
   * Remove text from askedTexts and restore to normal
   * @param {string} textKey - The text key
   */
  removeFromAskedTexts(textKey) {
    const askedData = this.askedTexts.get(textKey);
    
    if (!askedData) {
      console.warn('[TextSelector] No asked text found for textKey:', textKey);
      return;
    }
    
    const highlight = askedData.highlight;
    
    // Close ChatDialog if it's open for this textKey or related textKey
    if (typeof ChatDialog !== 'undefined' && ChatDialog.isOpen) {
      console.log('[TextSelector] ChatDialog is open - currentTextKey:', ChatDialog.currentTextKey, 'removing textKey:', textKey);
      
      // Check if the current chat is related to this textKey
      // ChatDialog might have textKey in format: textKey-selected, textKey-generic, or exact match
      const shouldClose = ChatDialog.currentTextKey === textKey || 
                         ChatDialog.currentTextKey?.startsWith(textKey + '-') ||
                         ChatDialog.currentTextKey?.includes(textKey) ||
                         textKey?.includes(ChatDialog.currentTextKey?.split('-').slice(0, -1).join('-'));
      
      if (shouldClose) {
        console.log('[TextSelector] Closing ChatDialog for asked text - currentTextKey:', ChatDialog.currentTextKey, 'removing textKey:', textKey);
        ChatDialog.close();
      } else {
        console.log('[TextSelector] ChatDialog open but for different text - currentTextKey:', ChatDialog.currentTextKey, 'removing textKey:', textKey);
        console.log('[TextSelector] Not closing chat as textKeys do not match');
      }
    }
    
    // Remove icons wrapper
    const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
    if (iconsWrapper) {
      iconsWrapper.remove();
    }
    
    // Remove highlight completely
    this.removeHighlight(highlight);
    
    // Remove from askedTexts map
    this.askedTexts.delete(textKey);
    
    // Remove from textToHighlights map if present
    this.textToHighlights.delete(textKey);
    
    // Remove from analysis data structure for current tab
    ButtonPanel.removeAskedTextFromAnalysisData(textKey);
    
    // Update button states to hide "Remove meanings" if no more data exists
    ButtonPanel.updateButtonStatesFromSelections();
    
    console.log('[TextSelector] Text removed from askedTexts:', textKey);
  },

  /**
   * Remove text from simplifiedTexts and restore to normal
   * @param {string} textKey - The text key
   */
  removeFromSimplifiedTexts(textKey) {
    const simplifiedData = this.simplifiedTexts.get(textKey);
    
    if (!simplifiedData) {
      console.warn('[TextSelector] No simplified text found for textKey:', textKey);
      return;
    }
    
    const highlight = simplifiedData.highlight;
    
    if (!highlight) {
      console.warn('[TextSelector] No highlight element found for simplified text:', textKey);
      this.simplifiedTexts.delete(textKey);
      return;
    }
    
    // Close ChatDialog if it's open (always close when green cross is clicked)
    if (typeof ChatDialog !== 'undefined' && ChatDialog.isOpen) {
      console.log('[TextSelector] ChatDialog is open - closing it when green cross clicked');
      console.log('[TextSelector] Current textKey:', ChatDialog.currentTextKey, 'removing textKey:', textKey);
      ChatDialog.close();
    }
    
    // Immediately add disappearing animation to green cross button (same as purple cross)
    const greenCrossBtn = highlight.querySelector('.vocab-text-remove-green-btn');
    if (greenCrossBtn && !greenCrossBtn.classList.contains('button-disappearing')) {
      greenCrossBtn.classList.add('button-disappearing');
      // Remove button after animation completes (300ms)
      setTimeout(() => {
        greenCrossBtn.remove();
      }, 300);
    }
    
    // Find icons wrapper
    let iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
    if (!iconsWrapper) {
      // Check if icons are in modal overlay (for modal context)
      const modalOverlay = ButtonPanel.topicsModal.customContentModal.overlay;
      if (modalOverlay) {
        iconsWrapper = window.safeQueryByDataTextKey('[data-text-key]', textKey, modalOverlay);
      }
      // Check if icons are in document body (for main webpage context)
      if (!iconsWrapper) {
        iconsWrapper = window.safeQueryByDataTextKey('[data-text-key]', textKey, document.body);
      }
    }
    
    // Trigger vanishing animations
    if (iconsWrapper) {
      iconsWrapper.classList.add('vocab-icons-vanishing');
    }
    // Only animate the underline color, not the text itself
    highlight.classList.add('vocab-text-vanishing');
    
    // Immediately add disappearing class to prevent purple underline from appearing
    // This ensures if purple underline becomes visible after simplified class is removed,
    // it will already be in disappearing state
    highlight.classList.add('underline-disappearing');
    
    // Also add disappearing class to all child elements with green background (vocab-word-explained)
    // This ensures the underline is removed from words with green background too
    const explainedWords = highlight.querySelectorAll('.vocab-word-explained');
    explainedWords.forEach(wordElement => {
      // Ensure the underline is removed from these elements by explicitly setting text-decoration
      wordElement.style.setProperty('text-decoration', 'none', 'important');
      wordElement.style.setProperty('text-decoration-line', 'none', 'important');
      wordElement.style.setProperty('text-decoration-color', 'transparent', 'important');
    });
    
    // Wait for green underline animation to complete before removing elements
    setTimeout(() => {
      // Remove icons wrapper
      if (iconsWrapper) {
        iconsWrapper.remove();
      }
      
      // Remove the simplified class (green underline) from the main highlight
      // After this, if purple underline is visible, it will already be fading out
      highlight.classList.remove('vocab-text-simplified', 'vocab-text-vanishing');
      
      // Explicitly remove underline from all child elements, especially those with green background
      // This ensures the underline is completely removed regardless of green background
      const allChildElements = highlight.querySelectorAll('*');
      allChildElements.forEach(childElement => {
        // Remove any text-decoration that might be inherited or applied
        childElement.style.removeProperty('text-decoration');
        childElement.style.removeProperty('text-decoration-line');
        childElement.style.removeProperty('text-decoration-color');
        childElement.style.removeProperty('text-decoration-style');
        childElement.style.removeProperty('text-decoration-thickness');
        // Also remove simplified class if it exists on child elements
        childElement.classList.remove('vocab-text-simplified');
      });
      
      // Continue with removal - purple underline should already be disappearing
      // Wait for purple underline to fade out before actually removing
      setTimeout(() => {
        this.removeHighlight(highlight);
      }, 300); // Wait for purple underline fade-out animation
    }, 300); // Wait for green underline fade-out animation
    
    // Remove from simplifiedTexts map
    this.simplifiedTexts.delete(textKey);
    console.log('[TextSelector] Removed from simplifiedTexts map:', textKey);
    
    // Remove from textToHighlights map if present
    this.textToHighlights.delete(textKey);
    console.log('[TextSelector] Removed from textToHighlights map:', textKey);
    
    // Remove from analysis data structure for current tab
    ButtonPanel.removeSimplifiedTextFromAnalysisData(textKey);
    
    // Update button states to hide "Remove meanings" if no more data exists
    ButtonPanel.updateButtonStatesFromSelections();
    
    console.log('[TextSelector] Text removal completed for:', textKey);
  },
  
  /**
   * Create green remove button for asked texts
   * @param {string} textKey - The text key
   * @returns {HTMLElement} Button element
   */
  createGreenRemoveButtonForAskedText(textKey) {
    const btn = document.createElement('button');
    btn.className = 'vocab-text-remove-green-btn';
    btn.setAttribute('aria-label', 'Remove asked text');
    btn.innerHTML = this.createGreenRemoveIcon();
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[TextSelector] Green remove button clicked for asked text:', textKey);
      this.removeFromAskedTexts(textKey);
    });
    
    return btn;
  },

  /**
   * Create green remove button for simplified texts
   * @param {string} textKey - The text key
   * @returns {HTMLElement} Button element
   */
  createGreenRemoveButtonForSimplifiedText(textKey) {
    const btn = document.createElement('button');
    btn.className = 'vocab-text-remove-green-btn';
    btn.setAttribute('aria-label', 'Remove simplified text');
    btn.innerHTML = this.createGreenRemoveIcon();
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[TextSelector] Green remove button clicked for simplified text:', textKey);
      this.removeFromSimplifiedTexts(textKey);
    });
    
    return btn;
  },

  /**
   * Create a chat button for the highlight
   * @param {string} textKey - The text key
   * @param {boolean} isGreen - Whether to use green color (default: false for purple)
   * @returns {HTMLElement}
   */
  createChatButton(textKey, isGreen = false) {
    const btn = document.createElement('button');
    btn.className = isGreen ? 'vocab-text-chat-btn vocab-text-chat-btn-green chat-breathing' : 'vocab-text-chat-btn chat-breathing';
    btn.setAttribute('aria-label', 'Open chat');
    btn.innerHTML = this.createChatIcon(isGreen);
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Get text from askedTexts or textToHighlights
      const askedData = this.askedTexts.get(textKey);
      const highlight = askedData ? askedData.highlight : this.textToHighlights.get(textKey);
      
      if (highlight) {
        // Use green pulsate if it's a green icon (from askedTexts)
        this.pulsateText(highlight, isGreen);
        
        // Open chat dialog with selected context
        const originalText = highlight.textContent.replace(/\s+/g, ' ').trim();
        ChatDialog.open(originalText, textKey, 'ask', null, 'selected');
      }
    });
    
    // Remove breathing class after animation completes
    setTimeout(() => {
      btn.classList.remove('chat-breathing');
    }, 1600); // Match animation duration
    
    return btn;
  },
  
  /**
   * Create chat icon SVG - Solid circle with white chat icon (bigger)
   * @param {boolean} isGreen - Whether to use green color (default: false for purple)
   * @returns {string} SVG markup
   */
  createChatIcon(isGreen = false) {
    const color = isGreen ? '#22c55e' : '#9527F5';
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="10" cy="10" r="9" fill="${color}"/>
        <path d="M10 6C8.239 6 6.5 7.459 6.5 8.875C6.5 9.681 6.994 10.4 7.348 10.856L6.744 12.246C6.664 12.39 6.664 12.569 6.744 12.714C6.825 12.858 6.999 12.951 7.181 12.951C7.241 12.951 7.301 12.939 7.358 12.915L8.571 12.464C9.404 12.656 10.318 12.75 11.25 12.75C12.511 12.75 13.75 11.791 13.75 10.375C13.75 8.959 12.511 6 10 6Z" fill="white"/>
        <circle cx="8" cy="9.25" r="0.8" fill="${color}"/>
        <circle cx="10" cy="9.25" r="0.8" fill="${color}"/>
        <circle cx="12" cy="9.25" r="0.8" fill="${color}"/>
      </svg>
    `;
  },
  
  /**
   * Create book icon button for simplified texts
   * @param {string} textKey - The text key
   * @returns {HTMLElement}
   */
  createBookButton(textKey) {
    const btn = document.createElement('button');
    btn.className = 'vocab-text-book-btn book-breathing';
    btn.setAttribute('aria-label', 'View simplified text');
    btn.innerHTML = this.createBookIcon();
    
    // Add click handler with improved toggle logic - use capture phase to ensure it fires
    // Use a flag to prevent double-triggering from multiple event handlers
    let isProcessing = false;
    
    const handleBookClick = (e) => {
      // Prevent double-triggering
      if (isProcessing) {
        console.log('[TextSelector] Book click already processing, ignoring duplicate event');
        return;
      }
      
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation(); // Prevent other handlers from interfering
      
      isProcessing = true;
      
      console.log('[TextSelector] Book icon clicked for:', textKey);
      
      // Get simplified text data first
      const simplifiedData = this.simplifiedTexts.get(textKey);
      if (!simplifiedData) {
        console.warn('[TextSelector] No simplified data found for textKey:', textKey);
        isProcessing = false;
        return;
      }
      
      // Comprehensive check if chat dialog is already open for this text segment
      // Handle all possible textKey format variations
      // Also check if dialog is currently opening (expanding) to prevent race conditions
      let isChatOpenForThisText = false;
      let isDialogOpening = false;
      
      if (typeof ChatDialog !== 'undefined') {
        // Check if dialog is currently opening (expanding animation)
        if (ChatDialog.dialogContainer && ChatDialog.dialogContainer.classList.contains('expanding')) {
          isDialogOpening = true;
          console.log('[TextSelector] Dialog is currently opening (expanding), waiting...');
        }
        
        // Only check if dialog is open if it's not currently opening
        if (ChatDialog.isOpen && ChatDialog.currentTextKey && !isDialogOpening) {
          const currentKey = ChatDialog.currentTextKey;
          const originalTextKey = textKey;
          
          // Strategy 1: Exact match
          if (currentKey === originalTextKey) {
            isChatOpenForThisText = true;
          }
          // Strategy 2: Match with -selected suffix
          else if (currentKey === `${originalTextKey}-selected`) {
            isChatOpenForThisText = true;
          }
          // Strategy 3: Match when currentKey starts with textKey
          else if (currentKey.startsWith(originalTextKey + '-')) {
            isChatOpenForThisText = true;
          }
          // Strategy 4: Match when textKey is part of currentKey (for complex formats)
          else if (currentKey.includes(originalTextKey)) {
            isChatOpenForThisText = true;
          }
          // Strategy 5: Match by simplifiedData (textStartIndex and textLength)
          else if (simplifiedData && simplifiedData.textStartIndex !== undefined && simplifiedData.textLength !== undefined) {
            // Extract start index and length from currentKey if it's in format: contentType-tabId-startIndex-length
            const currentKeyParts = currentKey.split('-');
            if (currentKeyParts.length >= 4) {
              const currentStartIndex = parseInt(currentKeyParts[currentKeyParts.length - 2]);
              const currentLength = parseInt(currentKeyParts[currentKeyParts.length - 1]);
              
              if (currentStartIndex === simplifiedData.textStartIndex && 
                  currentLength === simplifiedData.textLength) {
                isChatOpenForThisText = true;
              }
            }
            // Strategy 6: Match by checking if currentKey ends with startIndex-length pattern
            const expectedSuffix = `${simplifiedData.textStartIndex}-${simplifiedData.textLength}`;
            if (currentKey.endsWith(expectedSuffix)) {
              isChatOpenForThisText = true;
            }
          }
          // Strategy 7: Reverse check - check if originalTextKey contains parts of currentKey
          if (!isChatOpenForThisText) {
            const currentKeyPartsForBase = currentKey.split('-');
            const originalKeyParts = originalTextKey.split('-');
            if (currentKeyPartsForBase.length >= 2 && originalKeyParts.length >= 2) {
              // Compare base parts (contentType-tabId)
              const currentBase = currentKeyPartsForBase.slice(0, 2).join('-');
              const originalBase = originalKeyParts.slice(0, 2).join('-');
              if (currentBase === originalBase && simplifiedData) {
                // If base matches and we have simplifiedData, check by position
                if (currentKeyPartsForBase.length >= 4) {
                  const currentStartIndex = parseInt(currentKeyPartsForBase[currentKeyPartsForBase.length - 2]);
                  const currentLength = parseInt(currentKeyPartsForBase[currentKeyPartsForBase.length - 1]);
                  if (currentStartIndex === simplifiedData.textStartIndex && 
                      currentLength === simplifiedData.textLength) {
                    isChatOpenForThisText = true;
                  }
                }
              }
            }
          }
          
          console.log('[TextSelector] Toggle check - isOpen:', ChatDialog.isOpen, 'currentTextKey:', currentKey, 'originalTextKey:', originalTextKey, 'isChatOpenForThisText:', isChatOpenForThisText);
        }
      }
      
      // If dialog is currently opening, wait a bit and check again
      if (isDialogOpening) {
        console.log('[TextSelector] Dialog is opening, waiting before checking toggle state...');
        setTimeout(() => {
          isProcessing = false;
          // Re-trigger the click after dialog finishes opening
          setTimeout(() => {
            handleBookClick(e);
          }, 350); // Wait for expansion animation to complete (0.3s + small buffer)
        }, 50);
        return;
      }
      
      if (isChatOpenForThisText) {
        // Chat is already open for this text - close it (toggle off)
        console.log('[TextSelector] Chat dialog is already open for this text, closing it');
        ChatDialog.close();
        isProcessing = false;
        return;
      }
      
      // Chat is not open for this text - open it (toggle on)
        // Pulsate the text
        const highlight = this.textToHighlights.get(textKey);
        if (highlight) {
          this.pulsateText(highlight, true);
        }
        
        // Open ChatDialog in simplified mode with selected context
        // Always use 'selected' context when opening from book icon to ensure expansion animation
      // Note: ChatDialog.open() will handle the toggle if dialog is already open for same text
        ChatDialog.open(simplifiedData.text, textKey, 'simplified', simplifiedData, 'selected');
      
      // Reset processing flag after a delay to allow for state changes
      // Use longer delay to ensure dialog is fully opened before allowing another click
      setTimeout(() => {
        isProcessing = false;
      }, 600); // Wait for dialog to fully open (0.3s animation + buffer)
    };
    
    // Add both click and mousedown handlers to ensure it works on all websites
    // Use capture phase to ensure handlers fire before website handlers
    btn.addEventListener('click', handleBookClick, { capture: true, passive: false });
    btn.addEventListener('mousedown', (e) => {
      // Only trigger on left mouse button and if click handler didn't fire
      if (e.button === 0 && !isProcessing) {
        // Small delay to let click handler run first if it exists
        setTimeout(() => {
          if (!isProcessing) {
            handleBookClick(e);
          }
        }, 10);
      }
    }, { capture: true, passive: false });
    
    // Remove breathing class after animation completes
    setTimeout(() => {
      btn.classList.remove('book-breathing');
    }, 1600); // Match animation duration
    
    return btn;
  },
  
  /**
   * Create book icon SVG - Closed book icon with spine and cover lines (green)
   * @returns {string} SVG markup
   */
  createBookIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- Open book - line art style with curved edges and V-shaped spine -->
        <!-- Left page: curved top edge, slightly curved outer edge, connects to V spine -->
        <path d="M3 6.5Q3 5 5 5Q7 5 10 5.5L10 16.5L3 15.5Q3 11 3 6.5" stroke="#22c55e" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <!-- Right page: curved top edge, slightly curved outer edge, connects to V spine -->
        <path d="M10 5.5Q13 5 15 5Q17 5 17 6.5Q17 11 17 15.5L10 16.5L10 5.5" stroke="#22c55e" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <!-- Spine at bottom forming V shape (connects the two pages) -->
        <path d="M3 15.5L10 16.5L17 15.5" stroke="#22c55e" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>
    `;
  },
  
  /**
   * Create magic-meaning button for text selection
   * @param {string} textKey - The text key
   * @returns {HTMLElement}
   */
  createMagicMeaningButton(textKey) {
    const btn = document.createElement('button');
    btn.className = 'vocab-text-magic-meaning-btn magic-meaning-breathing';
    btn.setAttribute('aria-label', 'Get magic meaning');
    btn.setAttribute('data-text-key', textKey);
    
    // Use inline purple logo SVG (always available, no fetch needed)
    const iconHtml = this.createMagicMeaningIcon();
    btn.innerHTML = iconHtml;
    console.log('[TextSelector] Magic button icon set, length:', iconHtml.length);
    
    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      console.log('MAGIC_MEANING_CLICK');
      console.log('[TextSelector] Magic-meaning button clicked for:', textKey);
      
      // STEP 1: IMMEDIATELY change the clicked button to spinner state (before anything else)
      // This ensures the button stays visible with spinner icon
      btn.classList.add('magic-meaning-loading');
      btn.classList.remove('magic-meaning-breathing');
      btn.innerHTML = this.createSpinnerIcon();
      btn.disabled = true; // Disable button during loading
      btn._textKey = textKey; // Store reference for later
      
      // Check if we have a pending range (button shown but no span created yet)
      let highlight = this.textToHighlights.get(textKey);
      
      // Get button wrapper reference
      const buttonWrapper = this.buttonWrappers?.get(textKey);
      
      // STEP 2: If buttonWrapper exists (floating button on body), change it to spinner too and KEEP IT VISIBLE
      if (buttonWrapper) {
        const wrapperBtn = buttonWrapper.querySelector('.vocab-text-magic-meaning-btn');
        if (wrapperBtn) {
          wrapperBtn.classList.add('magic-meaning-loading');
          wrapperBtn.classList.remove('magic-meaning-breathing');
          wrapperBtn.innerHTML = this.createSpinnerIcon();
          wrapperBtn.disabled = true;
        }
        
        // Keep using absolute positioning - don't switch to fixed
        // The normal scroll handler (updateButtonPosition) will continue to work
        // We just need to make sure it doesn't skip when spinner is showing
        // Actually, we removed the skip logic, so it should work now
        
        // DO NOT REMOVE buttonWrapper - keep it visible with spinner during API call
        // It will be removed later when green book appears
      }
      
      if (!highlight && this.pendingRanges.has(textKey)) {
        // Create the span wrapper now
        const pendingRange = this.pendingRanges.get(textKey);
        const selectedText = pendingRange.toString();
        
        // Create the highlight span (don't remove buttonWrapper - keep it visible)
        highlight = this.highlightRange(pendingRange, selectedText);
        
        // Ensure highlight is added to the map (highlightRange should do this, but verify)
        if (highlight && !this.textToHighlights.has(textKey)) {
          console.warn('[TextSelector] Highlight created but not in map, adding it now');
          this.textToHighlights.set(textKey, highlight);
        }
        
        // Clean up pending data (but keep buttonWrapper visible)
        this.pendingRanges.delete(textKey);
        // DO NOT delete buttonWrapper from buttonWrappers map - keep it for later removal
      }
      
      if (!highlight) {
        console.warn('[TextSelector] No highlight found for textKey:', textKey);
        return;
      }
      
      // Double-check that highlight is in the map before proceeding
      if (!this.textToHighlights.has(textKey)) {
        console.warn('[TextSelector] Highlight exists but not in map, adding it now');
        this.textToHighlights.set(textKey, highlight);
      }
      
      // Do NOT show purple underline - only green underline will appear when vocab-text-simplified class is added
      // Keep underline hidden - it will only show when magic explain adds the simplified class
      
      // Add fast pulsating animation to the text with purple background
      highlight.classList.add('vocab-text-loading');
      
      // Mark highlight as processing to prevent magic button creation in highlightRange setTimeout
      highlight.setAttribute('data-processing-magic-meaning', 'true');
      
      // STEP 3: Ensure any magic button in highlight's iconsWrapper is also in spinner state
      const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
      if (iconsWrapper) {
        const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
        if (magicBtn && !magicBtn.classList.contains('magic-meaning-loading')) {
          magicBtn.classList.add('magic-meaning-loading');
          magicBtn.classList.remove('magic-meaning-breathing');
          magicBtn.innerHTML = this.createSpinnerIcon();
          magicBtn.disabled = true;
        }
      }
      
      // Also set up a watcher to ensure any iconsWrapper created by the setTimeout in highlightRange
      // has its button in loading state (don't remove it)
      const ensureButtonLoadingWatcher = setInterval(() => {
        const newIconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
        if (newIconsWrapper) {
          const magicBtn = newIconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
          if (magicBtn && !magicBtn.classList.contains('magic-meaning-loading')) {
            magicBtn.classList.add('magic-meaning-loading');
            magicBtn.classList.remove('magic-meaning-breathing');
            magicBtn.innerHTML = this.createSpinnerIcon();
            magicBtn.disabled = true;
          }
        }
      }, 50);
      
      // Stop watching after 200ms (enough time for the setTimeout to complete)
      setTimeout(() => {
        clearInterval(ensureButtonLoadingWatcher);
      }, 200);
      
      // Call handleMagicMeaning for this specific text only
      // Ensure highlight is in the map before calling ButtonPanel
      if (!TextSelector.textToHighlights.has(textKey)) {
        console.warn('[TextSelector] Highlight not in map before calling ButtonPanel, adding it now');
        TextSelector.textToHighlights.set(textKey, highlight);
      }
      
      // Small delay to ensure DOM and map are fully updated
      setTimeout(() => {
        ButtonPanel.handleMagicMeaningForText(textKey);
      }, 10);
    });
    
    return btn;
  },
  
  /**
   * Create magic-meaning icon SVG - White sparkle icon (matching main button design)
   * @returns {string} SVG markup
   */
  createMagicMeaningIcon() {
    // Use cached SVG content (same as home-options-btn but purple)
    if (this.purpleLogoSvgContent) {
      // Create a temporary container to parse and modify the SVG
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = this.purpleLogoSvgContent;
      const svgElement = tempDiv.querySelector('svg');
      if (svgElement) {
        // Set size attributes
        svgElement.setAttribute('width', '20');
        svgElement.setAttribute('height', '20');
        svgElement.setAttribute('viewBox', '0 0 293 277'); // Preserve original viewBox
        svgElement.style.display = 'block';
        svgElement.style.pointerEvents = 'none';
        svgElement.style.visibility = 'visible';
        svgElement.style.opacity = '1';
        // Return the modified SVG HTML
        return svgElement.outerHTML;
      }
    }
    // Fallback: return empty placeholder that will be updated when SVG loads
    return '<div style="width: 20px; height: 20px; background: transparent;"></div>';
  },
  
  /**
   * Update all existing magic meaning buttons with loaded SVG
   */
  updateAllMagicMeaningButtons() {
    if (!this.purpleLogoSvgContent) return;
    
    // Find all text magic meaning buttons
    const buttons = document.querySelectorAll('.vocab-text-magic-meaning-btn');
    buttons.forEach(btn => {
      if (!btn.classList.contains('magic-meaning-loading')) {
        btn.innerHTML = this.createMagicMeaningIcon();
      }
    });
  },
  
  /**
   * Create spinner icon SVG for loading state - Purple spinning circle
   * Professional, smooth, standard spinner with thicker visible arc and thinner border
   * @returns {string} SVG markup
   */
  createSpinnerIcon() {
    return `
      <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="9" cy="9" r="7" stroke="#9527F5" stroke-width="0.8" stroke-linecap="round" stroke-dasharray="14 30" opacity="0.15"/>
        <circle cx="9" cy="9" r="7" stroke="#9527F5" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="14 30" stroke-dashoffset="6" opacity="1">
          <animateTransform attributeName="transform" type="rotate" from="0 9 9" to="360 9 9" dur="1s" repeatCount="indefinite"/>
        </circle>
      </svg>
    `;
  },
  
  /**
   * Restore magic meaning button from loading state
   * @param {string} textKey - The text key
   */
  restoreMagicMeaningButton(textKey) {
    // First, try to find in button wrapper (button shown before highlight is created)
    let magicBtn = null;
    const buttonWrapper = this.buttonWrappers?.get(textKey);
    if (buttonWrapper) {
      magicBtn = buttonWrapper.querySelector('.vocab-text-magic-meaning-btn');
    }
    
    // If not found, try to find in highlight
    if (!magicBtn) {
      const highlight = this.textToHighlights.get(textKey);
      if (highlight) {
        magicBtn = highlight.querySelector('.vocab-text-magic-meaning-btn');
      }
    }
    
    // Also try to find by data attribute as fallback
    if (!magicBtn) {
      magicBtn = document.querySelector(`.vocab-text-magic-meaning-btn[data-text-key="${textKey}"]`);
    }
    
    if (magicBtn && magicBtn.classList.contains('magic-meaning-loading')) {
      // Restore button state
      magicBtn.classList.remove('magic-meaning-loading');
      magicBtn.classList.add('magic-meaning-breathing');
      magicBtn.innerHTML = this.createMagicMeaningIcon();
      magicBtn.disabled = false;
      console.log('[TextSelector] Restored magic meaning button from loading state');
    }
  },
  
  /**
   * Pulsate text highlight with color (green for asked texts, purple for selected)
   * @param {HTMLElement} highlight - The highlight element
   * @param {boolean} isGreen - Whether to use green color (default: false for purple)
   */
  pulsateText(highlight, isGreen = false) {
    // Add appropriate pulsate class
    const className = isGreen ? 'vocab-text-pulsate-green' : 'vocab-text-pulsate';
    highlight.classList.add(className);
    
    // Remove class after animation completes (0.6s for purple, 1.2s for green)
    const duration = isGreen ? 1200 : 600;
    setTimeout(() => {
      highlight.classList.remove(className);
    }, duration);
  },
  
  /**
   * Inject CSS styles for text highlights
   */
  injectStyles() {
    const styleId = 'vocab-text-selector-styles';
    
    // Check if styles already injected
    if (document.getElementById(styleId)) {
      return;
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      /* Text highlight wrapper - No underline by default, only shown when magic explain is clicked */
      .vocab-text-highlight {
        position: relative;
        text-decoration-line: none !important; /* No underline by default */
        text-decoration-style: none !important;
        text-decoration-color: transparent !important;
        text-decoration-thickness: 0;
        text-underline-offset: 0;
        cursor: text;
        overflow: visible;
        transition: text-decoration-color 0.3s ease-in-out, opacity 0.3s ease-in-out;
        opacity: 1;
        font-size: inherit !important; /* Preserve original font size */
        font-family: inherit !important; /* Preserve original font family */
        font-weight: inherit !important; /* Preserve original font weight */
        line-height: inherit !important; /* Preserve original line height */
        /* DO NOT set color: inherit on the highlight span - it can interfere with child element colors */
        /* Text nodes will inherit naturally from the highlight span's parent context */
        /* Child elements with inline styles or color classes will maintain their colors */
        letter-spacing: inherit !important; /* Preserve original letter spacing */
        /* When display is block, ensure no margins/padding interfere with child element spacing */
        margin: 0;
        padding: 0;
      }
      
      /* Ensure block-level elements inside highlight maintain their display, spacing, and original font sizes */
      .vocab-text-highlight p,
      .vocab-text-highlight div,
      .vocab-text-highlight h1,
      .vocab-text-highlight h2,
      .vocab-text-highlight h3,
      .vocab-text-highlight h4,
      .vocab-text-highlight h5,
      .vocab-text-highlight h6,
      .vocab-text-highlight section,
      .vocab-text-highlight article,
      .vocab-text-highlight aside,
      .vocab-text-highlight header,
      .vocab-text-highlight footer,
      .vocab-text-highlight nav,
      .vocab-text-highlight main,
      .vocab-text-highlight blockquote,
      .vocab-text-highlight pre,
      .vocab-text-highlight address {
        display: block !important; /* Ensure block-level elements maintain their block display */
        /* DO NOT set margins to inherit - margins don't inherit in CSS */
        /* Let block elements use their original margins from the website's CSS */
        /* Removing margin rules allows the browser to use default/website-defined margins */
        text-decoration: inherit; /* Preserve underline from parent */
        box-sizing: border-box; /* Consistent box model */
        font-family: inherit !important; /* Preserve font family */
        /* DO NOT set font-size: inherit - let block elements use their original font sizes from website CSS */
        /* DO NOT set line-height: inherit - let block elements use their original line heights */
        /* DO NOT set letter-spacing: inherit - let block elements use their original letter spacing */
        /* Block elements should maintain their original computed font sizes and margins, not inherit from the span */
      }
      
      /* Smooth animation for underline appearance - 0.3s duration (not used anymore, kept for compatibility) */
      .vocab-text-highlight.underline-appearing {
        text-decoration-color: transparent !important;
        text-decoration-line: none !important;
        /* No animation - underline should never appear for regular highlights */
      }
      
      /* Smooth animation for underline disappearance - same 0.3s duration */
      .vocab-text-highlight.underline-disappearing {
        text-decoration-color: transparent !important;
        text-decoration-line: none !important;
        animation: none; /* No animation needed since underline is always hidden */
      }
      
      /* Ensure underline stays hidden when simplified text is being removed */
      .vocab-text-highlight.underline-disappearing:not(.vocab-text-simplified) {
        text-decoration-color: transparent !important;
        text-decoration-line: none !important;
        animation: none; /* Keep it transparent */
      }
      
      @keyframes underlineFadeIn {
        0% {
          text-decoration-color: transparent;
        }
        100% {
          text-decoration-color: transparent; /* Always transparent - no purple underline */
        }
      }
      
      @keyframes underlineFadeOut {
        0% {
          text-decoration-color: transparent;
        }
        100% {
          text-decoration-color: transparent;
        }
      }
      
      /* For inline elements inside highlight, maintain underline and inherit font-size */
      /* DO NOT override font-weight or color for formatting elements - let them use their own styles */
      /* Exclude elements with color classes or inline styles from the universal selector */
      /* Block-level elements are handled separately to preserve their original font sizes */
      .vocab-text-highlight span:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight b:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight strong:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight em:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight i:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight u:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight a:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight code:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]),
      .vocab-text-highlight small:not([class*="user-"]):not([class*="rated-"]):not([style*="color"]):not([style*="Color"]) {
        text-decoration: inherit;
        box-sizing: border-box;
        font-size: inherit !important; /* Preserve original font size for inline child elements */
        font-family: inherit !important; /* Preserve original font family for child elements */
        line-height: inherit !important; /* Preserve original line height for child elements */
        letter-spacing: inherit !important; /* Preserve original letter spacing for child elements */
      }
      
      /* Apply base styles to all elements, but exclude color-related elements */
      .vocab-text-highlight * {
        text-decoration: inherit;
        box-sizing: border-box;
      }
      
      /* Ensure formatting elements maintain their bold/italic styling */
      .vocab-text-highlight b,
      .vocab-text-highlight strong {
        font-weight: bold !important; /* Force bold for b and strong tags */
      }
      
      .vocab-text-highlight em,
      .vocab-text-highlight i {
        font-style: italic !important; /* Force italic for em and i tags */
      }
      
      /* Ensure heading tags (h1-h6) maintain their original properties and remain as headings */
      /* Headings should keep their default font-weight (typically bold), font-size, and all other properties */
      /* The block-level CSS rule above already ensures display: block, but we want to be explicit here */
      .vocab-text-highlight h1,
      .vocab-text-highlight h2,
      .vocab-text-highlight h3,
      .vocab-text-highlight h4,
      .vocab-text-highlight h5,
      .vocab-text-highlight h6 {
        /* DO NOT override any font properties - let headings use their original website CSS */
        /* Headings will naturally maintain their font-weight, font-size, line-height, etc. from the website */
        /* The underline decoration is already inherited from the parent highlight span */
        display: block !important; /* Ensure headings remain block-level */
        /* All other properties (font-weight, font-size, color, etc.) come from the website's CSS */
      }
      
      /* Preserve colors on child elements - don't force inherit */
      /* Child elements with inline styles, classes, or default colors will maintain them */
      /* Text nodes will naturally inherit from the highlight span, which inherits from the original parent */
      
      /* Ensure elements with inline color styles maintain their colors */
      /* Inline styles have highest specificity - they will work automatically */
      /* No CSS rule needed - inline styles cannot be overridden by CSS */
      
      /* Ensure elements with color classes maintain their colors AND the underline */
      /* DO NOT override color for these elements - let website's CSS apply */
      /* Ensure underline is preserved for special elements (for green underline when simplified) */
      .vocab-text-highlight a.user-orange,
      .vocab-text-highlight a.rated-user,
      .vocab-text-highlight a[class*="user-orange"],
      .vocab-text-highlight a[class*="user-red"],
      .vocab-text-highlight a[class*="user-blue"],
      .vocab-text-highlight a[class*="user-green"],
      .vocab-text-highlight a[class*="user-purple"],
      .vocab-text-highlight a[class*="user-yellow"],
      .vocab-text-highlight a[class*="user-cyan"],
      .vocab-text-highlight a[class*="user-gray"],
      .vocab-text-highlight a[class*="user-black"],
      .vocab-text-highlight .user-orange,
      .vocab-text-highlight .user-red,
      .vocab-text-highlight .user-blue,
      .vocab-text-highlight .user-green,
      .vocab-text-highlight .user-purple,
      .vocab-text-highlight .user-yellow,
      .vocab-text-highlight .user-cyan,
      .vocab-text-highlight .user-gray,
      .vocab-text-highlight .user-black,
      .vocab-text-highlight .rated-user {
        /* Don't set color at all - let the website's CSS for these classes apply */
        /* The website's CSS should have the same or higher specificity */
        /* By not setting color here, the website's CSS will apply */
        /* No underline by default - only green underline when simplified class is added */
        text-decoration: none !important; /* No underline by default */
        text-decoration-line: none !important;
      }
      
      /* Also ensure elements with inline color styles preserve the underline */
      .vocab-text-highlight [style*="color"],
      .vocab-text-highlight [style*="Color"] {
        /* No underline by default - only green underline when simplified class is added */
        text-decoration: none !important; /* No underline by default */
        text-decoration-line: none !important;
      }
      
      /* Ensure elements with inline color styles work - inline styles have highest specificity */
      /* No CSS rule needed - inline styles cannot be overridden by CSS */
      
      /* Remove button - White circle with purple border and purple cross on top-left */
      .vocab-text-remove-btn {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 18px;
        height: 18px;
        background-color: #FFFFFF !important; /* Fully opaque white background */
        background: #FFFFFF !important; /* Fully opaque white background */
        border: 1px solid #9527F5 !important; /* Thin purple border */
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 1 !important; /* Fully opaque */
        transition: opacity 0.3s ease-in-out, transform 0.1s ease, background-color 0.2s ease, scale 0.3s ease-in-out, border-color 0.2s ease;
        padding: 0;
        z-index: 10000003;
        box-shadow: 0 2px 4px rgba(149, 39, 245, 0.4);
        pointer-events: auto;
        box-sizing: border-box;
      }
      
      /* Smooth animation for button appearance - 0.3s duration (same as underline) */
      .vocab-text-remove-btn.button-appearing {
        opacity: 0;
        transform: scale(0.8);
        animation: buttonFadeIn 0.3s ease-in-out forwards;
      }
      
      /* Smooth animation for button disappearance - 0.3s duration (same as underline) */
      .vocab-text-remove-btn.button-disappearing {
        animation: buttonFadeOut 0.3s ease-in-out forwards;
      }
      
      @keyframes buttonFadeIn {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      
      @keyframes buttonFadeOut {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(0.8);
        }
      }
      
      .vocab-text-highlight:hover .vocab-text-remove-btn {
        opacity: 1 !important;
      }
      
      .vocab-text-remove-btn:hover {
        transform: scale(1.15);
        opacity: 1 !important; /* Fully opaque on hover */
        background-color: #FFFFFF !important; /* Keep fully opaque white background on hover */
        background: #FFFFFF !important; /* Keep fully opaque white background on hover */
        border-color: #7a1fd9 !important; /* Slightly darker purple border on hover */
      }
      
      .vocab-text-remove-btn:active {
        transform: scale(0.95);
      }
      
      .vocab-text-remove-btn svg {
        pointer-events: none;
        display: block;
        width: 10px;
        height: 10px;
      }
      
      /* Remove purple border from cross button when text is loading (spinner active) */
      .vocab-text-highlight.vocab-text-loading .vocab-text-remove-btn {
        border: none !important;
      }
      
      /* Make cross icon green when text has green dashed underline (simplified/explained) */
      .vocab-text-highlight.vocab-text-simplified .vocab-text-remove-btn {
        border-color: #22c55e !important; /* Green border */
        box-shadow: 0 2px 4px rgba(34, 197, 94, 0.4) !important; /* Green shadow */
      }
      
      .vocab-text-highlight.vocab-text-simplified .vocab-text-remove-btn:hover {
        border-color: #16a34a !important; /* Darker green border on hover */
      }
      
      /* Make cross icon green - use multiple selectors to ensure it overrides inline styles */
      .vocab-text-highlight.vocab-text-simplified .vocab-text-remove-btn svg path,
      .vocab-text-highlight.vocab-text-simplified .vocab-text-remove-btn svg > path {
        stroke: #22c55e !important; /* Green cross icon */
        fill: none !important;
      }
      
      /* Also target the SVG element itself to ensure green color */
      .vocab-text-highlight.vocab-text-simplified .vocab-text-remove-btn svg {
        color: #22c55e !important;
      }
      
      /* Wrapper containers for icon groups */
      .vocab-text-icons-wrapper {
        position: absolute !important; /* Force absolute positioning */
        display: flex !important;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        z-index: 10000003 !important;
        animation: vocab-icon-appear 0.4s ease-out;
        pointer-events: auto !important;
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        margin: 0 !important; /* Remove any margins */
        padding: 0 !important; /* Remove any padding */
        width: auto !important; /* Auto width */
        height: auto !important; /* Auto height */
        min-width: 0 !important; /* No min-width */
        max-width: none !important; /* No max-width */
      }
      
      /* Magic meaning button wrapper - positioned at END (right side) of selected text */
      .vocab-text-icons-wrapper-magic {
        right: -45px !important; /* Position on right side (end of text), outside text */
        left: auto !important; /* Ensure left is not set */
        top: 0px !important; /* Align with top of text */
      }
      
      /* Book icon wrapper - positioned at TOP-LEFT of selected text */
      .vocab-text-icons-wrapper-book {
        left: -45px !important; /* Position on left side, outside text */
        right: auto !important; /* Ensure right is not set */
        top: 0px !important; /* Align with top of text */
      }

      /* Modal context: enhanced styling */
      .vocab-custom-content-modal .vocab-text-icons-wrapper {
        z-index: 10000005;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        padding: 4px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }
      
      /* Modal context: magic meaning button wrapper - positioned at END (right side) */
      .vocab-custom-content-modal .vocab-text-icons-wrapper-magic {
        right: -50px !important; /* Position on right side (end of text) in modal context */
        left: auto !important; /* Ensure left is not set */
        top: -2px !important; /* Slight offset for modal */
      }
      
      /* Modal context: book icon wrapper - positioned at TOP-LEFT */
      .vocab-custom-content-modal .vocab-text-icons-wrapper-book {
        left: -50px !important; /* Position on left side in modal context */
        right: auto !important; /* Ensure right is not set */
        top: -2px !important; /* Slight offset for modal */
      }
      
      /* Chat button - Solid purple circle with white chat icon on top-left (bigger) */
      /* Smooth icon appearance animation - slide from left */
      @keyframes vocab-icon-appear {
        0% {
          opacity: 0;
          transform: translateX(-15px) scale(0.8); /* Slide from left */
        }
        60% {
          transform: translateX(0) scale(1.05);
        }
        100% {
          opacity: 0.95;
          transform: translateX(0) scale(1);
        }
      }
      
      .vocab-text-chat-btn {
        position: relative;
        width: 28px;
        height: 28px;
        background: transparent;
        border: none;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.95;
        transition: opacity 0.2s ease, transform 0.1s ease;
        padding: 0;
        flex-shrink: 0;
      }
      
      .vocab-text-highlight:hover .vocab-text-icons-wrapper {
        opacity: 1;
      }
      
      .vocab-text-chat-btn:hover {
        transform: scale(1.15);
        opacity: 1;
      }
      
      .vocab-text-chat-btn:active {
        transform: scale(0.95);
      }
      
      .vocab-text-chat-btn svg {
        pointer-events: none;
        display: block;
        width: 28px;
        height: 28px;
      }
      
      /* Book button - Closed book icon on top-left */
      .vocab-text-book-btn {
        position: relative !important;
        width: 22px !important;
        height: 22px !important;
        min-width: 22px !important;
        min-height: 22px !important;
        max-width: 22px !important;
        max-height: 22px !important;
        background: #FFFFFF !important; /* Fully non-transparent white background */
        border: 2px solid #22c55e !important; /* Green border */
        border-radius: 50% !important; /* Circular shape */
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        opacity: 1 !important; /* Start fully visible to prevent glitchy appearance */
        visibility: visible !important; /* Ensure button is visible */
        transition: opacity 0.2s ease, transform 0.15s ease !important;
        padding: 0 !important;
        flex-shrink: 0 !important;
        box-shadow: 0 2px 4px rgba(34, 197, 94, 0.2) !important; /* Subtle green shadow for depth */
        pointer-events: auto !important; /* Ensure button is clickable on all websites */
        z-index: 10000004 !important; /* Ensure button is above other elements */
        user-select: none !important; /* Prevent text selection */
        -webkit-user-select: none !important;
        will-change: transform, opacity !important; /* Optimize animation performance */
        box-sizing: border-box !important;
        margin: 0 !important;
      }
      
      .vocab-text-book-btn:hover {
        transform: scale(1.1);
        opacity: 1;
      }
      
      .vocab-text-book-btn:active {
        transform: scale(0.9);
      }
      
      .vocab-text-book-btn svg {
        pointer-events: none !important;
        display: block !important;
        width: 18px !important;
        height: 18px !important;
        min-width: 18px !important;
        min-height: 18px !important;
        max-width: 18px !important;
        max-height: 18px !important;
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1)) !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-text-book-btn svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      /* Book button breathing animation when first appears */
      .vocab-text-book-btn.book-breathing {
        animation: bookBreathing 1.6s ease-in-out;
        animation-fill-mode: both; /* Ensure animation applies from start */
        opacity: 1 !important; /* Start fully visible */
        visibility: visible !important; /* Ensure visible during animation */
      }
      
      /* Magic-meaning button - White background with logo icon */
      .vocab-text-magic-meaning-btn {
        position: relative !important;
        width: 28px !important;
        height: 28px !important;
        min-width: 28px !important; /* Ensure minimum width */
        min-height: 28px !important; /* Ensure minimum height */
        max-width: 28px !important; /* Ensure maximum width */
        max-height: 28px !important; /* Ensure maximum height */
        aspect-ratio: 1 / 1 !important; /* Force perfect square/circle */
        background:rgb(255, 255, 255) !important; /* Non-transparent white background */
        border: none !important; /* No border */
        border-radius: 50% !important; /* Circular shape */
        display: flex !important;
        align-items: center;
        justify-content: center;
        cursor: pointer !important;
        opacity: 1;
        transition: opacity 0.2s ease, transform 0.15s ease, background-color 0.2s ease;
        padding: 0 !important;
        flex-shrink: 0;
        box-sizing: border-box !important; /* Include border in width/height */
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4) !important; /* Purple shadow */
        margin: 0 !important; /* No margin */
      }
      
      /* Magic-meaning button continuous breathing animation */
      .vocab-text-magic-meaning-btn.magic-meaning-breathing {
        animation: magicMeaningBreathingContinuous 3s ease-in-out infinite;
      }
      
      @keyframes magicMeaningBreathingContinuous {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
      
      /* Appearing animation */
      @keyframes magicMeaningAppear {
        from {
          transform: scale(0);
        }
        to {
          transform: scale(1);
        }
      }
      
      /* Disappearing animation */
      @keyframes magicMeaningDisappear {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(0);
        }
      }
      
      .vocab-text-magic-meaning-btn.magic-meaning-appearing {
        animation: magicMeaningAppear 0.2s ease-out forwards;
      }
      
      .vocab-text-magic-meaning-btn.magic-meaning-disappearing {
        animation: magicMeaningDisappear 0.2s ease-in forwards;
      }
      
      .vocab-text-magic-meaning-btn:hover {
        opacity: 1;
        background-color: #FFFFFF !important; /* Keep white background on hover */
        animation: magicMeaningBreathingContinuous 3s ease-in-out infinite; /* Keep breathing on hover */
      }
      
      .vocab-text-magic-meaning-btn:active {
        transform: scale(0.9);
      }
      
      .vocab-text-magic-meaning-btn img,
      .vocab-text-magic-meaning-btn svg {
        pointer-events: none !important;
        display: block !important;
        width: 20px !important;
        height: 20px !important;
        object-fit: contain !important;
        flex-shrink: 0 !important;
        max-width: 20px !important;
        max-height: 20px !important;
        visibility: visible !important;
        opacity: 1 !important;
        position: relative !important;
        z-index: 1 !important;
      }
      
      .vocab-text-magic-meaning-btn svg path {
        visibility: visible !important;
        opacity: 1 !important;
        display: block !important;
      }
      
      /* Loading state - white background with purple border and spinning icon */
      .vocab-text-magic-meaning-btn.magic-meaning-loading {
        background: #FFFFFF !important; /* Fully non-transparent white */
        border: 2px solid #9527F5 !important; /* Purple border */
        animation: none !important; /* Remove breathing animation */
        cursor: not-allowed !important;
        opacity: 1 !important;
      }
      
      .vocab-text-magic-meaning-btn.magic-meaning-loading img {
        width: 18px;
        height: 18px;
        filter: none;
        transform: none;
      }
      
      /* Spinner container for magic-meaning button during API call */
      .vocab-magic-meaning-spinner-container {
        position: relative !important;
        width: 32px !important;
        height: 32px !important;
        min-width: 32px !important; /* Ensure minimum width */
        min-height: 32px !important; /* Ensure minimum height */
        max-width: 32px !important; /* Ensure maximum width */
        max-height: 32px !important; /* Ensure maximum height */
        aspect-ratio: 1 / 1 !important; /* Force perfect square/circle */
        background: white !important; /* Circular white opaque container */
        border: none !important; /* No border */
        border-radius: 50% !important; /* Circular shape */
        display: block !important; /* Block display for absolute child positioning */
        flex-shrink: 0 !important;
        box-shadow: 0 2px 4px rgba(149, 39, 245, 0.2); /* Subtle purple shadow */
        box-sizing: border-box !important; /* Include border in width/height */
        padding: 0 !important; /* No padding */
        margin: 0 !important; /* No margin */
        overflow: visible !important; /* Ensure spinner is visible */
        line-height: 0 !important; /* Remove line height */
        vertical-align: middle !important; /* Vertical alignment */
      }
      
      /* Spinner - dark purple spinning circle */
      .vocab-magic-meaning-spinner {
        position: absolute !important; /* Use absolute positioning for perfect centering */
        width: 18px !important;
        height: 18px !important;
        min-width: 18px !important; /* Ensure minimum width */
        min-height: 18px !important; /* Ensure minimum height */
        max-width: 18px !important; /* Ensure maximum width */
        max-height: 18px !important; /* Ensure maximum height */
        aspect-ratio: 1 / 1 !important; /* Force perfect square/circle */
        border-width: 2px 2px 2px 2px !important; /* Uniform border width on all sides */
        border-style: solid !important; /* Solid border style */
        border-color: rgba(149, 39, 245, 0.2) !important; /* Light purple border */
        border-top-color: #9527F5 !important; /* Dark purple top border for spinner effect */
        border-radius: 50% !important; /* Perfect circle */
        animation: vocab-magic-spinner-spin 0.8s linear infinite !important; /* Ensure animation runs */
        box-sizing: border-box !important; /* Include border in width/height */
        padding: 0 !important; /* No padding */
        margin: 0 !important; /* No margin */
        flex-shrink: 0 !important; /* Prevent shrinking */
        display: block !important; /* Block display */
        top: 50% !important; /* Center vertically */
        left: 50% !important; /* Center horizontally */
        transform-origin: center center !important; /* Rotation center */
        line-height: 0 !important; /* Remove line height */
        vertical-align: middle !important; /* Vertical alignment */
        overflow: visible !important; /* Allow spinner to be visible */
        will-change: transform !important; /* Optimize animation */
        /* Initial transform will be set by animation */
      }
      
      @keyframes vocab-magic-spinner-spin {
        0% {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        100% {
          transform: translate(-50%, -50%) rotate(360deg);
        }
      }
      
      @keyframes bookBreathing {
        0% {
          transform: scale(1);
          opacity: 0.7;
        }
        25% {
          transform: scale(1.3);
          opacity: 1;
        }
        50% {
          transform: scale(1);
          opacity: 0.8;
        }
        75% {
          transform: scale(1.3);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      /* Chat button breathing animation when first appears */
      .vocab-text-chat-btn.chat-breathing {
        animation: chatBreathing 1.6s ease-in-out;
      }
      
      @keyframes chatBreathing {
        0% {
          transform: scale(1);
          opacity: 0.7;
        }
        25% {
          transform: scale(2.0);
          opacity: 1;
        }
        50% {
          transform: scale(1);
          opacity: 0.8;
        }
        75% {
          transform: scale(2.0);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      /* Green remove button - green cross on white circular background with green border */
      .vocab-text-remove-green-btn {
        position: relative !important;
        width: 18px !important;
        height: 18px !important;
        min-width: 18px !important;
        min-height: 18px !important;
        max-width: 18px !important;
        max-height: 18px !important;
        background-color: #FFFFFF !important; /* Fully opaque white background */
        background: #FFFFFF !important; /* Fully opaque white background */
        border: 1px solid #22c55e !important; /* Green border */
        border-radius: 50% !important; /* Circular shape */
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        opacity: 1 !important; /* Fully opaque */
        transition: opacity 0.2s ease, transform 0.15s ease, background-color 0.2s ease, border-color 0.2s ease !important;
        padding: 0 !important;
        flex-shrink: 0 !important;
        box-sizing: border-box !important;
        box-shadow: 0 1px 3px rgba(34, 197, 94, 0.2) !important;
        margin: 0 !important;
      }
      
      .vocab-text-remove-green-btn:hover {
        transform: scale(1.15);
        opacity: 1 !important; /* Fully opaque on hover */
        background-color: #FFFFFF !important; /* Keep fully opaque white background on hover */
        background: #FFFFFF !important; /* Keep fully opaque white background on hover */
        border-color: #16a34a !important; /* Slightly darker green border on hover */
      }
      
      .vocab-text-remove-green-btn:active {
        transform: scale(0.95);
      }
      
      .vocab-text-remove-green-btn.button-disappearing {
        animation: buttonFadeOut 0.3s ease-in-out forwards;
      }
      
      .vocab-text-remove-green-btn svg {
        pointer-events: none !important;
        display: block !important;
        width: 10px !important;
        height: 10px !important;
        min-width: 10px !important;
        min-height: 10px !important;
        max-width: 10px !important;
        max-height: 10px !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-text-remove-green-btn svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      /* Dark green dashed underline for simplified texts - darker green */
      .vocab-text-simplified {
        text-decoration-line: underline !important; /* Show underline when simplified */
        text-decoration-color: #16a34a !important; /* Darker green */
        text-decoration-style: dashed !important;
        text-decoration-thickness: 1.1px !important; /* Original thickness */
        text-underline-offset: 2px !important; /* Offset for better visibility */
        transition: text-decoration-color 0.3s ease-out;
      }
      
      /* Ensure words with green background inside simplified text still show the underline */
      /* But allow underline to be removed when simplified class is removed */
      .vocab-text-simplified .vocab-word-explained {
        text-decoration: inherit !important; /* Inherit underline from parent */
        text-decoration-line: inherit !important;
        text-decoration-color: inherit !important;
        text-decoration-style: inherit !important;
        text-decoration-thickness: inherit !important;
      }
      
      /* When simplified text is vanishing, ensure all child elements also remove underline */
      .vocab-text-simplified.vocab-text-vanishing .vocab-word-explained,
      .vocab-text-simplified.underline-disappearing .vocab-word-explained {
        text-decoration-color: transparent !important;
        text-decoration-line: none !important;
      }
      
      /* Vanishing animation for simplified text */
      .vocab-text-simplified.vocab-text-vanishing {
        text-decoration-color: transparent !important;
        transition: text-decoration-color 0.3s ease-out;
      }
      
      /* When simplified class is removed, ensure underline is removed from all children */
      .vocab-text-highlight:not(.vocab-text-simplified) .vocab-word-explained {
        text-decoration: none !important;
        text-decoration-line: none !important;
        text-decoration-color: transparent !important;
      }
      
      /* Vanishing animation for icons wrapper */
      .vocab-text-icons-wrapper.vocab-icons-vanishing {
        opacity: 0;
        transform: scale(0.8) translateY(-10px);
        pointer-events: none;
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        animation: none; /* Disable appearance animation when vanishing */
      }
      
      /* Pulsate animation for text highlights - light purple */
      @keyframes vocab-text-pulsate {
        0% {
          background-color: transparent;
        }
        50% {
          background-color: rgba(196, 181, 253, 0.7); /* Purple with slight transparency - lighter shade */
        }
        100% {
          background-color: transparent;
        }
      }
      
      .vocab-text-pulsate {
        animation: vocab-text-pulsate 0.6s ease-in-out;
      }
      
      /* Loading animation - pulsating light purple background (fast) */
      @keyframes vocab-text-loading-breathe {
        0%, 100% {
          background-color: transparent;
        }
        50% {
          background-color: rgba(196, 181, 253, 0.7); /* Purple with slight transparency - lighter shade */
        }
      }
      
      .vocab-text-loading {
        animation: vocab-text-loading-breathe 0.75s ease-in-out infinite;
        text-decoration: none !important;
        border-radius: 3px;
      }
      
      /* Pulsate animation for text highlights - light green (pulsates twice) */
      @keyframes vocab-text-pulsate-green {
        0% {
          background-color: transparent;
        }
        25% {
          background-color: rgba(34, 197, 94, 0.15);
        }
        50% {
          background-color: transparent;
        }
        75% {
          background-color: rgba(34, 197, 94, 0.15);
        }
        100% {
          background-color: transparent;
        }
      }
      
      .vocab-text-pulsate-green {
        animation: vocab-text-pulsate-green 1.2s ease-in-out;
      }
      
      /* Notification banner at top right */
      .vocab-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fee2e2;
        color: #dc2626;
        padding: 12px 40px 12px 20px;
        border-radius: 12px;
        border: 1px solid #dc2626;
        font-size: 14px;
        font-weight: 500;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        box-shadow: none;
        z-index: 9999999;
        opacity: 0;
        transform: translateX(400px);
        transition: opacity 0.3s ease, transform 0.3s ease;
        pointer-events: all;
        display: flex;
        align-items: center;
        gap: 12px;
        max-width: 400px;
        word-wrap: break-word;
      }
      
      .vocab-notification.visible {
        opacity: 1;
        transform: translateX(0);
      }
      
      /* Close button inside notification */
      .vocab-notification-close {
        position: absolute;
        left: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        background: none;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.6;
        transition: opacity 0.2s ease, transform 0.1s ease;
        padding: 0;
      }
      
      .vocab-notification-close:hover {
        opacity: 1;
        transform: translateY(-50%) scale(1.1);
      }
      
      .vocab-notification-close:active {
        transform: translateY(-50%) scale(0.9);
      }
      
      .vocab-notification-close svg {
        pointer-events: none;
        display: block;
        stroke: #dc2626;
      }
      
      /* Notification message text */
      .vocab-notification-message {
        margin-left: 24px;
      }
      
      /* Notification types */
      .vocab-notification-error {
        background: #fee2e2;
        color: #dc2626;
        border: 1px solid #dc2626;
      }
      
      .vocab-notification-success {
        background: #e8f5e8;
        color: #2e7d32;
        border-left: 4px solid #2e7d32;
      }
      
      .vocab-notification-info {
        background: #e3f2fd;
        color: #1565c0;
        border-left: 4px solid #1565c0;
      }
      
      /* Top-right ask-about-page button */
      .vocab-ask-about-page-btn {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 48px;
        height: 48px;
        background: #9527F5;
        border: 2px solid white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.95;
        transition: opacity 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        padding: 0;
        z-index: 10000000;
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4);
        pointer-events: auto;
        user-select: none;
        -webkit-user-select: none;
      }
      
      /* Hidden state - button is off-screen to the right with slide-out animation */
      .vocab-ask-about-page-btn-hidden {
        transform: translateX(100px);
        opacity: 0;
        pointer-events: none;
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease;
      }
      
      /* Visible state - button slides in from the right */
      .vocab-ask-about-page-btn-visible {
        transform: translateX(0);
        opacity: 0.95;
        pointer-events: auto;
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease;
      }
      
      .vocab-ask-about-page-btn-visible:hover {
        transform: translateX(0) scale(1.1);
        opacity: 1;
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.6);
      }
      
      .vocab-ask-about-page-btn-visible:active {
        transform: translateX(0) scale(0.95);
      }
      
      .vocab-ask-about-page-btn svg {
        pointer-events: none;
        display: block;
        width: 24px;
        height: 24px;
      }
      
      /* Home options container - attached to right edge, positioned below ask-about-page button */
      .home-options-container {
        position: fixed !important;
        top: 78px !important; /* Below ask-about-page button: 20px (top) + 48px (height) + 10px (gap) */
        right: -25px !important; /* Half off-screen to create protruding effect, flat edge at screen edge */
        z-index: 10000000 !important;
        display: flex !important;
        flex-direction: row-reverse !important; /* Reverse order so menu appears on left */
        align-items: center !important;
        gap: 8px !important;
        opacity: 0 !important;
        transform: translateX(100px) !important;
        transition: opacity 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) !important;
        width: auto !important;
        height: auto !important;
        min-width: auto !important;
        min-height: auto !important;
        max-width: none !important;
        max-height: none !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      .home-options-container.home-options-container-visible {
        opacity: 1 !important;
        transform: translateX(0) !important;
      }
      
      /* Semi-circular home options button - attached to right edge */
      .home-options-btn {
        width: 52px !important; /* Wider button for rectangular shape */
        height: 32px !important; /* Keep height same */
        min-width: 52px !important;
        min-height: 32px !important;
        max-width: 52px !important;
        max-height: 32px !important;
        background: #9527F5 !important; /* Purple background */
        border: 1px solid white !important; /* White border */
        border-right: none !important; /* No right border for flat edge (touching screen edge) */
        border-radius: 18px 0 0 18px !important; /* Semi-circular: rounded on left (semi-circle), flat on right */
        display: flex !important;
        align-items: center !important;
        justify-content: flex-start !important; /* Align to left */
        cursor: pointer !important;
        opacity: 0.95 !important;
        transition: opacity 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease !important;
        padding-left: 7px !important; /* Move icon more to the left */
        padding-right: 0 !important;
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4) !important;
        pointer-events: auto !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
      }
      
      .home-options-btn:hover,
      .home-options-container-active .home-options-btn {
        transform: translateX(-8px); /* Slide out from right edge on hover or when menu is visible */
        opacity: 1;
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.6);
      }
      
      .home-options-btn:active {
        transform: translateX(-4px); /* Slight slide out on active */
      }
      
      .home-options-btn svg,
      .home-options-btn .home-options-gear-icon {
        pointer-events: none !important;
        display: block !important;
        width: 16px !important; /* Smaller icon for smaller button */
        height: 16px !important; /* Smaller icon for smaller button */
        min-width: 16px !important;
        min-height: 16px !important;
        max-width: 16px !important;
        max-height: 16px !important;
        transition: transform 0.2s ease !important;
        margin-left: -2px !important; /* Move logo a bit more to the left */
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .home-options-btn svg *,
      .home-options-btn .home-options-gear-icon *,
      .home-options-btn svg image {
        display: block !important;
        visibility: visible !important;
      }
      
      .home-options-container-active .home-options-btn svg,
      .home-options-container-active .home-options-btn .home-options-gear-icon {
        transform: rotate(90deg) scale(1.6);
      }
      
      /* Hover menu - slides in from left on hover */
      .home-options-menu {
        display: flex !important;
        flex-direction: column !important;
        gap: 8px !important;
        opacity: 0 !important;
        transform: translateX(20px) !important;
        pointer-events: none !important;
        transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) !important;
        width: auto !important;
        height: auto !important;
        min-width: auto !important;
        min-height: auto !important;
        max-width: none !important;
        max-height: none !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      .home-options-container:hover .home-options-menu,
      .home-options-container-visible:hover .home-options-menu,
      .home-options-btn:hover ~ .home-options-menu,
      .home-options-menu:hover,
      .home-options-menu.home-options-menu-visible {
        opacity: 1 !important;
        transform: translateX(0) !important;
        pointer-events: auto !important;
      }
      
      .home-options-menu-item {
        background: #9527F5 !important;
        color: white !important;
        border: 2px solid white !important;
        border-radius: 50% !important;
        width: 36px !important;
        height: 36px !important;
        min-width: 36px !important;
        min-height: 36px !important;
        max-width: 36px !important;
        max-height: 36px !important;
        padding: 0 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4) !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        opacity: 0 !important;
        transform: translateX(-10px) scale(1) !important;
        transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s ease !important;
        position: relative !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
      }
      
      .home-options-menu-item svg {
        width: 16px !important;
        height: 16px !important;
        min-width: 16px !important;
        min-height: 16px !important;
        max-width: 16px !important;
        max-height: 16px !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .home-options-menu-item svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      .home-options-menu-item:nth-child(1) {
        transition-delay: 0.05s;
      }
      
      .home-options-menu-item:nth-child(2) {
        transition-delay: 0.1s;
      }
      
      .home-options-menu-item:nth-child(3) {
        transition-delay: 0.15s;
      }
      
      .home-options-menu-item:nth-child(4) {
        transition-delay: 0.2s;
      }
      
      .home-options-btn:hover ~ .home-options-menu .home-options-menu-item,
      .home-options-menu:hover .home-options-menu-item,
      .home-options-menu.home-options-menu-visible .home-options-menu-item {
        opacity: 1 !important;
        transform: translateX(0) scale(1) !important;
        width: 36px !important;
        height: 36px !important;
      }
      
      .home-options-btn:hover ~ .home-options-menu .home-options-menu-item:hover,
      .home-options-menu:hover .home-options-menu-item:hover,
      .home-options-menu.home-options-menu-visible .home-options-menu-item:hover,
      .home-options-menu-item:hover {
        background: #9527F5;
        transform: translateX(0) scale(1.1) !important;
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.6);
      }
      
      /* Tooltip styles */
      .home-options-menu-item-tooltip {
        position: absolute;
        right: calc(100% + 12px);
        top: 50%;
        transform: translateY(-50%);
        background: white;
        color: #b29cfb;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        font-style: normal !important;
        font-variant: normal !important;
        text-transform: none !important;
        letter-spacing: normal !important;
        line-height: 1.4 !important;
        text-decoration: none !important;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
        z-index: 10000001;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }
      
      .home-options-menu-item:hover .home-options-menu-item-tooltip {
        opacity: 1;
      }
      
      .home-options-menu-item:active {
        transform: translateX(0) scale(1.1) !important;
        width: 36px !important;
        height: 36px !important;
      }
      
      /* Tooltip for ask-about-page button - Similar to import-content button tooltip */
      .vocab-ask-about-page-tooltip {
        position: fixed !important;
        background: white !important;
        color: #b29cfb !important;
        padding: 10px 20px !important;
        border-radius: 20px !important;
        font-size: 13px !important;
        font-weight: 500 !important;
        white-space: nowrap !important;
        text-align: center !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
        box-shadow: 0 0 20px rgba(178, 156, 251, 0.3), 0 4px 12px rgba(178, 156, 251, 0.2) !important;
        z-index: 9999999 !important;
        pointer-events: none !important;
        opacity: 0 !important;
        transform: translateY(5px) scale(0.95) !important;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                   transform 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        visibility: visible !important;
        width: auto !important;
        height: auto !important;
        min-height: 40px !important;
      }
      
      .vocab-ask-about-page-tooltip.visible {
        opacity: 1 !important;
        transform: translateY(0) scale(1) !important;
      }
      
      /* Tooltip arrow - pointing upward to the button (since tooltip is below, on the left side) */
      .vocab-ask-about-page-tooltip::after {
        content: '';
        position: absolute;
        bottom: 100%;
        right: 20px;
        border: 6px solid transparent;
        border-bottom-color: white;
        filter: drop-shadow(0 2px 3px rgba(167, 139, 250, 0.2));
      }
    `;
    
    document.head.appendChild(style);
  }
};

// ===================================
// Drag Handle Module - Manages drag-and-drop functionality
// ===================================
const DragHandle = {
  isDragging: false,
  dragStartX: 0,
  dragStartY: 0,
  elementStartX: 0,
  elementStartY: 0,
  targetElement: null,
  handleElement: null,
  
  /**
   * Initialize drag handle
   * @param {HTMLElement} handle - The drag handle element
   * @param {HTMLElement} target - The element to be dragged
   */
  init(handle, target) {
    this.handleElement = handle;
    this.targetElement = target;
    
    // Attach event listeners
    this.handleElement.addEventListener('mousedown', this.onDragStart.bind(this));
    document.addEventListener('mousemove', this.onDragMove.bind(this));
    document.addEventListener('mouseup', this.onDragEnd.bind(this));
    
    // Touch events for mobile
    this.handleElement.addEventListener('touchstart', this.onTouchStart.bind(this));
    document.addEventListener('touchmove', this.onTouchMove.bind(this));
    document.addEventListener('touchend', this.onDragEnd.bind(this));
  },
  
  /**
   * Handle mouse drag start
   * @param {MouseEvent} e - Mouse event
   */
  onDragStart(e) {
    e.preventDefault();
    e.stopPropagation();
    
    this.isDragging = true;
    this.dragStartX = e.clientX;
    this.dragStartY = e.clientY;
    
    const rect = this.targetElement.getBoundingClientRect();
    this.elementStartX = rect.left;
    this.elementStartY = rect.top;
    
    // Add dragging visual feedback
    this.targetElement.style.transition = 'none';
    this.handleElement.style.cursor = 'grabbing';
    document.body.style.userSelect = 'none';
    
    // Disable pointer events on buttons to prevent hover tooltips during drag
    this.targetElement.style.pointerEvents = 'none';
    this.handleElement.style.pointerEvents = 'auto'; // Keep handle interactive
    
    // Remove any existing tooltips
    this.removeAllTooltips();
  },
  
  /**
   * Handle touch drag start
   * @param {TouchEvent} e - Touch event
   */
  onTouchStart(e) {
    const touch = e.touches[0];
    this.onDragStart({
      preventDefault: () => e.preventDefault(),
      stopPropagation: () => e.stopPropagation(),
      clientX: touch.clientX,
      clientY: touch.clientY
    });
  },
  
  /**
   * Handle drag move
   * @param {MouseEvent} e - Mouse event
   */
  onDragMove(e) {
    if (!this.isDragging) return;
    
    e.preventDefault();
    
    const deltaX = e.clientX - this.dragStartX;
    const deltaY = e.clientY - this.dragStartY;
    
    const newLeft = this.elementStartX + deltaX;
    const newTop = this.elementStartY + deltaY;
    
    // Apply constraints to keep panel within viewport
    const constraints = this.calculateConstraints();
    const constrainedLeft = Math.max(constraints.minX, Math.min(constraints.maxX, newLeft));
    const constrainedTop = Math.max(constraints.minY, Math.min(constraints.maxY, newTop));
    
    // Update position
    this.targetElement.style.left = `${constrainedLeft}px`;
    this.targetElement.style.top = `${constrainedTop}px`;
    this.targetElement.style.right = 'auto';
    this.targetElement.style.transform = 'none';
  },
  
  /**
   * Handle touch drag move
   * @param {TouchEvent} e - Touch event
   */
  onTouchMove(e) {
    if (!this.isDragging) return;
    const touch = e.touches[0];
    this.onDragMove({
      preventDefault: () => e.preventDefault(),
      clientX: touch.clientX,
      clientY: touch.clientY
    });
  },
  
  /**
   * Handle drag end
   */
  onDragEnd() {
    if (!this.isDragging) return;
    
    this.isDragging = false;
    
    // Remove visual feedback
    this.handleElement.style.cursor = 'grab';
    document.body.style.userSelect = '';
    
    // Re-enable pointer events on buttons
    this.targetElement.style.pointerEvents = '';
    
    // Save position
    const rect = this.targetElement.getBoundingClientRect();
    PositionManager.savePosition({
      left: rect.left,
      top: rect.top
    });
  },
  
  /**
   * Calculate viewport constraints to keep panel fully visible
   * @returns {Object} Constraint boundaries
   */
  calculateConstraints() {
    const rect = this.targetElement.getBoundingClientRect();
    const minVisibleArea = rect.width * 0.8; // Keep 80% of the panel visible
    
    return {
      minX: -rect.width + minVisibleArea,
      maxX: window.innerWidth - minVisibleArea,
      minY: 0,
      maxY: window.innerHeight - rect.height
    };
  },
  
  /**
   * Apply saved position to target element
   * @param {Object} position - Position object {left, top}
   */
  applyPosition(position) {
    if (!position || !this.targetElement) return;
    
    this.targetElement.style.left = `${position.left}px`;
    this.targetElement.style.top = `${position.top}px`;
    this.targetElement.style.right = 'auto';
    this.targetElement.style.transform = 'none';
  },
  
  /**
   * Reset to default position
   */
  resetPosition() {
    this.targetElement.style.left = '0';
    this.targetElement.style.top = '';
    this.targetElement.style.right = '';
    this.targetElement.style.transform = '';
    PositionManager.clearPosition();
  },
  
  /**
   * Remove all visible tooltips
   */
  removeAllTooltips() {
    const tooltips = document.querySelectorAll('.vocab-btn-tooltip');
    tooltips.forEach(tooltip => tooltip.remove());
  }
};

// ===================================
// Chat Dialog Module - Manages the chat popup interface
// ===================================
const ChatDialog = {
  dialogContainer: null,
  isOpen: false,
  currentText: null,
  currentTextKey: null,
  chatHistory: [],
  chatHistories: new Map(), // Store chat history for each textKey
  mode: 'ask', // 'ask' or 'simplified'
  simplifiedData: null, // For simplified mode
  isSimplifying: false, // Track if currently simplifying more
  chatContext: 'general', // 'general' for content chat, 'selected' for selected text chat
  pageSummary: null, // Store the fetched page summary
  pagePossibleQuestions: [], // Store possible questions from summary API
  simplifiedPossibleQuestions: [], // Store possible questions from simplify API
  
  /**
   * Initialize chat dialog
   */
  init() {
    console.log('[ChatDialog] Initializing...');
    this.injectStyles();
  },
  
  /**
   * Open chat dialog with selected text
   * @param {string} text - The selected text
   * @param {string} textKey - The text key for identification
   * @param {string} mode - The dialog mode: 'ask' or 'simplified'
   * @param {Object} simplifiedData - Simplified text data (for simplified mode)
   * @param {string} chatContext - The chat context: 'general' or 'selected'
   */
  open(text, textKey, mode = 'ask', simplifiedData = null, chatContext = 'general') {
    console.log('[ChatDialog] ===== OPEN FUNCTION CALLED =====');
    console.log('[ChatDialog] open() called with:', {
      textLength: text ? text.length : 0,
      textKey: textKey,
      mode: mode,
      chatContext: chatContext,
      isOpen: this.isOpen,
      currentTextKey: this.currentTextKey
    });
    console.log('[ChatDialog] ChatHistories Map contents:', Array.from(this.chatHistories.keys()));
    
    // Close BookmarkWordsDialog if it's open
    if (typeof BookmarkWordsDialog !== 'undefined' && BookmarkWordsDialog.isOpen) {
      console.log('[ChatDialog] BookmarkWordsDialog is open, closing it before opening chat/summary dialog');
      BookmarkWordsDialog.close();
    }
    
    // Set the chat context
    this.chatContext = chatContext;
    
    // For page-general context, check global variables first
    if (textKey && textKey.startsWith('page-general')) {
      // Load from global variables if they exist
      if (window.pageSummary !== null && window.pageSummaryPossibleQuestions !== null) {
        console.log('[ChatDialog] Loading page summary from global variables');
        this.pageSummary = window.pageSummary;
        this.pagePossibleQuestions = window.pageSummaryPossibleQuestions;
      } else {
        // If global variables are null, clear instance variables
        console.log('[ChatDialog] Global page summary variables are null, clearing instance variables');
        this.pageSummary = null;
        this.pagePossibleQuestions = [];
      }
    } else {
      // Clear summary if not a page-general context
      this.pageSummary = null;
      this.pagePossibleQuestions = [];
    }
    
    // Generate proper contextual textKey based on chat context
    let contextualTextKey;
    if (chatContext === 'general') {
      // For general chat: <content type>-<tab id>-generic
      // Extract content type and tab ID from textKey
      const parts = textKey.split('-');
      if (parts.length >= 3) {
        const contentType = parts[0]; // e.g., "pdf"
        const tabId = parts[1]; // e.g., "tabId2"
        contextualTextKey = `${contentType}-${tabId}-generic`;
      } else {
        // Fallback for custom content
        contextualTextKey = `${textKey}-generic`;
      }
    } else if (chatContext === 'selected') {
      // For selected text chat: <content type>-<tab id>-<start index>-<selected text length>
      // Extract content type and tab ID from textKey
      const parts = textKey.split('-');
      if (parts.length >= 3) {
        const contentType = parts[0]; // e.g., "pdf"
        const tabId = parts[1]; // e.g., "tabId2"
        // For selected text, we need start index and length from simplifiedData or textKey
        if (simplifiedData && simplifiedData.textStartIndex !== undefined && simplifiedData.textLength !== undefined) {
          contextualTextKey = `${contentType}-${tabId}-${simplifiedData.textStartIndex}-${simplifiedData.textLength}`;
        } else if (parts.length >= 5) {
          // textKey already contains start index and length
          contextualTextKey = textKey;
        } else {
          // Fallback - use simplified format
          contextualTextKey = `${contentType}-${tabId}-selected`;
        }
      } else {
        // Fallback for custom content
        contextualTextKey = `${textKey}-selected`;
      }
    } else {
      // Fallback to old format
      contextualTextKey = `${textKey}-${chatContext}`;
    }
    
    console.log('[ChatDialog] Generated contextualTextKey:', contextualTextKey, 'for chatContext:', chatContext);
    
    // If dialog is already open for the same text and context
    if (this.isOpen && this.currentTextKey === contextualTextKey) {
      console.log('[ChatDialog] Dialog already open for same textKey and context:', contextualTextKey);
      // If opening in simplified mode and already open for same text
      if (mode === 'simplified') {
        // Dialog is already open - this means user clicked book icon again, so close it
        console.log('[ChatDialog] Already open for this text, closing it (toggle off)');
        this.close();
        return;
      }
      // If opening in 'ask' mode, just switch to ask tab
      else {
        console.log('[ChatDialog] Switching to ask tab');
        this.switchTab('ask');
      }
      return; // Don't re-create the dialog
    }
    
    // If dialog is open for different text, close it first
    if (this.isOpen) {
      console.log('[ChatDialog] Dialog open for different text, closing first');
      // Force immediate cleanup if minimizing or expanding (to prevent invisible dialog)
      const wasMinimizing = this.dialogContainer && this.dialogContainer.classList.contains('minimizing');
      const wasExpanding = this.dialogContainer && this.dialogContainer.classList.contains('expanding');
      
      if (wasMinimizing || wasExpanding) {
        // Cancel any ongoing animation and clean up immediately
        if (this.dialogContainer) {
          this.dialogContainer.classList.remove('minimizing', 'expanding');
          this.dialogContainer.style.removeProperty('transition');
          this.dialogContainer.style.removeProperty('animation');
          
          // Clean up CSS variables
          this.dialogContainer.style.removeProperty('--minimize-target-x');
          this.dialogContainer.style.removeProperty('--minimize-target-y');
          this.dialogContainer.style.removeProperty('--minimize-start-transform');
          this.dialogContainer.style.removeProperty('--minimize-end-transform');
          this.dialogContainer.style.removeProperty('--expand-start-transform');
          this.dialogContainer.style.removeProperty('--expand-end-transform');
          
          // Force a reflow to ensure cleanup is applied
          void this.dialogContainer.offsetHeight;
        }
      }
      
      this.close();
      
      // Wait for close animation to complete and ensure cleanup
      setTimeout(() => {
        // Double-check dialog is fully removed and cleaned up
        if (this.dialogContainer && this.dialogContainer.parentNode) {
          console.log('[ChatDialog] Dialog still exists, forcing removal');
          // Clean up any remaining animation classes and CSS variables
          this.dialogContainer.classList.remove('minimizing', 'expanding', 'visible');
          this.dialogContainer.style.removeProperty('animation');
          this.dialogContainer.style.removeProperty('transition');
          this.dialogContainer.style.removeProperty('--minimize-target-x');
          this.dialogContainer.style.removeProperty('--minimize-target-y');
          this.dialogContainer.style.removeProperty('--minimize-start-transform');
          this.dialogContainer.style.removeProperty('--minimize-end-transform');
          this.dialogContainer.style.removeProperty('--expand-start-transform');
          this.dialogContainer.style.removeProperty('--expand-end-transform');
          
          this.dialogContainer.remove();
          this.dialogContainer = null;
          this.isOpen = false;
        }
        console.log('[ChatDialog] Opening dialog after close delay');
        this.openDialog(text, contextualTextKey, mode, simplifiedData);
      }, 350); // Wait for animation to complete (300ms) + small buffer
    } else {
      // Dialog is not open, open it
      console.log('[ChatDialog] Dialog not open, opening directly');
      this.openDialog(text, contextualTextKey, mode, simplifiedData);
    }
  },
  
  /**
   * Internal method to open dialog
   * @param {string} text - The selected text
   * @param {string} contextualTextKey - The contextual text key for identification
   * @param {string} mode - The dialog mode: 'ask' or 'simplified'
   * @param {Object} simplifiedData - Simplified text data (for simplified mode)
   */
  openDialog(text, contextualTextKey, mode = 'ask', simplifiedData = null) {
    console.log('[ChatDialog] ===== OPEN DIALOG FUNCTION CALLED =====');
    console.log('[ChatDialog] openDialog() called with:', {
      textLength: text ? text.length : 0,
      contextualTextKey: contextualTextKey,
      mode: mode,
      hasSimplifiedData: !!simplifiedData
    });
    
    this.currentText = text;
    this.currentTextKey = contextualTextKey;
    
    // Load existing chat history for this text, or create new empty array
    console.log('[ChatDialog] ===== LOADING CHAT HISTORY =====');
    console.log('[ChatDialog] Looking for contextualTextKey:', contextualTextKey);
    console.log('[ChatDialog] Available keys in chatHistories:', Array.from(this.chatHistories.keys()));
    console.log('[ChatDialog] ChatHistories Map size:', this.chatHistories.size);
    
    this.chatHistory = this.chatHistories.get(contextualTextKey) || [];
    console.log('[ChatDialog] Loaded chat history:', this.chatHistory.length, 'messages');
    console.log('[ChatDialog] Chat history for contextualTextKey', contextualTextKey, ':', this.chatHistory);
    
    this.mode = mode;
    
    // For simplified mode, always load the latest data from TextSelector.simplifiedTexts
    // This ensures we get all explanations including ones generated via "Simplify more"
    if (mode === 'simplified' && contextualTextKey) {
      // Get original textKey (remove -selected suffix if present)
      const originalTextKey = contextualTextKey.replace(/-selected$/, '').replace(/-generic$/, '');
      const latestSimplifiedData = TextSelector.simplifiedTexts.get(originalTextKey);
      
      if (latestSimplifiedData) {
        console.log('[ChatDialog] Loaded latest simplified data from TextSelector:', latestSimplifiedData);
        console.log('[ChatDialog] Previous simplified texts count:', latestSimplifiedData.previousSimplifiedTexts?.length || 0);
        console.log('[ChatDialog] Current simplified text exists:', !!latestSimplifiedData.simplifiedText);
        this.simplifiedData = latestSimplifiedData;
      } else if (simplifiedData) {
        // Fallback to passed simplifiedData if not found in TextSelector
        console.log('[ChatDialog] Using passed simplifiedData (not found in TextSelector)');
        this.simplifiedData = simplifiedData;
      } else {
        console.warn('[ChatDialog] No simplified data available for simplified mode');
        this.simplifiedData = null;
      }
    } else {
      this.simplifiedData = simplifiedData;
    }
    
    console.log('[ChatDialog] Creating dialog...');
    this.createDialog();
    console.log('[ChatDialog] Showing dialog...');
    this.show();
    
    // Hide Focus buttons for custom content (pdf, text, topics, image)
    this.hideFocusButtonsForCustomContent(contextualTextKey);
    
    console.log('[ChatDialog] Opened in', mode, 'mode for text:', text.substring(0, 50) + '...');
    console.log('[ChatDialog] Loaded', this.chatHistory.length, 'chat messages');
  },
  
  /**
   * Hide Focus buttons for custom content types (pdf, text, topics, image)
   * @param {string} textKey - The text key to check if it's custom content
   */
  hideFocusButtonsForCustomContent(textKey) {
    // Hide focus buttons for general chat (chat icon), show for selected text chat (book icon)
    // Also hide for page-general (ask-about-page button) - check for both 'page-general' and 'page-general-generic'
    const isPageGeneral = textKey && (textKey === 'page-general' || textKey.startsWith('page-general'));
    
    if (isPageGeneral) {
      console.log('[ChatDialog] Hiding Focus buttons for page-general:', textKey, 'chatContext:', this.chatContext);
      
      // Hide the top-right Focus button
      const topRightFocusBtn = this.dialogContainer.querySelector('.vocab-chat-focus-btn-top-right');
      if (topRightFocusBtn) {
        topRightFocusBtn.style.display = 'none';
        topRightFocusBtn.style.visibility = 'hidden';
        console.log('[ChatDialog] Focus button hidden via hideFocusButtonsForCustomContent');
      }
      
      // Hide Focus button containers in tab contents
      const focusBtnContainers = this.dialogContainer.querySelectorAll('.vocab-chat-focus-btn-container');
      focusBtnContainers.forEach(container => {
        container.style.display = 'none';
        container.style.visibility = 'hidden';
      });
      
      console.log('[ChatDialog] Focus buttons hidden for page-general');
    } else if (this.chatContext === 'general') {
      // Hide for other general chats too
      console.log('[ChatDialog] Hiding Focus buttons for general chat:', textKey);
      
      // Hide the top-right Focus button
      const topRightFocusBtn = this.dialogContainer.querySelector('.vocab-chat-focus-btn-top-right');
      if (topRightFocusBtn) {
        topRightFocusBtn.style.display = 'none';
        topRightFocusBtn.style.visibility = 'hidden';
      }
      
      // Hide Focus button containers in tab contents
      const focusBtnContainers = this.dialogContainer.querySelectorAll('.vocab-chat-focus-btn-container');
      focusBtnContainers.forEach(container => {
        container.style.display = 'none';
        container.style.visibility = 'hidden';
      });
      
      console.log('[ChatDialog] Focus buttons hidden for general chat');
    } else {
      console.log('[ChatDialog] Showing Focus buttons for selected text chat:', textKey);
      
      // Show the top-right Focus button
      const topRightFocusBtn = this.dialogContainer.querySelector('.vocab-chat-focus-btn-top-right');
      if (topRightFocusBtn) {
        topRightFocusBtn.style.display = 'block';
        topRightFocusBtn.style.visibility = 'visible';
      }
      
      // Show Focus button containers in tab contents
      const focusBtnContainers = this.dialogContainer.querySelectorAll('.vocab-chat-focus-btn-container');
      focusBtnContainers.forEach(container => {
        container.style.display = 'block';
        container.style.visibility = 'visible';
      });
      
      console.log('[ChatDialog] Focus buttons shown for selected text chat');
    }
  },
  
  /**
   * Close chat dialog
   */
  close() {
    console.log('[ChatDialog] ===== CLOSE FUNCTION CALLED =====');
    
    // Prevent closing if dialog is currently opening (expanding)
    if (this.dialogContainer && this.dialogContainer.classList.contains('expanding')) {
      console.log('[ChatDialog] Dialog is currently opening (expanding), cannot close yet');
      return;
    }
    
    // If already minimizing, don't close again (prevent double-close)
    if (this.dialogContainer && this.dialogContainer.classList.contains('minimizing')) {
      console.log('[ChatDialog] Dialog is already minimizing, ignoring close request');
      return;
    }
    
    console.log('[ChatDialog] Current state - isOpen:', this.isOpen, 'currentTextKey:', this.currentTextKey);
    console.log('[ChatDialog] chatContext:', this.chatContext);
    console.log('[ChatDialog] dialogContainer exists:', !!this.dialogContainer);
    
    if (!this.isOpen) {
      console.log('[ChatDialog] Dialog not open, nothing to close');
      return;
    }
    
    // Save chat history before closing
    if (this.currentTextKey && this.chatHistory.length > 0) {
      this.chatHistories.set(this.currentTextKey, [...this.chatHistory]);
      console.log('[ChatDialog] Saved', this.chatHistory.length, 'chat messages for', this.currentTextKey);
      
      // Also save to analysis data for persistence
      this.saveChatHistoryToAnalysisData();
    }
    
    // Save current dimensions before closing
    this.saveDimensions();
    
    // Check if we should minimize to book icon (only for selected text chat with textKey)
    // OR minimize to ask-about-page button (for page-general context)
    console.log('[ChatDialog] ===== CHECKING MINIMIZATION CONDITIONS =====');
    console.log('[ChatDialog] Condition 1 - currentTextKey exists:', !!this.currentTextKey, 'value:', this.currentTextKey);
    console.log('[ChatDialog] Condition 2 - chatContext === "selected":', this.chatContext === 'selected', 'value:', this.chatContext);
    console.log('[ChatDialog] Condition 3 - currentTextKey === "page-general":', this.currentTextKey === 'page-general');
    console.log('[ChatDialog] Condition 4 - dialogContainer exists:', !!this.dialogContainer);
    
    // Check for home-options-btn if textKey is 'page-general' (check for both original and transformed key)
    let homeOptionsButton = null;
    if (this.currentTextKey && (this.currentTextKey === 'page-general' || this.currentTextKey.startsWith('page-general')) && this.dialogContainer) {
      // Check for home-options-btn (for Summarise button)
      homeOptionsButton = document.getElementById('home-options-btn');
      if (homeOptionsButton) {
        console.log('[ChatDialog] ✓✓✓ FOUND HOME-OPTIONS BUTTON! Will minimize to it...');
      }
    }
    
    if (this.currentTextKey && this.chatContext === 'selected' && this.dialogContainer) {
      console.log('[ChatDialog] ✓ All conditions met! Proceeding with minimization animation...');
      // IMMEDIATELY disable transition to prevent slide-out animation
      this.dialogContainer.style.setProperty('transition', 'none', 'important');
      
      // Extract original textKey from contextualTextKey
      // contextualTextKey format can be:
      // 1. Full text with "-selected" appended: "long text here-selected"
      // 2. <contentType>-<tabId>-<startIndex>-<length>
      // 3. <contentType>-<tabId>-selected
      // The book icon uses the original textKey without "-selected"
      
      let originalTextKey = this.currentTextKey;
      const textKeysToTry = [this.currentTextKey]; // Always try the current key first
      
      // If contextualTextKey ends with "-selected", remove it
      if (this.currentTextKey.endsWith('-selected')) {
        originalTextKey = this.currentTextKey.slice(0, -'-selected'.length);
        textKeysToTry.push(originalTextKey);
        console.log('[ChatDialog] Removed "-selected" suffix, originalTextKey:', originalTextKey);
      }
      
      // Also try extracting from format: contentType-tabId-selected
      const parts = this.currentTextKey.split('-');
      if (parts.length >= 3 && parts[parts.length - 1] === 'selected') {
        const baseKey = parts.slice(0, -1).join('-');
        if (!textKeysToTry.includes(baseKey)) {
          textKeysToTry.push(baseKey);
        }
      }
      
      console.log('[ChatDialog] Looking for book icon with textKeys to try:', textKeysToTry);
      console.log('[ChatDialog] Original textKey (without -selected):', originalTextKey);
      
      // Find the book icon for this textKey - use multiple strategies
      const allIconsWrappers = document.querySelectorAll('.vocab-text-icons-wrapper');
      console.log('[ChatDialog] All icons wrappers found:', allIconsWrappers.length);
      
      // Log all available textKeys for debugging
      const availableTextKeys = [];
      allIconsWrappers.forEach((wrapper, index) => {
        const wrapperTextKey = wrapper.getAttribute('data-text-key');
        availableTextKeys.push(wrapperTextKey);
        console.log(`[ChatDialog] Icons wrapper ${index + 1} has textKey:`, wrapperTextKey);
      });
      console.log('[ChatDialog] Available textKeys in DOM:', availableTextKeys);
      
      let iconsWrapper = null;
      let bookIcon = null;
      
      // Strategy 1: Try exact match with textKeysToTry
      for (const wrapper of allIconsWrappers) {
        const wrapperTextKey = wrapper.getAttribute('data-text-key');
        if (textKeysToTry.includes(wrapperTextKey)) {
          iconsWrapper = wrapper;
          bookIcon = iconsWrapper.querySelector('.vocab-text-book-btn');
          if (bookIcon) {
            console.log('[ChatDialog] ✓✓✓ MATCH FOUND! Icons wrapper with textKey:', wrapperTextKey);
            break;
          }
        }
      }
      
      // Strategy 2: Try matching by simplifiedData if available
      if (!bookIcon && this.simplifiedData) {
        console.log('[ChatDialog] Trying to find book icon by matching simplifiedData...');
        for (const wrapper of allIconsWrappers) {
          const wrapperTextKey = wrapper.getAttribute('data-text-key');
          const simplifiedData = TextSelector.simplifiedTexts.get(wrapperTextKey);
          if (simplifiedData && 
              simplifiedData.textStartIndex === this.simplifiedData.textStartIndex &&
              simplifiedData.textLength === this.simplifiedData.textLength) {
            iconsWrapper = wrapper;
            bookIcon = iconsWrapper.querySelector('.vocab-text-book-btn');
            if (bookIcon) {
              console.log('[ChatDialog] ✓✓✓ FOUND BOOK ICON by matching simplifiedData with textKey:', wrapperTextKey);
              break;
            }
          }
        }
      }
      
      // Strategy 3: Try partial matching (check if currentTextKey contains or is contained in wrapperTextKey)
      if (!bookIcon) {
        console.log('[ChatDialog] Trying partial textKey matching...');
        for (const wrapper of allIconsWrappers) {
          const wrapperTextKey = wrapper.getAttribute('data-text-key');
          // Check if keys share common parts
          const currentParts = this.currentTextKey.split('-');
          const wrapperParts = wrapperTextKey.split('-');
          
          // Match if they share at least 3 common parts (contentType, tabId, and one more)
          if (currentParts.length >= 3 && wrapperParts.length >= 3) {
            const commonParts = currentParts.filter(part => wrapperParts.includes(part));
            if (commonParts.length >= 3) {
              iconsWrapper = wrapper;
              bookIcon = iconsWrapper.querySelector('.vocab-text-book-btn');
              if (bookIcon) {
                console.log('[ChatDialog] ✓✓✓ FOUND BOOK ICON by partial matching with textKey:', wrapperTextKey);
                break;
              }
            }
          }
        }
      }
      
      console.log('[ChatDialog] ===== BOOK ICON SEARCH RESULTS =====');
      console.log('[ChatDialog] Total icons wrappers found:', allIconsWrappers.length);
      console.log('[ChatDialog] Icons wrapper found:', !!iconsWrapper);
      console.log('[ChatDialog] Book icon found:', !!bookIcon);
      
      if (bookIcon) {
        console.log('[ChatDialog] ✓✓✓ FOUND BOOK ICON! Starting minimization animation...');
        
        // Check if dialogContainer still exists before proceeding
        if (!this.dialogContainer) {
          console.error('[ChatDialog] ERROR: dialogContainer is null, cannot minimize');
          return;
        }
        
        // Force a reflow to ensure book icon is in its final position
        void bookIcon.offsetHeight;
        
        // Get dialog size (use getBoundingClientRect for accurate size)
        const dialogRect = this.dialogContainer.getBoundingClientRect();
        const dialogHeight = dialogRect.height;
        const dialogWidth = dialogRect.width;
        
        // Get book icon position (use getBoundingClientRect for accurate viewport coordinates)
        // Force a reflow before getting position to ensure accurate coordinates
        void bookIcon.offsetHeight;
        const bookIconRect = bookIcon.getBoundingClientRect();
        const bookIconCenterX = bookIconRect.left + bookIconRect.width / 2;
        const bookIconCenterY = bookIconRect.top + bookIconRect.height / 2;
        
        console.log('[ChatDialog] Book icon center:', { x: bookIconCenterX, y: bookIconCenterY });
        console.log('[ChatDialog] Book icon rect:', { left: bookIconRect.left, top: bookIconRect.top, width: bookIconRect.width, height: bookIconRect.height });
        console.log('[ChatDialog] Dialog size:', { width: dialogWidth, height: dialogHeight });
        
        // Calculate the translation needed to move dialog center to book icon center
        // IMPORTANT: Always calculate from the dialog's DEFAULT position, not its current position
        // This ensures consistent minimization regardless of where the dialog was moved to
        // The dialog's default position is:
        // - position: fixed
        // - right: 0
        // - top: 50%
        // - transform: translateY(-50%) translateX(0) when visible
        // This means the dialog center is at:
        // X: viewportWidth - dialogWidth/2 (from right edge)
        // Y: viewportHeight / 2 (from top: 50% with translateY(-50%))
        
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Calculate DEFAULT dialog center position (not current position)
        // Default X: from right edge (right: 0), center is at viewportWidth - dialogWidth/2
        const defaultDialogCenterX = viewportWidth - dialogWidth / 2;
        // Default Y: from top: 50% with translateY(-50%), center is at viewportHeight / 2
        const defaultDialogCenterY = viewportHeight / 2;
        
        // Calculate target position: book icon center (viewport coordinates)
        // This is ALWAYS the same - the book icon's position is fixed
        const targetCenterX = bookIconCenterX;
        const targetCenterY = bookIconCenterY;
        
        // Calculate how much to move from DEFAULT center to target center
        // This ensures consistent calculation regardless of dialog's current position
        const deltaX = targetCenterX - defaultDialogCenterX;
        const deltaY = targetCenterY - defaultDialogCenterY;
        
        // Calculate final transform values
        // Start transform: translateY(-50%) translateX(0) (default position)
        // To move the center to the book icon:
        // - translateY: -50% (to center vertically) + deltaY in pixels
        // - translateX: 0 (from right edge) + deltaX in pixels
        
        // Convert -50% to pixels: -dialogHeight / 2
        const negativeHalfHeight = -dialogHeight / 2; // -50% of height in pixels
        const finalTranslateY = negativeHalfHeight + deltaY;
        
        // For X: dialog is positioned from right edge, so translateX(0) means no horizontal offset
        // To move center to book icon center, we need to move by deltaX
        const finalTranslateX = deltaX;
        
        console.log('[ChatDialog] Transform calculation (using DEFAULT position for consistency):');
        console.log('[ChatDialog]   viewportHeight:', viewportHeight, 'viewportWidth:', viewportWidth);
        console.log('[ChatDialog]   dialogHeight:', dialogHeight, 'dialogWidth:', dialogWidth);
        console.log('[ChatDialog]   defaultDialogCenterX:', defaultDialogCenterX, 'defaultDialogCenterY:', defaultDialogCenterY);
        console.log('[ChatDialog]   targetCenterX (book icon):', targetCenterX, 'targetCenterY (book icon):', targetCenterY);
        console.log('[ChatDialog]   deltaX:', deltaX, 'deltaY:', deltaY);
        console.log('[ChatDialog]   finalTranslateX:', finalTranslateX, 'finalTranslateY:', finalTranslateY);
        
        // Get current transform to use as start transform
        const currentComputedStyle = window.getComputedStyle(this.dialogContainer);
        const currentTransform = currentComputedStyle.transform;
        const currentTop = currentComputedStyle.top;
        const currentRight = currentComputedStyle.right;
        
        // Calculate current dialog center from actual position
        const currentDialogCenterX = dialogRect.left + dialogWidth / 2;
        const currentDialogCenterY = dialogRect.top + dialogHeight / 2;
        
        // Calculate delta from CURRENT position to book icon (not default position)
        // This ensures smooth animation from wherever the dialog currently is
        const deltaXFromCurrent = targetCenterX - currentDialogCenterX;
        const deltaYFromCurrent = targetCenterY - currentDialogCenterY;
        
        // Parse current transform to get translate values
        // If transform is "none" or doesn't match expected format, use default
        let startTranslateX = 0;
        let startTranslateY = -dialogHeight / 2; // Default: -50% of height
        
        if (currentTransform && currentTransform !== 'none') {
          // Try to extract translate values from matrix or translate string
          const matrixMatch = currentTransform.match(/matrix\([^)]+\)/);
          if (matrixMatch) {
            // For matrix, we need to extract translateX and translateY
            // Matrix format: matrix(a, b, c, d, tx, ty)
            const values = currentTransform.match(/[-+]?[0-9]*\.?[0-9]+/g);
            if (values && values.length >= 6) {
              startTranslateX = parseFloat(values[4]) || 0;
              startTranslateY = parseFloat(values[5]) || -dialogHeight / 2;
            }
          } else {
            // Try to match translateX and translateY
            const translateXMatch = currentTransform.match(/translateX\(([^)]+)\)/);
            const translateYMatch = currentTransform.match(/translateY\(([^)]+)\)/);
            if (translateXMatch) {
              const val = translateXMatch[1].replace('px', '').trim();
              startTranslateX = parseFloat(val) || 0;
            }
            if (translateYMatch) {
              const val = translateYMatch[1].replace('px', '').replace('%', '').trim();
              if (translateYMatch[1].includes('%')) {
                startTranslateY = (parseFloat(val) / 100) * dialogHeight;
              } else {
                startTranslateY = parseFloat(val) || -dialogHeight / 2;
              }
            }
          }
        }
        
        // Calculate end transform from current position
        const endTranslateX = startTranslateX + deltaXFromCurrent;
        const endTranslateY = startTranslateY + deltaYFromCurrent;
        
        console.log('[ChatDialog] Animation calculation from CURRENT position:');
        console.log('[ChatDialog]   currentTransform:', currentTransform);
        console.log('[ChatDialog]   currentDialogCenterX:', currentDialogCenterX, 'currentDialogCenterY:', currentDialogCenterY);
        console.log('[ChatDialog]   startTranslateX:', startTranslateX, 'startTranslateY:', startTranslateY);
        console.log('[ChatDialog]   deltaXFromCurrent:', deltaXFromCurrent, 'deltaYFromCurrent:', deltaYFromCurrent);
        console.log('[ChatDialog]   endTranslateX:', endTranslateX, 'endTranslateY:', endTranslateY);
        
        // Clean up any previous animation state FIRST before setting new properties
        this.dialogContainer.classList.remove('minimizing', 'expanding');
        this.dialogContainer.style.removeProperty('--minimize-target-x');
        this.dialogContainer.style.removeProperty('--minimize-target-y');
        this.dialogContainer.style.removeProperty('--minimize-start-transform');
        this.dialogContainer.style.removeProperty('--minimize-end-transform');
        this.dialogContainer.style.removeProperty('--expand-start-transform');
        this.dialogContainer.style.removeProperty('--expand-end-transform');
        this.dialogContainer.style.removeProperty('animation');
        this.dialogContainer.style.removeProperty('transition');
        
        // Force a reflow to ensure cleanup is applied
        void this.dialogContainer.offsetHeight;
        
        // Set CSS custom properties for the animation
        // Use current transform as start, and calculate end from current position
        this.dialogContainer.style.setProperty('--minimize-target-x', `${targetCenterX}px`);
        this.dialogContainer.style.setProperty('--minimize-target-y', `${targetCenterY}px`);
        this.dialogContainer.style.setProperty('--minimize-start-transform', `translateY(${startTranslateY}px) translateX(${startTranslateX}px)`);
        this.dialogContainer.style.setProperty('--minimize-end-transform', `translateY(${endTranslateY}px) translateX(${endTranslateX}px)`);
        
        // Ensure dialog is visible before animation starts
        if (!this.dialogContainer.classList.contains('visible')) {
          this.dialogContainer.classList.add('visible');
        }
        
        // Force a reflow to ensure styles are applied
        void this.dialogContainer.offsetHeight;
        
        console.log('[ChatDialog] Set CSS properties:');
        console.log('[ChatDialog] --minimize-target-x:', targetCenterX);
        console.log('[ChatDialog] --minimize-target-y:', targetCenterY);
        console.log('[ChatDialog] --minimize-start-transform:', `translateY(${startTranslateY}px) translateX(${startTranslateX}px)`);
        console.log('[ChatDialog] --minimize-end-transform:', `translateY(${endTranslateY}px) translateX(${endTranslateX}px)`);
        console.log('[ChatDialog] Dialog height:', dialogHeight);
        
        // Force a reflow to ensure styles are applied
        void this.dialogContainer.offsetHeight;
        
        // Add minimizing class to trigger animation (DO NOT remove visible class)
        // Check if dialogContainer still exists before accessing classList
        if (!this.dialogContainer) {
          console.error('[ChatDialog] ERROR: dialogContainer is null before adding minimizing class');
          return;
        }
        
        // Now add the minimizing class to trigger animation
        // The CSS will handle the animation via the .minimizing class
        this.dialogContainer.classList.add('minimizing');
        
        // Force a reflow to ensure animation starts
        void this.dialogContainer.offsetHeight;
        
        // Verify animation is applied
        if (!this.dialogContainer) {
          console.error('[ChatDialog] ERROR: dialogContainer is null before getting computed style');
          return;
        }
        const computedStyle = window.getComputedStyle(this.dialogContainer);
        const animationName = computedStyle.animationName;
        const animationDuration = computedStyle.animationDuration;
        const animationState = computedStyle.animationPlayState;
        const transform = computedStyle.transform;
        
        console.log('[ChatDialog] ===== ANIMATION VERIFICATION =====');
        console.log('[ChatDialog] Minimization animation started');
        console.log('[ChatDialog] Dialog has minimizing class:', this.dialogContainer && this.dialogContainer.classList.contains('minimizing'));
        console.log('[ChatDialog] Animation name:', animationName);
        console.log('[ChatDialog] Animation duration:', animationDuration);
        console.log('[ChatDialog] Animation play state:', animationState);
        console.log('[ChatDialog] Current transform:', transform);
        console.log('[ChatDialog] CSS custom properties:');
        if (this.dialogContainer) {
        console.log('[ChatDialog]   --minimize-start-transform:', this.dialogContainer.style.getPropertyValue('--minimize-start-transform'));
        console.log('[ChatDialog]   --minimize-end-transform:', this.dialogContainer.style.getPropertyValue('--minimize-end-transform'));
        console.log('[ChatDialog]   --minimize-target-x:', this.dialogContainer.style.getPropertyValue('--minimize-target-x'));
        console.log('[ChatDialog]   --minimize-target-y:', this.dialogContainer.style.getPropertyValue('--minimize-target-y'));
        }
        
        // Wait for animation to complete, then hide dialog
        setTimeout(() => {
          console.log('[ChatDialog] Minimization animation completed, hiding dialog');
          
          // Check if dialogContainer still exists before accessing it
          if (!this.dialogContainer) {
            console.log('[ChatDialog] Dialog container already removed, skipping cleanup');
            return;
          }
          
          // Clean up animation class and CSS properties
          this.dialogContainer.classList.remove('minimizing');
          this.dialogContainer.style.removeProperty('--minimize-target-x');
          this.dialogContainer.style.removeProperty('--minimize-target-y');
          this.dialogContainer.style.removeProperty('--minimize-start-transform');
          this.dialogContainer.style.removeProperty('--minimize-end-transform');
          
          // Remove dialog container immediately (no need for hide() since animation is done)
          console.log('[ChatDialog] Removing dialog container...');
          if (this.dialogContainer) {
            this.dialogContainer.remove();
            this.dialogContainer = null;
            console.log('[ChatDialog] Dialog container removed');
          }
          // Reset state
          this.isOpen = false;
          this.currentText = null;
          this.currentTextKey = null;
          console.log('[ChatDialog] Dialog state reset');
        }, 300); // 0.3s animation duration (same as appearing animation)
        
        return; // Exit early, cleanup will continue in setTimeout
      } else {
        console.log('[ChatDialog] ✗✗✗ BOOK ICON NOT FOUND! Cannot minimize to book icon.');
        console.log('[ChatDialog] Falling back to regular close...');
      }
    } else if (homeOptionsButton) {
      console.log('[ChatDialog] ✓✓✓ FOUND HOME-OPTIONS BUTTON! Using simple slide-out animation (like bookmark modal)...');
      
      // Check if dialogContainer still exists before proceeding
      if (!this.dialogContainer) {
        console.error('[ChatDialog] ERROR: dialogContainer is null, cannot close');
        return;
      }
      
      // Use simple slide-out animation (same as bookmark modal)
      // Remove inline transform to allow CSS transition to work
      this.dialogContainer.style.removeProperty('transform');
      
      // Force reflow to ensure the style change is applied
      void this.dialogContainer.offsetHeight;
      
      // Remove visible class to trigger slide-out animation
      this.dialogContainer.classList.remove('visible');
      
      // Wait for animation to complete, then hide dialog
      setTimeout(() => {
        console.log('[ChatDialog] Slide-out animation completed, hiding dialog');
        
        // Check if dialogContainer still exists before accessing it
        if (!this.dialogContainer) {
          console.log('[ChatDialog] Dialog container already removed, skipping cleanup');
          return;
        }
        
        // Remove dialog container
        console.log('[ChatDialog] Removing dialog container...');
        if (this.dialogContainer) {
          this.dialogContainer.remove();
          this.dialogContainer = null;
          console.log('[ChatDialog] Dialog container removed');
        }
        // Reset state
        this.isOpen = false;
        this.currentText = null;
        this.currentTextKey = null;
        console.log('[ChatDialog] Dialog state reset');
      }, 300); // 0.3s animation duration (same as bookmark modal)
      
      return; // Exit early, cleanup will continue in setTimeout
    } else {
      console.log('[ChatDialog] ✗✗✗ MINIMIZATION CONDITIONS NOT MET!');
      console.log('[ChatDialog] Reasons:');
      if (!this.currentTextKey) console.log('[ChatDialog]   - currentTextKey is missing');
      const isPageGeneral = this.currentTextKey && (this.currentTextKey === 'page-general' || this.currentTextKey.startsWith('page-general'));
      if (this.chatContext !== 'selected' && !isPageGeneral) console.log('[ChatDialog]   - chatContext is not "selected" and textKey is not "page-general"');
      if (!this.dialogContainer) console.log('[ChatDialog]   - dialogContainer is missing');
    }
    
    // Fallback to original behavior if no book icon found or not selected text chat
    console.log('[ChatDialog] ===== USING FALLBACK CLOSE (NO MINIMIZATION) =====');
    console.log('[ChatDialog] No book icon or ask-about-page button found, using fallback close');
    
    // If dialog is visible, use slide-out animation
    if (this.dialogContainer && this.dialogContainer.classList.contains('visible')) {
      this.dialogContainer.classList.remove('visible');
      setTimeout(() => {
        this.hide();
      }, 300);
    } else {
      this.hide();
    }
    
    // Keep the chat icon on the text (don't remove it)
    // The text should remain in askedTexts container
    
    setTimeout(() => {
      console.log('[ChatDialog] Removing dialog container...');
      if (this.dialogContainer) {
        this.dialogContainer.remove();
        this.dialogContainer = null;
        console.log('[ChatDialog] Dialog container removed');
      }
      // Reset state
      this.isOpen = false;
      this.currentText = null;
      this.currentTextKey = null;
      console.log('[ChatDialog] Dialog state reset');
    }, 300); // Wait for slide-out animation
    
    console.log('[ChatDialog] Closed');
  },
  
  /**
   * Create dialog DOM structure
   */
  createDialog() {
    console.log('[ChatDialog] ===== CREATE DIALOG FUNCTION CALLED =====');
    console.log('[ChatDialog] Creating dialog container...');
    
    // Create main container
    this.dialogContainer = document.createElement('div');
    this.dialogContainer.id = 'vocab-chat-dialog';
    this.dialogContainer.className = 'vocab-chat-dialog';
    
    console.log('[ChatDialog] Dialog container created:', this.dialogContainer.id);
    
    // Create dialog content
    const dialogContent = document.createElement('div');
    dialogContent.className = 'vocab-chat-content';
    
    // Create left side button container (collapse and delete buttons stacked vertically)
    const leftButtonContainer = document.createElement('div');
    leftButtonContainer.className = 'vocab-chat-left-buttons';
    
    // Create collapse button (smaller size)
    const collapseBtn = document.createElement('button');
    collapseBtn.className = 'vocab-chat-collapse-btn-small';
    collapseBtn.setAttribute('aria-label', 'Close chat');
    collapseBtn.innerHTML = this.createCollapseIcon();
    collapseBtn.addEventListener('click', () => this.close());
    
    leftButtonContainer.appendChild(collapseBtn);
    
    // Create focus button for top right corner
    const focusButton = document.createElement('button');
    focusButton.className = 'vocab-chat-focus-btn-top-right';
    focusButton.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <polygon points="10,7 4,12 10,17" fill="white"/>
        <rect x="10" y="10.5" width="10" height="3" fill="white"/>
      </svg>
      <span>Focus</span>
    `;
    
    // Hide focus button immediately if it's for page-general (ask-about-page)
    // Check for both 'page-general' and 'page-general-generic' (the transformed key)
    if (this.currentTextKey && (this.currentTextKey === 'page-general' || this.currentTextKey.startsWith('page-general'))) {
      focusButton.style.display = 'none';
      focusButton.style.visibility = 'hidden';
      console.log('[ChatDialog] Hiding focus button for page-general, currentTextKey:', this.currentTextKey, 'chatContext:', this.chatContext);
    }
    
    // Add click handler for focus button
    focusButton.addEventListener('click', () => {
      console.log('[Focus Button] Clicked, currentTextKey:', this.currentTextKey);
      console.log('[Focus Button] chatContext:', this.chatContext);
      
      if (this.currentTextKey) {
        // For selected text chat, use original textKey to find highlight
        const originalTextKey = this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '');
        console.log('[Focus Button] Original textKey:', originalTextKey);
        
        // Try exact match first with current key
        let highlight = TextSelector.textToHighlights.get(this.currentTextKey);
        let matchedKey = this.currentTextKey;
        
        // If no match, try with originalTextKey (after removing suffixes)
        if (!highlight) {
          highlight = TextSelector.textToHighlights.get(originalTextKey);
          matchedKey = originalTextKey;
          console.log('[Focus Button] Trying with originalTextKey:', originalTextKey, 'Found:', !!highlight);
        }
        
        // If still no match, try checking askedTexts map (for green chat icon texts)
        if (!highlight) {
          console.log('[Focus Button] Trying to find in askedTexts...');
          const askedData = TextSelector.askedTexts.get(originalTextKey);
          if (askedData && askedData.highlight) {
            highlight = askedData.highlight;
            matchedKey = originalTextKey;
            console.log('[Focus Button] Found in askedTexts:', originalTextKey);
          } else {
            // Try iterating through askedTexts to find a partial match
            console.log('[Focus Button] Trying to find matching asked text by iteration...');
            for (const [key, data] of TextSelector.askedTexts) {
              if (key.includes(originalTextKey) || originalTextKey.includes(key)) {
                highlight = data.highlight;
                matchedKey = key;
                console.log('[Focus Button] Found matching asked text:', key);
                break;
              }
            }
          }
        }
        
        // If still no match, try checking simplifiedTexts map
        if (!highlight) {
          console.log('[Focus Button] Trying to find in simplifiedTexts...');
          const simplifiedData = TextSelector.simplifiedTexts.get(originalTextKey);
          if (simplifiedData && simplifiedData.highlight) {
            highlight = simplifiedData.highlight;
            matchedKey = originalTextKey;
            console.log('[Focus Button] Found in simplifiedTexts:', originalTextKey);
          } else {
            // Try to find a matching key in simplifiedTexts by comparing text positions
            console.log('[Focus Button] Trying to find matching simplified text by position...');
            const parts = originalTextKey.split('-');
            if (parts.length >= 4) {
              const contentType = parts[0];
              const tabId = parts[1];
              const startIndex = parseInt(parts[2]);
              const textLength = parseInt(parts[3]);
              
              // Search through simplifiedTexts for matching position
              for (const [key, data] of TextSelector.simplifiedTexts) {
                if (data.textStartIndex === startIndex && data.textLength === textLength) {
                  highlight = data.highlight;
                  matchedKey = key;
                  console.log('[Focus Button] Found matching simplified text by position:', key);
                  break;
                }
              }
            }
          }
        }
        
        // If no exact match, try searching by comparing the current text with highlight text
        if (!highlight && this.currentText) {
          console.log('[Focus Button] Trying to match by text content...');
          const currentText = this.currentText.trim();
          
          // Search through all highlights
          for (const [key, element] of TextSelector.textToHighlights) {
            const elementText = element.textContent.replace(/\s+/g, ' ').trim();
            if (elementText === currentText || elementText.includes(currentText) || currentText.includes(elementText)) {
              highlight = element;
              matchedKey = key;
              console.log('[Focus Button] Found match by text content:', key.substring(0, 50) + '...');
              break;
            }
          }
        }
        
        // If no exact match, try fuzzy matching
        if (!highlight) {
          console.log('[Focus Button] No exact match, trying fuzzy matching...');
          
          // Find the best matching key by comparing text content
          let bestMatch = null;
          let bestScore = 0;
          
          for (const [key, element] of TextSelector.textToHighlights) {
            // Calculate similarity score based on common text length
            const commonLength = this.calculateCommonTextLength(originalTextKey, key);
            const score = commonLength / Math.max(originalTextKey.length, key.length);
            
            console.log('[Focus Button] Comparing with key:', key.substring(0, 50) + '...', 'Score:', score);
            
            if (score > bestScore && score > 0.7) { // Require at least 70% similarity
              bestScore = score;
              bestMatch = element;
              matchedKey = key;
            }
          }
          
          if (bestMatch) {
            highlight = bestMatch;
            console.log('[Focus Button] Found fuzzy match with score:', bestScore, 'Key:', matchedKey);
          }
        }
        
        console.log('[Focus Button] Found highlight:', highlight);
        
        if (highlight) {
          console.log('[Focus Button] Scrolling to highlight and pulsating');
          
          // First scroll to the element
          highlight.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
          });
          
          // Always use green pulsate for focus button
          const isGreenPulsate = true;
          const pulsateClassName = 'vocab-text-pulsate-green';
          console.log('[Focus Button] Using green pulsate for focus button');
          
          // Pulsate with green color twice
          setTimeout(() => {
            // First pulsate - ensure class is removed first to restart animation
            highlight.classList.remove(pulsateClassName);
            // Force reflow to ensure class removal is processed
            void highlight.offsetWidth;
            TextSelector.pulsateText(highlight, isGreenPulsate);
            console.log('[Focus Button] First green pulsate animation triggered');
            
            // Second pulsate after the first animation completes (1.2s for green)
            setTimeout(() => {
              // Remove class first to restart animation
              highlight.classList.remove(pulsateClassName);
              // Force reflow to ensure class removal is processed
              void highlight.offsetWidth;
              TextSelector.pulsateText(highlight, isGreenPulsate);
              console.log('[Focus Button] Second green pulsate animation triggered');
            }, 1200); // 1.2s duration for green pulsate animation
          }, 300); // Small delay to let scroll complete
        } else {
          console.log('[Focus Button] No highlight found for textKey:', originalTextKey);
          console.log('[Focus Button] Current textKey:', this.currentTextKey);
          console.log('[Focus Button] Available textToHighlights keys:', Array.from(TextSelector.textToHighlights.keys()));
          console.log('[Focus Button] Available askedTexts keys:', Array.from(TextSelector.askedTexts.keys()));
          console.log('[Focus Button] Available simplifiedTexts keys:', Array.from(TextSelector.simplifiedTexts.keys()));
        }
      } else {
        console.log('[Focus Button] No currentTextKey available');
      }
    });
    
    // Create content area
    const contentArea = document.createElement('div');
    contentArea.className = 'vocab-chat-content-area';
    
    // Create simplified content (always present)
    const simplifiedContent = this.createSimplifiedContent();
    contentArea.appendChild(simplifiedContent);
    
    // Create input area
    const inputArea = this.createInputArea();
    
    // Create resize handles
    const resizeHandles = this.createResizeHandles();
    
    // Assemble dialog
    dialogContent.appendChild(leftButtonContainer);
    dialogContent.appendChild(focusButton);
    dialogContent.appendChild(contentArea);
    dialogContent.appendChild(inputArea);
    
    this.dialogContainer.appendChild(dialogContent);
    this.dialogContainer.appendChild(resizeHandles.left);
    this.dialogContainer.appendChild(resizeHandles.bottom);
    this.dialogContainer.appendChild(resizeHandles.bottomLeft);
    this.dialogContainer.appendChild(resizeHandles.topLeft);
    
    document.body.appendChild(this.dialogContainer);
    console.log('[ChatDialog] Dialog container appended to body');
    
    // Initialize resize functionality
    this.initResize();
    
    // Load saved dimensions after dialog is created
    this.loadSavedDimensions();
  },
  
  /**
   * Create resize handles
   */
  createResizeHandles() {
    const leftHandle = document.createElement('div');
    leftHandle.className = 'vocab-chat-resize-handle vocab-chat-resize-left';
    
    const bottomHandle = document.createElement('div');
    bottomHandle.className = 'vocab-chat-resize-handle vocab-chat-resize-bottom';
    
    const bottomLeftHandle = document.createElement('div');
    bottomLeftHandle.className = 'vocab-chat-resize-handle vocab-chat-resize-bottom-left';
    
    const topLeftHandle = document.createElement('div');
    topLeftHandle.className = 'vocab-chat-resize-handle vocab-chat-resize-top-left';
    
    return {
      left: leftHandle,
      bottom: bottomHandle,
      bottomLeft: bottomLeftHandle,
      topLeft: topLeftHandle
    };
  },
  
  /**
   * Initialize resize functionality
   */
  initResize() {
    let isResizing = false;
    let resizeType = null;
    let startX = 0;
    let startY = 0;
    let startWidth = 0;
    let startHeight = 0;
    
    const startResize = (e, type) => {
      isResizing = true;
      resizeType = type;
      startX = e.clientX;
      startY = e.clientY;
      
      const rect = this.dialogContainer.getBoundingClientRect();
      startWidth = rect.width;
      startHeight = rect.height;
      
      e.preventDefault();
      document.body.style.userSelect = 'none';
    };
    
    const resize = (e) => {
      if (!isResizing) return;
      
      const deltaX = startX - e.clientX; // Inverted for right-side panel
      const deltaY = e.clientY - startY;
      
      if (resizeType === 'left' || resizeType === 'bottom-left' || resizeType === 'top-left') {
        const newWidth = Math.max(300, Math.min(800, startWidth + deltaX));
        this.dialogContainer.style.setProperty('width', `${newWidth}px`, 'important');
        console.log('[ChatDialog] DEBUG: Resizing width to:', newWidth);
      }
      
      if (resizeType === 'bottom' || resizeType === 'bottom-left') {
        const newHeight = Math.max(400, Math.min(window.innerHeight * 0.9, startHeight + deltaY));
        this.dialogContainer.style.setProperty('height', `${newHeight}px`, 'important');
        console.log('[ChatDialog] DEBUG: Resizing height to:', newHeight);
      }
      
      if (resizeType === 'top-left') {
        const newHeight = Math.max(400, Math.min(window.innerHeight * 0.9, startHeight - deltaY));
        this.dialogContainer.style.setProperty('height', `${newHeight}px`, 'important');
        console.log('[ChatDialog] DEBUG: Resizing height (top-left) to:', newHeight);
      }
    };
    
    const stopResize = () => {
      if (!isResizing) return;
      
      console.log('[ChatDialog] DEBUG: Stopping resize, current dimensions:', {
        width: this.dialogContainer.style.width,
        height: this.dialogContainer.style.height
      });
      
      // Save current dimensions to session storage
      this.saveDimensions();
      
      isResizing = false;
      resizeType = null;
      document.body.style.userSelect = '';
    };
    
    // Attach event listeners to resize handles
    const leftHandle = this.dialogContainer.querySelector('.vocab-chat-resize-left');
    const bottomHandle = this.dialogContainer.querySelector('.vocab-chat-resize-bottom');
    const bottomLeftHandle = this.dialogContainer.querySelector('.vocab-chat-resize-bottom-left');
    const topLeftHandle = this.dialogContainer.querySelector('.vocab-chat-resize-top-left');
    
    leftHandle.addEventListener('mousedown', (e) => startResize(e, 'left'));
    bottomHandle.addEventListener('mousedown', (e) => startResize(e, 'bottom'));
    bottomLeftHandle.addEventListener('mousedown', (e) => startResize(e, 'bottom-left'));
    topLeftHandle.addEventListener('mousedown', (e) => startResize(e, 'top-left'));
    
    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResize);
  },
  
  /**
   * Save current dialog dimensions to localStorage
   */
  saveDimensions() {
    if (!this.dialogContainer) {
      console.log('[ChatDialog] ERROR: No dialog container to save dimensions');
      return;
    }
    
    // Get computed dimensions to ensure we capture the actual size
    const computedStyle = window.getComputedStyle(this.dialogContainer);
    const dimensions = {
      width: computedStyle.width || this.dialogContainer.style.width || '400px',
      height: computedStyle.height || this.dialogContainer.style.height || '600px'
    };
    
    console.log('[ChatDialog] DEBUG: Saving dimensions:', dimensions);
    
    try {
      localStorage.setItem('chatDialogDimensions', JSON.stringify(dimensions));
      console.log('[ChatDialog] SUCCESS: Dimensions saved to localStorage:', dimensions);
    } catch (error) {
      console.log('[ChatDialog] ERROR saving dimensions:', error);
    }
  },
  
  /**
   * Load saved dimensions from localStorage and apply them
   */
  loadSavedDimensions() {
    console.log('[ChatDialog] DEBUG: Attempting to load saved dimensions...');
    
    if (!this.dialogContainer) {
      console.log('[ChatDialog] DEBUG: No dialog container available');
      return;
    }
    
    try {
      const savedDimensions = localStorage.getItem('chatDialogDimensions');
      console.log('[ChatDialog] DEBUG: localStorage result:', savedDimensions);
      
      let width, height;
      
      if (savedDimensions) {
        const dimensions = JSON.parse(savedDimensions);
        width = dimensions.width;
        height = dimensions.height;
        console.log('[ChatDialog] DEBUG: Found saved dimensions:', { width, height });
      } else {
        // Set default dimensions if none are saved
        width = '600px';
        height = '800px';
        console.log('[ChatDialog] DEBUG: No saved dimensions found, using defaults:', { width, height });
      }
      
      // Apply dimensions with !important to override CSS and site-specific styles
      this.dialogContainer.style.setProperty('width', width, 'important');
      this.dialogContainer.style.setProperty('height', height, 'important');
      
      console.log('[ChatDialog] SUCCESS: Applied dimensions:', { width, height });
    } catch (error) {
      console.log('[ChatDialog] ERROR loading dimensions:', error);
      // Fallback to default dimensions on error
      this.dialogContainer.style.setProperty('width', '600px', 'important');
      this.dialogContainer.style.setProperty('height', '800px', 'important');
    }
  },
  
  /**
   * Create tabs section
   */
  createTabs() {
    const tabsContainer = document.createElement('div');
    tabsContainer.className = 'vocab-chat-tabs';
    
    // First tab: "Original text" for ask mode, "Simplified" for simplified mode
    const firstTab = document.createElement('button');
    
    if (this.mode === 'simplified') {
      // In simplified mode, first tab is "Simplified explanation" and is active
      firstTab.className = 'vocab-chat-tab active';
      firstTab.setAttribute('data-tab', 'simplified');
      firstTab.textContent = 'Simplified explanation';
      firstTab.addEventListener('click', () => this.switchTab('simplified'));
    } else {
      // In ask mode, first tab is "Simplified explanation" and is not active
      firstTab.className = 'vocab-chat-tab';
      firstTab.setAttribute('data-tab', 'simplified');
      firstTab.textContent = 'Simplified explanation';
      firstTab.addEventListener('click', () => this.switchTab('simplified'));
    }
    
    // Second tab: Always "Ask on content"
    const chatTab = document.createElement('button');
    // Chat tab is active in ask mode, not active in simplified mode
    chatTab.className = this.mode === 'simplified' ? 'vocab-chat-tab' : 'vocab-chat-tab active';
    chatTab.setAttribute('data-tab', 'ask');
    chatTab.textContent = 'Ask on content';
    chatTab.addEventListener('click', () => this.switchTab('ask'));
    
    // Create sliding indicator
    const indicator = document.createElement('div');
    indicator.className = 'vocab-chat-tab-indicator';
    indicator.id = 'vocab-chat-tab-indicator';
    
    tabsContainer.appendChild(firstTab);
    tabsContainer.appendChild(chatTab);
    tabsContainer.appendChild(indicator);
    
    // Set initial indicator position after a brief delay to let tabs render
    setTimeout(() => {
      this.updateIndicatorPosition();
    }, 50);
    
    return tabsContainer;
  },
  
  /**
   * Create simplified text content
   */
  createSimplifiedContent() {
    const content = document.createElement('div');
    content.className = 'vocab-chat-tab-content active';
    content.setAttribute('data-content', 'simplified');
    content.style.display = 'flex';
    content.style.flexDirection = 'column';
    content.style.height = '100%';
    content.style.overflow = 'hidden';
    
    // Create scrollable container for all content
    const scrollableContainer = document.createElement('div');
    scrollableContainer.className = 'vocab-chat-scrollable-content';
    scrollableContainer.style.flex = '1';
    scrollableContainer.style.overflowY = 'auto';
    scrollableContainer.style.padding = '16px';
    
    // Container for all simplified explanations
    const explanationsContainer = document.createElement('div');
    explanationsContainer.id = 'vocab-chat-simplified-container';
    
    // Build all simplified explanations (current + previous)
    this.renderSimplifiedExplanations(explanationsContainer);
    
    // Create summary container (above button) for ask-about-page chat
    if (this.chatContext === 'general' && this.currentTextKey && this.currentTextKey.startsWith('page-general')) {
      // Check global variables first
      const hasGlobalSummary = window.pageSummary !== null && window.pageSummaryPossibleQuestions !== null;
      
      // Only create and render summary container if global variables are not null
      if (hasGlobalSummary) {
        const summaryContainer = document.createElement('div');
        summaryContainer.id = 'vocab-chat-page-summary-container';
        summaryContainer.className = 'vocab-chat-page-summary-container';
        
        // Load from global variables to instance variables if needed
        if (!this.pageSummary) {
          this.pageSummary = window.pageSummary;
          this.pagePossibleQuestions = window.pageSummaryPossibleQuestions;
        }
        
        // Render summary if it exists
        if (this.pageSummary) {
          this.renderPageSummaryWithQuestions(summaryContainer);
        }
        
        scrollableContainer.appendChild(summaryContainer);
      }
    }
    
    // Create "Simplify more" button container
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'vocab-chat-simplify-more-container';
    
    // Only show "Simplify more" button for selected text chat, not for general content chat
    // For ask-about-page (page-general), show "Summarise the page" button instead
    console.log('[ChatDialog] Creating Simplify more button - chatContext:', this.chatContext, 'mode:', this.mode, 'textKey:', this.currentTextKey);
    // Check for both 'page-general' and 'page-general-generic' (the transformed key)
    if (this.chatContext === 'general' && this.currentTextKey && this.currentTextKey.startsWith('page-general')) {
      // Check global variables first
      const hasGlobalSummary = window.pageSummary !== null && window.pageSummaryPossibleQuestions !== null;
      
      // Show "Summarise the page" button for ask-about-page chat
      console.log('[ChatDialog] Adding Summarise the page button');
      const summariseBtn = document.createElement('button');
      summariseBtn.className = 'vocab-chat-simplify-more-btn';
      summariseBtn.innerHTML = `${this.createSparkleIcon()} Summarise this page`;
      summariseBtn.id = 'vocab-chat-summarise-page-btn';
      
      // If global summary exists, show "Clear summary" button
      if (hasGlobalSummary) {
        // Load from global variables to instance variables if needed
        if (!this.pageSummary) {
          this.pageSummary = window.pageSummary;
          this.pagePossibleQuestions = window.pageSummaryPossibleQuestions;
        }
        
        summariseBtn.innerHTML = 'Clear summary';
        summariseBtn.disabled = false;
        summariseBtn.classList.remove('disabled');
        console.log('[ChatDialog] Global summary exists - showing "Clear summary" button');
        
        // Add onclick handler to clear summary
        summariseBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          console.log('[ChatDialog] Clear summary button clicked in simplified content!');
          this.clearSummary();
        }, true); // Use capture phase
      } else {
      // Add onclick handler to call summarise API
      summariseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        console.log('[ChatDialog] Summarise button clicked in simplified content!');
        this.handleSummarisePage();
      }, true); // Use capture phase
      }
      
      buttonContainer.appendChild(summariseBtn);
    } else if (this.chatContext !== 'general' && this.mode === 'simplified') {
      console.log('[ChatDialog] Adding Simplify more button');
      const simplifyMoreBtn = document.createElement('button');
      simplifyMoreBtn.className = 'vocab-chat-simplify-more-btn';
      simplifyMoreBtn.textContent = 'Simplify more';
      simplifyMoreBtn.id = 'vocab-chat-simplify-more-btn';
      
      // Always enable the simplify more button
        simplifyMoreBtn.disabled = false;
      simplifyMoreBtn.classList.remove('disabled');
      
      // Add click handler
      simplifyMoreBtn.addEventListener('click', () => this.handleSimplifyMore());
      
      buttonContainer.appendChild(simplifyMoreBtn);
    } else {
      console.log('[ChatDialog] NOT adding Simplify more button - chatContext:', this.chatContext, 'mode:', this.mode);
    }
    
    // Create chat container below Simplify more button with top margin
    const chatContainer = document.createElement('div');
    chatContainer.className = 'vocab-chat-messages';
    chatContainer.id = 'vocab-chat-messages';
    chatContainer.style.marginTop = '20px';
    
    // If we have existing chat history, render it
    if (this.chatHistory && this.chatHistory.length > 0) {
      this.chatHistory.forEach(item => {
        this.renderChatMessage(chatContainer, item.type, item.message, item.possibleQuestions || []);
      });
      
      // Update delete button visibility and scroll to bottom after rendering
      setTimeout(() => {
        this.updateGlobalClearButton();
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }, 10);
    } else {
      // Show appropriate message based on chat context
      const promptText = this.chatContext === 'selected' 
        ? 'Ask anything on the selected content' 
        : 'Ask anything about the page';
      
      const noChatsMsg = document.createElement('div');
      noChatsMsg.className = 'vocab-chat-no-messages';
      noChatsMsg.innerHTML = `
        <div class="vocab-chat-no-messages-content">
          ${this.createChatEmptyIcon()}
          <span>${promptText}</span>
        </div>
      `;
      chatContainer.appendChild(noChatsMsg);
    }
    
    // Add all content to scrollable container
    scrollableContainer.appendChild(explanationsContainer);
    scrollableContainer.appendChild(buttonContainer);
    scrollableContainer.appendChild(chatContainer);
    
    // Add scrollable container to main content
    content.appendChild(scrollableContainer);
    
    return content;
  },
  
  /**
   * Render all simplified explanations with headers
   * @param {HTMLElement} container - Container element to render into
   */
  renderSimplifiedExplanations(container) {
    if (!container) {
      console.warn('[ChatDialog] Container is null, cannot render simplified explanations');
      return;
    }
    
    // Always try to get the latest data from TextSelector first (for streaming updates)
    let dataToRender = null;
    let textSelectorData = null;
    if (this.currentTextKey) {
      // Try to get data from TextSelector using the original textKey and key variations
      const originalTextKey = this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '');
      
      // Try multiple key variations to find the data
      const keyVariations = [
        originalTextKey,
        `${originalTextKey}-selected`,
        `${originalTextKey}-generic`,
        this.currentTextKey
      ];
      
      for (const key of keyVariations) {
        const data = TextSelector.simplifiedTexts.get(key);
        if (data && (data.simplifiedText || data.accumulatedSimplifiedText || (Array.isArray(data.previousSimplifiedTexts) && data.previousSimplifiedTexts.length > 0))) {
          textSelectorData = data;
          console.log('[ChatDialog] Retrieved simplified data from TextSelector for key:', key);
          console.log('[ChatDialog] TextSelector data.possibleQuestions:', textSelectorData.possibleQuestions);
          console.log('[ChatDialog] TextSelector data.possibleQuestions length:', textSelectorData.possibleQuestions?.length || 0);
          break;
        }
      }
    }
    
    // Priority order:
    // 1. this.simplifiedData if it has simplifiedText or accumulatedSimplifiedText (most recent, might have questions)
    // 2. textSelectorData if it has simplifiedText or accumulatedSimplifiedText (streaming data)
    // 3. this.simplifiedData as fallback
    
    // Check if this.simplifiedData has text (either simplifiedText or accumulatedSimplifiedText from streaming)
    const hasSimplifiedDataText = this.simplifiedData && (
      this.simplifiedData.simplifiedText || 
      this.simplifiedData.accumulatedSimplifiedText ||
      (Array.isArray(this.simplifiedData.previousSimplifiedTexts) && this.simplifiedData.previousSimplifiedTexts.length > 0)
    );
    
    // Check if textSelectorData has text
    const hasTextSelectorDataText = textSelectorData && (
      textSelectorData.simplifiedText || 
      textSelectorData.accumulatedSimplifiedText ||
      (Array.isArray(textSelectorData.previousSimplifiedTexts) && textSelectorData.previousSimplifiedTexts.length > 0)
    );
    
    if (hasSimplifiedDataText) {
      dataToRender = this.simplifiedData;
      // If simplifiedText is empty but accumulatedSimplifiedText exists, use it
      if (!dataToRender.simplifiedText && dataToRender.accumulatedSimplifiedText) {
        dataToRender = { ...dataToRender, simplifiedText: dataToRender.accumulatedSimplifiedText };
      }
      console.log('[ChatDialog] Using simplifiedData from ChatDialog');
      console.log('[ChatDialog] Has simplifiedText:', !!dataToRender.simplifiedText);
      console.log('[ChatDialog] Has previousSimplifiedTexts:', Array.isArray(dataToRender.previousSimplifiedTexts) && dataToRender.previousSimplifiedTexts.length > 0);
      console.log('[ChatDialog] Has possibleQuestions:', !!dataToRender.possibleQuestions && dataToRender.possibleQuestions.length > 0);
      console.log('[ChatDialog] Has explanationQuestions:', !!dataToRender.explanationQuestions && dataToRender.explanationQuestions.length > 0);
    } else if (hasTextSelectorDataText) {
      dataToRender = textSelectorData;
      // If simplifiedText is empty but accumulatedSimplifiedText exists, use it
      if (!dataToRender.simplifiedText && dataToRender.accumulatedSimplifiedText) {
        dataToRender = { ...dataToRender, simplifiedText: dataToRender.accumulatedSimplifiedText };
      }
      console.log('[ChatDialog] Using simplifiedData from TextSelector');
      console.log('[ChatDialog] Has simplifiedText:', !!dataToRender.simplifiedText);
      console.log('[ChatDialog] Has previousSimplifiedTexts:', Array.isArray(dataToRender.previousSimplifiedTexts) && dataToRender.previousSimplifiedTexts.length > 0);
      console.log('[ChatDialog] Has possibleQuestions:', !!dataToRender.possibleQuestions && dataToRender.possibleQuestions.length > 0);
      console.log('[ChatDialog] Has explanationQuestions:', !!dataToRender.explanationQuestions && dataToRender.explanationQuestions.length > 0);
    } else if (this.simplifiedData) {
      dataToRender = this.simplifiedData;
      console.log('[ChatDialog] Using simplifiedData from ChatDialog (fallback - no text found)');
    }
    
    if (!dataToRender) {
      console.log('[ChatDialog] No simplified data available to render');
      return;
    }
    
    console.log('[ChatDialog] renderSimplifiedExplanations - dataToRender.possibleQuestions:', dataToRender.possibleQuestions);
    console.log('[ChatDialog] renderSimplifiedExplanations - dataToRender.possibleQuestions type:', typeof dataToRender.possibleQuestions);
    console.log('[ChatDialog] renderSimplifiedExplanations - dataToRender.possibleQuestions is array:', Array.isArray(dataToRender.possibleQuestions));
    console.log('[ChatDialog] renderSimplifiedExplanations - dataToRender.possibleQuestions length:', dataToRender.possibleQuestions?.length || 0);
    
    // Ensure previousSimplifiedTexts is an array
    let previousSimplifiedTextsArray = Array.isArray(dataToRender.previousSimplifiedTexts)
      ? dataToRender.previousSimplifiedTexts
      : (dataToRender.previousSimplifiedTexts ? [dataToRender.previousSimplifiedTexts] : []);
    
    // Get all explanations (previous + current)
    let allExplanations = [
      ...previousSimplifiedTextsArray,
      ...(dataToRender.simplifiedText ? [dataToRender.simplifiedText] : [])
    ].filter(Boolean); // Remove any null/undefined values
    
    // Ensure we have at least one explanation to render
    // If we don't have explanations but have questions, try to get data from TextSelector
    if (allExplanations.length === 0) {
      console.warn('[ChatDialog] No explanations found in dataToRender, trying to get from TextSelector');
      console.log('[ChatDialog] Current textKey:', this.currentTextKey);
      console.log('[ChatDialog] dataToRender keys:', dataToRender ? Object.keys(dataToRender) : 'null');
      console.log('[ChatDialog] dataToRender.simplifiedText:', dataToRender?.simplifiedText?.substring(0, 50) || 'empty');
      console.log('[ChatDialog] dataToRender.previousSimplifiedTexts:', dataToRender?.previousSimplifiedTexts);
      
      if (this.currentTextKey) {
        // Try multiple key variations to find the data
        const keyVariations = [
          this.currentTextKey,
          this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, ''),
          `${this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '')}-selected`,
          `${this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '')}-generic`
        ];
        
        let textSelectorData = null;
        let foundKey = null;
        
        // Try each key variation
        for (const key of keyVariations) {
          const data = TextSelector.simplifiedTexts.get(key);
          if (data && (data.simplifiedText || (Array.isArray(data.previousSimplifiedTexts) && data.previousSimplifiedTexts.length > 0))) {
            textSelectorData = data;
            foundKey = key;
            console.log('[ChatDialog] Found data in TextSelector with key:', key);
            break;
          }
        }
        
        // Also try iterating through all entries if key-based lookup fails
        if (!textSelectorData) {
          console.log('[ChatDialog] Key-based lookup failed, trying to find by matching textStartIndex/textLength');
          const dataToRenderTextStartIndex = dataToRender?.textStartIndex;
          const dataToRenderTextLength = dataToRender?.textLength;
          
          if (dataToRenderTextStartIndex !== undefined && dataToRenderTextLength !== undefined) {
            for (const [key, data] of TextSelector.simplifiedTexts.entries()) {
              if (data.textStartIndex === dataToRenderTextStartIndex && 
                  data.textLength === dataToRenderTextLength &&
                  (data.simplifiedText || (Array.isArray(data.previousSimplifiedTexts) && data.previousSimplifiedTexts.length > 0))) {
                textSelectorData = data;
                foundKey = key;
                console.log('[ChatDialog] Found data in TextSelector by matching position, key:', key);
                break;
              }
            }
          }
        }
        
        if (textSelectorData) {
          const fallbackPrevious = Array.isArray(textSelectorData.previousSimplifiedTexts)
            ? textSelectorData.previousSimplifiedTexts
            : (textSelectorData.previousSimplifiedTexts ? [textSelectorData.previousSimplifiedTexts] : []);
          const fallbackExplanations = [
            ...fallbackPrevious,
            ...(textSelectorData.simplifiedText ? [textSelectorData.simplifiedText] : [])
          ].filter(Boolean);
          
          console.log('[ChatDialog] Fallback explanations found:', fallbackExplanations.length);
          console.log('[ChatDialog] Fallback previous count:', fallbackPrevious.length);
          console.log('[ChatDialog] Fallback simplifiedText exists:', !!textSelectorData.simplifiedText);
          
          if (fallbackExplanations.length > 0) {
            // Merge the data - use questions from dataToRender if available, otherwise from textSelectorData
            const mergedData = {
              ...textSelectorData,
              explanationQuestions: dataToRender?.explanationQuestions || textSelectorData.explanationQuestions || [],
              possibleQuestions: dataToRender?.possibleQuestions || textSelectorData.possibleQuestions || []
            };
            
            // Use merged data
            dataToRender = mergedData;
            previousSimplifiedTextsArray = fallbackPrevious;
            allExplanations = fallbackExplanations;
            
            console.log('[ChatDialog] Successfully merged data from TextSelector');
            console.log('[ChatDialog] Merged explanationQuestions:', mergedData.explanationQuestions);
            console.log('[ChatDialog] Merged possibleQuestions:', mergedData.possibleQuestions);
          }
        } else {
          console.warn('[ChatDialog] No data found in TextSelector with any key variation');
          console.log('[ChatDialog] Available keys in TextSelector:', Array.from(TextSelector.simplifiedTexts.keys()));
        }
      }
      
      // If still no explanations, don't render
      if (allExplanations.length === 0) {
        console.warn('[ChatDialog] No explanations available to render after all fallback attempts');
        console.warn('[ChatDialog] This might mean the simplified text was not streamed or stored properly');
        return;
      }
    }
    
    container.innerHTML = '';
    
    console.log('[ChatDialog] Rendering', allExplanations.length, 'simplified explanations');
    console.log('[ChatDialog] Previous explanations count:', previousSimplifiedTextsArray.length);
    console.log('[ChatDialog] Current simplified text exists:', !!dataToRender.simplifiedText);
    
    // Get explanationQuestions array - stores questions per explanation version
    // Index 0 = first explanation, Index 1 = second explanation, etc.
    // This ensures each explanation has its own set of possible questions
    const explanationQuestions = Array.isArray(dataToRender.explanationQuestions) 
      ? dataToRender.explanationQuestions 
      : [];
    
    console.log('[ChatDialog] explanationQuestions array:', explanationQuestions);
    console.log('[ChatDialog] explanationQuestions array length:', explanationQuestions.length);
    
    // Render each explanation with header
    allExplanations.forEach((explanation, index) => {
      const item = document.createElement('div');
      item.className = 'vocab-chat-simplified-item';
      
      // Create header
      const header = document.createElement('div');
      header.className = 'vocab-chat-simplified-header';
      header.textContent = `Simplified explanation ${index + 1}`;
      
      // Create text display
      const textDisplay = document.createElement('div');
      textDisplay.className = 'vocab-chat-simplified-text';
      textDisplay.textContent = explanation;
      
      item.appendChild(header);
      item.appendChild(textDisplay);
      
      // Get questions for THIS specific explanation from explanationQuestions array
      // Each explanation has its own questions stored at the corresponding index
      const questionsForThisExplanation = explanationQuestions[index] || [];
      const validQuestions = Array.isArray(questionsForThisExplanation) && questionsForThisExplanation.length > 0
        ? questionsForThisExplanation.filter(q => q && q.trim() !== '')
        : [];
      
      console.log('[ChatDialog] ===== RENDERING EXPLANATION', index + 1, '=====');
      console.log('[ChatDialog] Questions for explanation index', index, ':', questionsForThisExplanation);
      console.log('[ChatDialog] Valid questions count:', validQuestions.length);
      
      // Render questions for this specific explanation if they exist
      if (validQuestions.length > 0) {
        console.log('[ChatDialog] ✓✓✓ RENDERING QUESTIONS FOR EXPLANATION', index + 1, '✓✓✓');
        console.log('[ChatDialog] validQuestions to render:', validQuestions);
        console.log('[SUBHRAM] Creating questions container...');
        
        const questionsContainer = document.createElement('div');
        questionsContainer.className = 'vocab-chat-message-questions-container';
        
        console.log('[SUBHRAM] Building questions HTML...');
        const questionsHTML = `
          <h4 class="vocab-chat-message-questions-header">You might be interested on:</h4>
          <div class="vocab-chat-message-questions-list">
            ${validQuestions.map((question, qIndex) => {
              console.log('[SUBHRAM] Mapping question', qIndex, ':', question);
              return `
              <div class="vocab-chat-message-question-item" data-question="${this.escapeHtml(question)}">
                <span class="vocab-chat-message-question-icon">+</span>
                <span>${this.escapeHtml(question)}</span>
              </div>
            `;
            }).join('')}
          </div>
        `;
        
        console.log('[SUBHRAM] Questions HTML created, length:', questionsHTML.length);
        console.log('[SUBHRAM] Setting innerHTML on questionsContainer...');
        questionsContainer.innerHTML = questionsHTML;
        
        // Verify the HTML was set
        console.log('[SUBHRAM] questionsContainer.innerHTML length after setting:', questionsContainer.innerHTML.length);
        console.log('[SUBHRAM] questionsContainer children count:', questionsContainer.children.length);
        
        // Add click handlers to question items
        const questionItems = questionsContainer.querySelectorAll('.vocab-chat-message-question-item');
        console.log('[SUBHRAM] Found question items:', questionItems.length);
        questionItems.forEach((qItem, qIndex) => {
          console.log('[SUBHRAM] Adding click handler to question item', qIndex);
          qItem.addEventListener('click', () => {
            const question = qItem.getAttribute('data-question');
            console.log('[ChatDialog] Simplified explanation question clicked:', question);
            this.askQuestion(question);
          });
        });
        
        // Append questions container to the explanation item
        console.log('[SUBHRAM] Appending questionsContainer to item...');
        item.appendChild(questionsContainer);
        console.log('[SUBHRAM] questionsContainer appended. Item children count:', item.children.length);
        
        // Verify it's in the DOM
        const verifyContainer = item.querySelector('.vocab-chat-message-questions-container');
        console.log('[SUBHRAM] Verification - questionsContainer found in item:', !!verifyContainer);
        
        // Trigger animation by forcing a reflow
        setTimeout(() => {
          void questionsContainer.offsetHeight;
          console.log('[SUBHRAM] Animation trigger executed');
        }, 0);
      } else {
        console.log('[SUBHRAM] ✗✗✗ NOT RENDERING QUESTIONS ✗✗✗');
        console.log('[SUBHRAM] Reason - validQuestions.length is 0');
      }
      
      container.appendChild(item);
      console.log('[SUBHRAM] Item appended to container. Container children count:', container.children.length);
    });
    
    console.log('[SUBHRAM] ===== FINISHED RENDERING ALL EXPLANATIONS =====');
    console.log('[SUBHRAM] Final container children count:', container.children.length);
    const finalQuestionsContainer = container.querySelector('.vocab-chat-message-questions-container');
    console.log('[SUBHRAM] Final verification - questionsContainer found in main container:', !!finalQuestionsContainer);
    
    // Brain icon removed - no longer showing pulsating icon below simplified explanations
  },
  
  // Brain icon functionality removed - no longer needed
  
  /**
   * Handle "Simplify more" button click
   */
  async handleSimplifyMore() {
    if (!this.simplifiedData || !this.currentTextKey) return;
    if (this.isSimplifying) return;
    
    console.log('[ChatDialog] Simplify more clicked');
    
    this.isSimplifying = true;
    
    // Disable button and show loading state
    const simplifyMoreBtn = document.getElementById('vocab-chat-simplify-more-btn');
    if (simplifyMoreBtn) {
      simplifyMoreBtn.disabled = true;
      simplifyMoreBtn.classList.add('disabled', 'loading');
      simplifyMoreBtn.textContent = 'Simplifying...';
    }
    
    // Build API request with ALL previous simplified explanations
    // Ensure previousSimplifiedTexts is an array
    const previousSimplifiedTextsArray = Array.isArray(this.simplifiedData.previousSimplifiedTexts)
      ? this.simplifiedData.previousSimplifiedTexts
      : (this.simplifiedData.previousSimplifiedTexts ? [this.simplifiedData.previousSimplifiedTexts] : []);
    
    // Include ALL previous explanations + current simplified text
    const previousSimplifiedTexts = [
      ...previousSimplifiedTextsArray,
      ...(this.simplifiedData.simplifiedText ? [this.simplifiedData.simplifiedText] : [])
    ].filter(Boolean); // Remove any null/undefined values
    
    console.log('[ChatDialog] Sending API request with previousSimplifiedTexts:', {
      previousSimplifiedTextsCount: previousSimplifiedTextsArray.length,
      currentSimplifiedText: this.simplifiedData.simplifiedText,
      totalPreviousSimplifiedTexts: previousSimplifiedTexts.length,
      previousSimplifiedTexts: previousSimplifiedTexts
    });
    
    // Get full page text to extract context (same context as original simplify call)
    let pageText = '';
    if (pageTextContent) {
      try {
        const contentData = JSON.parse(pageTextContent);
        pageText = contentData.text || '';
      } catch (e) {
        console.warn('[ChatDialog] Error parsing pageTextContent, using fallback');
        pageText = document.body.innerText || document.body.textContent || '';
      }
    } else {
      pageText = document.body.innerText || document.body.textContent || '';
    }
    
    // Extract context: 50 words before + selected text + 50 words after
    // Use ButtonPanel's extractContextForText method if available, otherwise use inline logic
    let context = '';
    if (typeof ButtonPanel !== 'undefined' && ButtonPanel.extractContextForText) {
      context = ButtonPanel.extractContextForText(
        pageText,
        this.simplifiedData.textStartIndex,
        this.simplifiedData.textLength,
        this.simplifiedData.text
      );
    } else {
      // Fallback: inline context extraction using sentences
      const textBefore = pageText.substring(0, this.simplifiedData.textStartIndex);
      const textAfter = pageText.substring(this.simplifiedData.textStartIndex + this.simplifiedData.textLength);
      
      // Helper function to split text into sentences
      const splitIntoSentences = (text) => {
        if (!text || text.trim().length === 0) return [];
        const sentenceRegex = /[.!?]+(?:\s+|$)/g;
        const sentences = [];
        let lastIndex = 0;
        let match;
        while ((match = sentenceRegex.exec(text)) !== null) {
          const sentenceEnd = match.index + match[0].length;
          const sentence = text.substring(lastIndex, sentenceEnd).trim();
          if (sentence.length > 0) {
            sentences.push(sentence);
          }
          lastIndex = sentenceEnd;
        }
        if (lastIndex < text.length) {
          const remaining = text.substring(lastIndex).trim();
          if (remaining.length > 0) {
            sentences.push(remaining);
          }
        }
        return sentences;
      };
      
      const getLastNSentences = (text, n) => {
        if (!text || n <= 0) return '';
        const sentences = splitIntoSentences(text);
        const startIndex = Math.max(0, sentences.length - n);
        return sentences.slice(startIndex).join(' ');
      };
      
      const getFirstNSentences = (text, n) => {
        if (!text || n <= 0) return '';
        const sentences = splitIntoSentences(text);
        return sentences.slice(0, n).join(' ');
      };
      
      const sentencesBefore = getLastNSentences(textBefore, 3);
      const sentencesAfter = getFirstNSentences(textAfter, 3);
      context = [sentencesBefore, this.simplifiedData.text, sentencesAfter].filter(p => p.trim().length > 0).join(' ').trim();
    }
    
    const textSegments = [{
      textStartIndex: this.simplifiedData.textStartIndex,
      textLength: this.simplifiedData.textLength,
      text: this.simplifiedData.text,
      context: context, // Add context parameter
      previousSimplifiedTexts: previousSimplifiedTexts
    }];
    
    // Call ApiService
    ApiService.simplify(
      textSegments,
      // onEvent callback
      (eventData) => {
        console.log('[ChatDialog] Received simplified text event:', eventData);
        
        // Ensure previousSimplifiedTexts is always an array
        const previousSimplifiedTextsArray = Array.isArray(previousSimplifiedTexts) 
          ? previousSimplifiedTexts 
          : (previousSimplifiedTexts ? [previousSimplifiedTexts] : []);
        
        // Handle chunk events (streaming)
        if (eventData.chunk !== undefined) {
          console.log('[ChatDialog] Chunk event - chunk:', eventData.chunk, 'accumulatedSimplifiedText:', eventData.accumulatedSimplifiedText);
          
          // Get existing data to preserve explanationQuestions structure
          const originalTextKey = this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '');
          const existingData = TextSelector.simplifiedTexts.get(originalTextKey) || {};
          const streamingExplanationQuestions = existingData.explanationQuestions || [];
          
          // Update simplified data with streaming text
          this.simplifiedData = {
            textStartIndex: eventData.textStartIndex,
            textLength: eventData.textLength,
            text: eventData.text,
            simplifiedText: eventData.accumulatedSimplifiedText || '', // Use accumulated text for streaming
            previousSimplifiedTexts: previousSimplifiedTextsArray,
            shouldAllowSimplifyMore: false, // Will be set on complete
            explanationQuestions: streamingExplanationQuestions, // Preserve existing questions structure
            possibleQuestions: [], // Will be set on complete
            context: context // Store context for ask API (from closure)
          };
          
          // Update stored data - use original text key for storage
          TextSelector.simplifiedTexts.set(originalTextKey, this.simplifiedData);
          
          // Update UI in real-time - re-render all explanations with streaming text
          // Try multiple ways to find the container
          let container = null;
          if (this.dialogContainer) {
            container = this.dialogContainer.querySelector('#vocab-chat-simplified-container');
          }
          if (!container) {
            container = document.getElementById('vocab-chat-simplified-container');
          }
          
          if (container) {
            console.log('[ChatDialog] Updating UI with streaming data (Simplify more), accumulated text length:', eventData.accumulatedSimplifiedText?.length || 0);
            this.renderSimplifiedExplanations(container);
          } else {
            console.log('[ChatDialog] Container not found yet (Simplify more), will retry on next chunk');
          }
        }
        
        // Handle complete event (final data)
        // IMPORTANT: Check for type === 'complete' first to ensure we get possibleQuestions
        else if (eventData.type === 'complete') {
          console.log('[ChatDialog] ===== COMPLETE EVENT HANDLER TRIGGERED =====');
          console.log('[ChatDialog] Complete event - simplifiedText:', eventData.simplifiedText, 'shouldAllowSimplifyMore:', eventData.shouldAllowSimplifyMore);
          console.log('[ChatDialog] Complete event - possibleQuestions received:', eventData.possibleQuestions);
          console.log('[ChatDialog] Complete event - possibleQuestions type:', typeof eventData.possibleQuestions);
          console.log('[ChatDialog] Complete event - possibleQuestions is array:', Array.isArray(eventData.possibleQuestions));
          console.log('[ChatDialog] Complete event - possibleQuestions length:', eventData.possibleQuestions?.length || 0);
          console.log('[ChatDialog] Complete event - possibleQuestions value (stringified):', JSON.stringify(eventData.possibleQuestions));
          
          // Ensure possibleQuestions is an array and store directly in ChatDialog property (like pagePossibleQuestions)
          this.simplifiedPossibleQuestions = Array.isArray(eventData.possibleQuestions) 
            ? eventData.possibleQuestions 
            : (eventData.possibleQuestions ? [eventData.possibleQuestions] : []);
          
          console.log('[ChatDialog] Stored simplifiedPossibleQuestions:', this.simplifiedPossibleQuestions);
          console.log('[ChatDialog] Stored simplifiedPossibleQuestions length:', this.simplifiedPossibleQuestions.length);
          
          // Update simplified data with final text
          // previousSimplifiedTextsArray already includes all previous + the old current simplified text
          // The new simplifiedText becomes the new current
          
          // Get existing data to preserve explanationQuestions structure
          const originalTextKey = this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '');
          const existingData = TextSelector.simplifiedTexts.get(originalTextKey) || {};
          
          // Initialize explanationQuestions array if it doesn't exist
          // This array stores possibleQuestions for each explanation version
          // Index 0 = first explanation, Index 1 = second explanation, etc.
          let explanationQuestions = existingData.explanationQuestions || [];
          
          // Ensure explanationQuestions is an array
          if (!Array.isArray(explanationQuestions)) {
            explanationQuestions = [];
          }
          
          // Calculate the index for the new explanation
          // The new explanation index = number of previous explanations (including the old current one that was moved to previous)
          const newExplanationIndex = previousSimplifiedTexts.length;
          
          // Store possibleQuestions for this specific explanation version
          // Ensure it's an array
          const questionsForThisExplanation = Array.isArray(this.simplifiedPossibleQuestions) 
            ? this.simplifiedPossibleQuestions 
            : (this.simplifiedPossibleQuestions ? [this.simplifiedPossibleQuestions] : []);
          
          // Extend or update the explanationQuestions array
          // If the index doesn't exist yet, push to array
          // If it exists, update it (shouldn't happen, but handle it)
          if (newExplanationIndex >= explanationQuestions.length) {
            explanationQuestions.push(questionsForThisExplanation);
          } else {
            explanationQuestions[newExplanationIndex] = questionsForThisExplanation;
          }
          
          console.log('[ChatDialog] Storing questions for explanation index:', newExplanationIndex);
          console.log('[ChatDialog] explanationQuestions array length:', explanationQuestions.length);
          console.log('[ChatDialog] Questions for this explanation:', questionsForThisExplanation);
          
        // IMPORTANT: Prioritize eventData.simplifiedText from API complete event
        // The API always sends simplifiedText in the complete event, so use it if available
        // Fall back to this.simplifiedData.simplifiedText (which might have accumulatedSimplifiedText from streaming)
        const preservedSimplifiedText = eventData.simplifiedText || this.simplifiedData?.simplifiedText || '';
        const preservedText = eventData.text || this.simplifiedData?.text || '';
        const preservedTextStartIndex = eventData.textStartIndex !== undefined ? eventData.textStartIndex : (this.simplifiedData?.textStartIndex || 0);
        const preservedTextLength = eventData.textLength !== undefined ? eventData.textLength : (this.simplifiedData?.textLength || 0);
        
        this.simplifiedData = {
          textStartIndex: preservedTextStartIndex,
          textLength: preservedTextLength,
          text: preservedText,
          simplifiedText: preservedSimplifiedText,
            previousSimplifiedTexts: previousSimplifiedTexts, // Use the array we sent to API (includes all previous + old current)
          shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore !== undefined ? eventData.shouldAllowSimplifyMore : (this.simplifiedData?.shouldAllowSimplifyMore || false),
          explanationQuestions: explanationQuestions, // Store questions per explanation version
          possibleQuestions: this.simplifiedPossibleQuestions, // Keep for backward compatibility, but use explanationQuestions instead
          context: context || this.simplifiedData?.context // Store context for ask API (from closure)
        };
        
        console.log('[ChatDialog] Updated simplifiedData.possibleQuestions:', this.simplifiedData.possibleQuestions);
        console.log('[ChatDialog] Updated simplifiedData.possibleQuestions length:', this.simplifiedData.possibleQuestions.length);
        console.log('[ChatDialog] Updated simplifiedData.simplifiedText length:', this.simplifiedData.simplifiedText?.length || 0);
          
          console.log('[ChatDialog] Updated simplifiedData after complete event:', {
            previousSimplifiedTextsCount: previousSimplifiedTexts.length,
            newSimplifiedText: eventData.simplifiedText,
            previousSimplifiedTexts: previousSimplifiedTexts
          });
        
        // Update stored data with all key variations to ensure it can be found
        // Use original text key for storage (already defined above)
        TextSelector.simplifiedTexts.set(originalTextKey, this.simplifiedData);
        // Also store with key variations for compatibility
        TextSelector.simplifiedTexts.set(`${originalTextKey}-selected`, this.simplifiedData);
        TextSelector.simplifiedTexts.set(`${originalTextKey}-generic`, this.simplifiedData);
        
        console.log('[ChatDialog] Stored simplified data with key:', originalTextKey);
        console.log('[ChatDialog] Stored simplified data with key variations');
        
        console.log('[ChatDialog] Updated simplified data in TextSelector:', {
          textKey: originalTextKey,
          previousSimplifiedTextsCount: previousSimplifiedTextsArray.length,
          hasCurrentSimplifiedText: !!eventData.simplifiedText,
          shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore || false,
          possibleQuestionsCount: this.simplifiedData.possibleQuestions.length
        });
        
        // Verify the data was stored correctly
        const storedData = TextSelector.simplifiedTexts.get(originalTextKey);
        console.log('[ChatDialog] Verification - stored data.possibleQuestions:', storedData?.possibleQuestions);
        console.log('[ChatDialog] Verification - stored data.possibleQuestions length:', storedData?.possibleQuestions?.length || 0);
        
          // Update UI - re-render all explanations with final text
        const container = this.dialogContainer.querySelector('#vocab-chat-simplified-container');
        if (container) {
          console.log('[ChatDialog] About to call renderSimplifiedExplanations - this.simplifiedData.possibleQuestions:', this.simplifiedData.possibleQuestions);
          console.log('[ChatDialog] About to call renderSimplifiedExplanations - this.simplifiedData.possibleQuestions length:', this.simplifiedData.possibleQuestions.length);
          this.renderSimplifiedExplanations(container);
          console.log('[ChatDialog] After renderSimplifiedExplanations call');
        } else {
          console.log('[ChatDialog] Container not found for rendering questions');
        }
        
          // Reset button - always enable
        if (simplifyMoreBtn) {
          simplifyMoreBtn.classList.remove('loading');
          simplifyMoreBtn.textContent = 'Simplify more';
            simplifyMoreBtn.disabled = false;
            simplifyMoreBtn.classList.remove('disabled');
        }
        
        this.isSimplifying = false;
        }
        // Fallback: Handle events with simplifiedText but no type (backward compatibility)
        else if (eventData.simplifiedText && !eventData.chunk && eventData.type !== 'complete') {
          console.log('[ChatDialog] Fallback complete event (has simplifiedText but no type)');
          console.log('[ChatDialog] Fallback - possibleQuestions received:', eventData.possibleQuestions);
          
          // Ensure possibleQuestions is an array
          const possibleQuestionsArray = Array.isArray(eventData.possibleQuestions) 
            ? eventData.possibleQuestions 
            : (eventData.possibleQuestions ? [eventData.possibleQuestions] : []);
          
          // Get existing data to preserve explanationQuestions structure
          const originalTextKey = this.currentTextKey.replace(/-selected$/, '').replace(/-generic$/, '');
          const existingData = TextSelector.simplifiedTexts.get(originalTextKey) || {};
          
          // Initialize explanationQuestions array if it doesn't exist
          let explanationQuestions = existingData.explanationQuestions || [];
          if (!Array.isArray(explanationQuestions)) {
            explanationQuestions = [];
          }
          
          // For fallback, this is the first explanation (index 0)
          const explanationIndex = 0;
          if (explanationIndex >= explanationQuestions.length) {
            explanationQuestions.push(possibleQuestionsArray);
          } else {
            explanationQuestions[explanationIndex] = possibleQuestionsArray;
          }
          
          // Preserve existing data if eventData doesn't have it
          const preservedSimplifiedText = eventData.simplifiedText || this.simplifiedData?.simplifiedText || '';
          const preservedText = eventData.text || this.simplifiedData?.text || '';
          const preservedTextStartIndex = eventData.textStartIndex !== undefined ? eventData.textStartIndex : (this.simplifiedData?.textStartIndex || 0);
          const preservedTextLength = eventData.textLength !== undefined ? eventData.textLength : (this.simplifiedData?.textLength || 0);
          
          // Update simplified data
          this.simplifiedData = {
            textStartIndex: preservedTextStartIndex,
            textLength: preservedTextLength,
            text: preservedText,
            simplifiedText: preservedSimplifiedText,
            previousSimplifiedTexts: previousSimplifiedTexts || this.simplifiedData?.previousSimplifiedTexts || [],
            shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore !== undefined ? eventData.shouldAllowSimplifyMore : (this.simplifiedData?.shouldAllowSimplifyMore || false),
            explanationQuestions: explanationQuestions,
            possibleQuestions: possibleQuestionsArray, // Keep for backward compatibility
            context: this.simplifiedData?.context // Preserve context
          };
          
          // Update stored data
          TextSelector.simplifiedTexts.set(originalTextKey, this.simplifiedData);
          
          // Re-render
          const container = this.dialogContainer.querySelector('#vocab-chat-simplified-container');
          if (container) {
            this.renderSimplifiedExplanations(container);
          }
        }
      },
      // onComplete callback
      () => {
        console.log('[ChatDialog] Simplification complete');
        this.isSimplifying = false;
      },
      // onError callback
      async (error) => {
        console.error('[ChatDialog] Error during simplification:', error);
        
        // Check if it's a 429 rate limit error
        const isRateLimit = error.status === 429 || 
                           error.message.includes('429') || 
                           error.message.includes('Rate limit') ||
                           error.message.includes('too fast');
        
        if (isRateLimit && typeof ErrorBanner !== 'undefined') {
          await ErrorBanner.show('You are requesting too fast, please retry after few seconds');
        }
        
        // Reset button
        if (simplifyMoreBtn) {
          simplifyMoreBtn.classList.remove('loading');
          simplifyMoreBtn.textContent = 'Simplify more';
        }
        
        this.isSimplifying = false;
        
        // Show error
        TextSelector.showNotification('Error simplifying text. Please try again.');
      }
    );
  },
  
  /**
   * Handle "Summarise the page" button click
   */
  async handleSummarisePage() {
    console.log('[ChatDialog] ===== handleSummarisePage CALLED =====');
    
    // Get pageTextContent from global variable
    const pageTextContent = window.pageTextContent;
    console.log('[ChatDialog] pageTextContent from window:', pageTextContent ? 'exists' : 'null/undefined');
    
    if (!pageTextContent) {
      console.warn('[ChatDialog] pageTextContent is not available');
      this.addMessageToChat('ai', '⚠️ Page content is not yet loaded. Please wait a moment and try again.');
      return;
    }
    
    console.log('[ChatDialog] pageTextContent is available, length:', pageTextContent.length);
    
    // Get the button
    const summariseBtn = document.getElementById('vocab-chat-summarise-page-btn');
    if (!summariseBtn) {
      console.warn('[ChatDialog] Summarise button not found');
      return;
    }
    
    // Store original content (with icon)
    const originalContent = summariseBtn.innerHTML;
    
    // Hide the original button and create a separate stop button above summary container
    summariseBtn.style.display = 'none';
    
    // Store abort function reference
    let abortFunction = null;
    
    // Create stop button above summary container
    let stopButton = document.getElementById('vocab-chat-stop-summarise-btn');
    if (!stopButton) {
      stopButton = document.createElement('button');
      stopButton.id = 'vocab-chat-stop-summarise-btn';
      stopButton.className = 'vocab-chat-stop-summarise-btn';
      stopButton.innerHTML = 'Stop';
      stopButton.style.display = 'block';
    } else {
      stopButton.style.display = 'block';
    }
    
    // Add click handler for Stop button
    const stopHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      console.log('[ChatDialog] Stop button clicked - cancelling summarise request');
      
      // Cancel the API call
      if (abortFunction) {
        abortFunction();
        abortFunction = null;
      }
      
      // Hide stop button
      const stopBtn = document.getElementById('vocab-chat-stop-summarise-btn');
      if (stopBtn) {
        stopBtn.style.display = 'none';
      }
      
      // Get the original summarise button and show it
      const currentBtn = document.getElementById('vocab-chat-summarise-page-btn');
      if (!currentBtn) return;
      
      // Check if we have accumulated summary to save
      if (this.pageSummary && this.pageSummary.trim().length > 0) {
        // Save accumulated summary to global variables
        window.pageSummary = this.pageSummary;
        window.pageSummaryPossibleQuestions = this.pagePossibleQuestions || [];
        console.log('[ChatDialog] Saved accumulated summary to memory:', this.pageSummary.length, 'characters');
        
        // Update summary container if it exists to show the accumulated summary
        const summaryContainer = document.getElementById('vocab-chat-page-summary-container');
        if (summaryContainer) {
          summaryContainer.innerHTML = `
            <h3 class="vocab-chat-page-summary-header">Page summary</h3>
            <div class="vocab-chat-page-summary-content">
              ${this.renderMarkdown(this.pageSummary)}
            </div>
          `;
          
          // Attach click handlers to reference markers in summary
          const summaryContent = summaryContainer.querySelector('.vocab-chat-page-summary-content');
          if (summaryContent) {
            this.attachReferenceMarkerHandlers(summaryContent);
          }
        }
        
        // Change button to "Clear summary"
        currentBtn.disabled = false;
        currentBtn.classList.remove('disabled', 'loading');
        currentBtn.innerHTML = 'Clear summary';
        currentBtn.style.display = 'block';
        
        // Update click handler to clear summary
        currentBtn.replaceWith(currentBtn.cloneNode(true));
        const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
        if (newBtn) {
          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('[ChatDialog] Clear summary button clicked!');
            this.clearSummary();
          }, true);
        }
      } else {
        // No accumulated summary, reset to original state
        // Remove typing indicator if it exists
        const summaryContainer = document.getElementById('vocab-chat-page-summary-container');
        if (summaryContainer) {
          summaryContainer.innerHTML = '';
        }
        
        currentBtn.disabled = false;
        currentBtn.classList.remove('disabled', 'loading');
        currentBtn.innerHTML = originalContent;
        currentBtn.style.display = 'block';
        
        // Update click handler back to handleSummarisePage
        currentBtn.replaceWith(currentBtn.cloneNode(true));
        const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
        if (newBtn) {
          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('[ChatDialog] Summarise button clicked!');
            this.handleSummarisePage();
          }, true);
        }
      }
    };
    
    // Add click handler to stop button
    stopButton.replaceWith(stopButton.cloneNode(true));
    const stopBtn = document.getElementById('vocab-chat-stop-summarise-btn');
    if (stopBtn) {
      stopBtn.addEventListener('click', stopHandler, true);
    }
    
    try {
      // Parse pageTextContent to get the text
      const contentData = JSON.parse(pageTextContent);
      let pageText = contentData.text || '';
      
      if (!pageText) {
        throw new Error('No text content available');
      }
      
      // Limit text length to avoid API errors (use first 50000 characters for summarisation)
      // The API might have limits on text length
      const MAX_TEXT_LENGTH = 50000;
      if (pageText.length > MAX_TEXT_LENGTH) {
        console.log('[ChatDialog] Page text is too long, truncating to', MAX_TEXT_LENGTH, 'characters');
        pageText = pageText.substring(0, MAX_TEXT_LENGTH);
      }
      
      console.log('[ChatDialog] Calling summarise API for page summarisation...');
      console.log('[ChatDialog] Text length:', pageText.length, 'text preview:', pageText.substring(0, 100) + '...');
      console.log('[ChatDialog] ApiService available:', typeof ApiService !== 'undefined');
      
      // Call ApiService with SSE
      try {
        // Initialize streaming summary and questions
        this.pageSummary = '';
        this.pagePossibleQuestions = [];
        let summaryContainer = null;
        let summaryShown = false;
        
        // Create or get summary container for streaming
        const buttonContainer = document.querySelector('.vocab-chat-simplify-more-container');
        if (buttonContainer) {
          summaryContainer = document.getElementById('vocab-chat-page-summary-container');
          if (!summaryContainer) {
            summaryContainer = document.createElement('div');
            summaryContainer.id = 'vocab-chat-page-summary-container';
            summaryContainer.className = 'vocab-chat-page-summary-container';
            buttonContainer.parentNode.insertBefore(summaryContainer, buttonContainer);
          }
          
          // Insert stop button above summary container if it doesn't exist
          let stopBtn = document.getElementById('vocab-chat-stop-summarise-btn');
          if (!stopBtn) {
            stopBtn = document.createElement('button');
            stopBtn.id = 'vocab-chat-stop-summarise-btn';
            stopBtn.className = 'vocab-chat-stop-summarise-btn';
            stopBtn.innerHTML = 'Stop';
            stopBtn.style.display = 'block';
            summaryContainer.parentNode.insertBefore(stopBtn, summaryContainer);
          } else {
            // Move stop button above summary container if it exists elsewhere
            if (stopBtn.parentNode !== summaryContainer.parentNode || stopBtn.nextSibling !== summaryContainer) {
              summaryContainer.parentNode.insertBefore(stopBtn, summaryContainer);
            }
            stopBtn.style.display = 'block';
          }
        }
        
        // Show 3-dot typing indicator while waiting for first event
        if (summaryContainer) {
          summaryContainer.innerHTML = `
            <div class="vocab-chat-typing-indicator">
              <span class="vocab-chat-typing-dot"></span>
              <span class="vocab-chat-typing-dot"></span>
              <span class="vocab-chat-typing-dot"></span>
            </div>
          `;
        }
        
        // Call ApiService with SSE callbacks
        abortFunction = await ApiService.summarise(
          pageText,
          // onEvent callback - handle chunk and complete events
          (eventData) => {
            console.log('[ChatDialog] Received summarise event:', eventData);
            
            // Handle chunk events (streaming)
            if (eventData.chunk !== undefined) {
              console.log('[ChatDialog] Chunk event - chunk:', eventData.chunk, 'accumulated length:', eventData.accumulated?.length || 0);
              
              // Update accumulated summary
              if (eventData.accumulated) {
                this.pageSummary = eventData.accumulated;
                
                // Store accumulated summary in global variable during streaming
                window.pageSummary = eventData.accumulated;
                
                // Show summary container on first chunk (remove spinner)
                if (summaryContainer && !summaryShown) {
                  summaryShown = true;
                  console.log('[ChatDialog] Showing summary container on first chunk');
                }
                
                // Update summary UI in real-time (spinner will be replaced by content)
                if (summaryContainer) {
                  summaryContainer.innerHTML = `
                    <h3 class="vocab-chat-page-summary-header">Page summary</h3>
                    <div class="vocab-chat-page-summary-content">
                      ${this.renderMarkdown(this.pageSummary)}
                    </div>
                  `;
                  
                  // Attach click handlers to reference markers in summary
                  const summaryContent = summaryContainer.querySelector('.vocab-chat-page-summary-content');
                  if (summaryContent) {
                    this.attachReferenceMarkerHandlers(summaryContent);
                  }
                  
                  // Auto-scroll to bottom as content is being added
                  // Find the scrollable content container - try multiple methods
                  let scrollableContent = summaryContainer.closest('.vocab-chat-scrollable-content');
                  
                  // If not found via closest, try finding it from the parent
                  if (!scrollableContent) {
                    let parent = summaryContainer.parentElement;
                    while (parent && !scrollableContent) {
                      if (parent.classList && parent.classList.contains('vocab-chat-scrollable-content')) {
                        scrollableContent = parent;
                        break;
                      }
                      parent = parent.parentElement;
                    }
                  }
                  
                  // If still not found, try querying from the dialog container
                  if (!scrollableContent && this.dialogContainer) {
                    scrollableContent = this.dialogContainer.querySelector('.vocab-chat-scrollable-content');
                  }
                  
                  if (scrollableContent) {
                    // Only auto-scroll if user is already at or near the bottom
                    // This prevents forcing scroll when user has manually scrolled up
                    this.scrollScrollableContent(scrollableContent, true, true);
                  } else {
                    console.warn('[ChatDialog] Could not find scrollable content container for auto-scroll');
                  }
                }
              }
            }
            
            // Handle complete event (final summary)
            else if (eventData.type === 'complete' && eventData.summary) {
              console.log('[ChatDialog] Complete event - summary length:', eventData.summary.length);
              console.log('[ChatDialog] Possible questions:', eventData.possibleQuestions?.length || 0);
              
              // Store final summary and possible questions in instance variables
              this.pageSummary = eventData.summary;
              this.pagePossibleQuestions = eventData.possibleQuestions || [];
              
              // Store in global variables for persistence across dialog open/close
              window.pageSummary = eventData.summary;
              window.pageSummaryPossibleQuestions = eventData.possibleQuestions || [];
              console.log('[ChatDialog] Stored summary in global variables');
              
              // Update summary UI with final data including questions
              if (summaryContainer) {
                this.renderPageSummaryWithQuestions(summaryContainer);
              }
              
              // Hide stop button after completion
              const stopBtnAfterComplete = document.getElementById('vocab-chat-stop-summarise-btn');
              if (stopBtnAfterComplete) {
                stopBtnAfterComplete.style.display = 'none';
              }
              
              // Change button to "Clear summary" after completion
              const summariseBtnAfterComplete = document.getElementById('vocab-chat-summarise-page-btn');
              if (summariseBtnAfterComplete) {
                // Clear abort function reference
                abortFunction = null;
                
                summariseBtnAfterComplete.disabled = false;
                summariseBtnAfterComplete.classList.remove('loading', 'disabled');
                summariseBtnAfterComplete.innerHTML = 'Clear summary';
                summariseBtnAfterComplete.style.display = 'block';
                
                // Update click handler to clear summary
                summariseBtnAfterComplete.replaceWith(summariseBtnAfterComplete.cloneNode(true));
                const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
                if (newBtn) {
                  newBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('[ChatDialog] Clear summary button clicked!');
                    this.clearSummary();
                  }, true);
                }
                
                console.log('[ChatDialog] Button changed to "Clear summary" after completion');
              }
            }
          },
          // onComplete callback
          () => {
            console.log('[ChatDialog] Summarise stream complete');
            // Clear abort function reference on completion
            abortFunction = null;
          },
          // onError callback
          (error) => {
            // Check if it's an abort error (user cancelled)
            if (error.name === 'AbortError' || error.message.includes('aborted')) {
              console.log('[ChatDialog] Summarise request was aborted by user');
              // Don't show error message for user-initiated cancellation
              // The stop handler already handles button state and saving accumulated summary
              // Remove typing indicator if no accumulated summary (stop handler will handle if there is summary)
              if (!this.pageSummary || this.pageSummary.trim().length === 0) {
                if (summaryContainer) {
                  summaryContainer.innerHTML = '';
                }
              }
              abortFunction = null;
              return;
            }
            
            console.error('[ChatDialog] Error during summarisation:', error);
            console.error('[ChatDialog] Error details:', {
              message: error.message,
              name: error.name,
              stack: error.stack
            });
            
            // Check if it's a LOGIN_REQUIRED error - don't show error message in chat container
            if (error.errorCode === 'LOGIN_REQUIRED') {
              console.log('[ChatDialog] LOGIN_REQUIRED error detected, skipping chat message (login modal will be shown via event)');
              // Still need to reset button and clear abort function
              abortFunction = null;
              
              // Remove spinner if it exists
              if (summaryContainer) {
                summaryContainer.innerHTML = '';
              }
              
              // Hide stop button
              const stopBtnOnError = document.getElementById('vocab-chat-stop-summarise-btn');
              if (stopBtnOnError) {
                stopBtnOnError.style.display = 'none';
              }
              
              // Reset button
              const summariseBtnOnError = document.getElementById('vocab-chat-summarise-page-btn');
              if (summariseBtnOnError) {
                summariseBtnOnError.disabled = false;
                summariseBtnOnError.classList.remove('disabled', 'loading');
                summariseBtnOnError.innerHTML = originalContent;
                summariseBtnOnError.style.display = 'block';
                
                // Update click handler back to handleSummarisePage
                summariseBtnOnError.replaceWith(summariseBtnOnError.cloneNode(true));
                const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
                if (newBtn) {
                  newBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('[ChatDialog] Summarise button clicked!');
                    this.handleSummarisePage();
                  }, true);
                }
              }
              return;
            }
            
            // Check if it's a 429 rate limit error
            const isRateLimit = error.status === 429 || 
                               error.message.includes('429') || 
                               error.message.includes('Rate limit') ||
                               error.message.includes('too fast');
            
            if (isRateLimit && typeof ErrorBanner !== 'undefined') {
              ErrorBanner.show('You are requesting too fast, please retry after few seconds');
            }
            
            // Show error message in chat with more details
            const errorMessage = error.message || 'Please try again.';
            this.addMessageToChat('ai', `⚠️ **Error:**\n\nFailed to summarise the page. ${errorMessage}`);
            
            // Clear abort function reference
            abortFunction = null;
            
            // Hide stop button
            const stopBtnOnError = document.getElementById('vocab-chat-stop-summarise-btn');
            if (stopBtnOnError) {
              stopBtnOnError.style.display = 'none';
            }
            
            // Reset button
            const summariseBtnOnError = document.getElementById('vocab-chat-summarise-page-btn');
            if (summariseBtnOnError) {
              summariseBtnOnError.disabled = false;
              summariseBtnOnError.classList.remove('disabled', 'loading');
              summariseBtnOnError.innerHTML = originalContent;
              summariseBtnOnError.style.display = 'block';
              
              // Update click handler back to handleSummarisePage
              summariseBtnOnError.replaceWith(summariseBtnOnError.cloneNode(true));
              const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
              if (newBtn) {
                newBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();
                  console.log('[ChatDialog] Summarise button clicked!');
                  this.handleSummarisePage();
                }, true);
              }
            }
          }
        );
      } catch (error) {
        console.error('[ChatDialog] Error during summarisation:', error);
        console.error('[ChatDialog] Error details:', {
          message: error.message,
          name: error.name,
          stack: error.stack
        });
        
        // Check if it's a 429 rate limit error
        const isRateLimit = error.status === 429 || 
                           error.message.includes('429') || 
                           error.message.includes('Rate limit') ||
                           error.message.includes('too fast');
        
        if (isRateLimit && typeof ErrorBanner !== 'undefined') {
          await ErrorBanner.show('You are requesting too fast, please retry after few seconds');
        }
        
        // Show error message in chat with more details
        const errorMessage = error.message || 'Please try again.';
        this.addMessageToChat('ai', `⚠️ **Error:**\n\nFailed to summarise the page. ${errorMessage}`);
        
        // Clear abort function reference
        abortFunction = null;
        
        // Hide stop button
        const stopBtnOnCatchError = document.getElementById('vocab-chat-stop-summarise-btn');
        if (stopBtnOnCatchError) {
          stopBtnOnCatchError.style.display = 'none';
        }
        
        // Reset button
        const summariseBtnOnCatchError = document.getElementById('vocab-chat-summarise-page-btn');
        if (summariseBtnOnCatchError) {
          summariseBtnOnCatchError.disabled = false;
          summariseBtnOnCatchError.classList.remove('disabled', 'loading');
          summariseBtnOnCatchError.innerHTML = originalContent;
          summariseBtnOnCatchError.style.display = 'block';
          
          // Update click handler back to handleSummarisePage
          summariseBtnOnCatchError.replaceWith(summariseBtnOnCatchError.cloneNode(true));
          const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
          if (newBtn) {
            newBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              console.log('[ChatDialog] Summarise button clicked!');
              this.handleSummarisePage();
            }, true);
          }
        }
      }
    } catch (error) {
      console.error('[ChatDialog] Error parsing pageTextContent:', error);
      
      // Clear abort function reference
      abortFunction = null;
      
      // Hide stop button
      const stopBtnOnParseError = document.getElementById('vocab-chat-stop-summarise-btn');
      if (stopBtnOnParseError) {
        stopBtnOnParseError.style.display = 'none';
      }
      
      // Show error message in chat
      this.addMessageToChat('ai', `⚠️ **Error:**\n\nFailed to parse page content. ${error.message || 'Please try again.'}`);
      
      // Reset button
      const summariseBtnOnParseError = document.getElementById('vocab-chat-summarise-page-btn');
      if (summariseBtnOnParseError) {
        summariseBtnOnParseError.disabled = false;
        summariseBtnOnParseError.classList.remove('disabled', 'loading');
        summariseBtnOnParseError.innerHTML = originalContent;
        summariseBtnOnParseError.style.display = 'block';
        
        // Update click handler back to handleSummarisePage
        summariseBtnOnParseError.replaceWith(summariseBtnOnParseError.cloneNode(true));
        const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
        if (newBtn) {
          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('[ChatDialog] Summarise button clicked!');
            this.handleSummarisePage();
          }, true);
        }
      }
    }
  },
  
  /**
   * Render page summary above the "Summarise the page" button
   * This is separate from chat history
   */
  renderPageSummary() {
    if (!this.pageSummary) {
      return;
    }
    
    // Find or create summary container
    let summaryContainer = document.getElementById('vocab-chat-page-summary-container');
    if (!summaryContainer) {
      // Find the button container to insert summary above it
      const buttonContainer = document.querySelector('.vocab-chat-simplify-more-container');
      if (!buttonContainer) {
        console.warn('[ChatDialog] Button container not found, cannot render summary');
        return;
      }
      
      // Create summary container
      summaryContainer = document.createElement('div');
      summaryContainer.id = 'vocab-chat-page-summary-container';
      summaryContainer.className = 'vocab-chat-page-summary-container';
      
      // Insert before button container
      buttonContainer.parentNode.insertBefore(summaryContainer, buttonContainer);
    }
    
    // Render summary with questions
    this.renderPageSummaryWithQuestions(summaryContainer);
    
    console.log('[ChatDialog] Page summary rendered above button');
  },
  
  /**
   * Render page summary with possible questions
   * @param {HTMLElement} summaryContainer - The container element to render into
   */
  renderPageSummaryWithQuestions(summaryContainer) {
    if (!this.pageSummary) {
      return;
    }
    
    // Build questions HTML if they exist
    let questionsHTML = '';
    if (this.pagePossibleQuestions && this.pagePossibleQuestions.length > 0) {
      const validQuestions = this.pagePossibleQuestions.filter(q => q && q.trim() !== '');
      if (validQuestions.length > 0) {
        questionsHTML = `
          <div class="vocab-chat-page-questions-container">
            <h4 class="vocab-chat-page-questions-header">Would you like to know ?</h4>
            <div class="vocab-chat-page-questions-list">
              ${validQuestions.map((question, index) => `
                <div class="vocab-chat-page-question-item" data-question="${this.escapeHtml(question)}">
                  <span class="vocab-chat-page-question-icon">+</span>
                  <span>${this.escapeHtml(question)}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }
    }
    
    // Render summary content with questions
    summaryContainer.innerHTML = `
      <h3 class="vocab-chat-page-summary-header">Page summary</h3>
      <div class="vocab-chat-page-summary-content">
        ${this.renderMarkdown(this.pageSummary)}
      </div>
      ${questionsHTML}
    `;
    
    // Add click handlers to question items
    const questionItems = summaryContainer.querySelectorAll('.vocab-chat-page-question-item');
    questionItems.forEach(item => {
      item.addEventListener('click', () => {
        const question = item.getAttribute('data-question');
        console.log('[ChatDialog] Question clicked:', question);
        this.askQuestion(question);
      });
    });
    
    // Attach reference marker handlers to the summary content
    const summaryContent = summaryContainer.querySelector('.vocab-chat-page-summary-content');
    if (summaryContent) {
      console.log('[ChatDialog] Attaching reference handlers to summary content in renderPageSummaryWithQuestions');
      this.attachReferenceMarkerHandlers(summaryContent);
    } else {
      console.warn('[ChatDialog] Summary content not found in renderPageSummaryWithQuestions');
    }
    
    // Trigger animation by forcing a reflow for questions container
    const questionsContainer = summaryContainer.querySelector('.vocab-chat-page-questions-container');
    if (questionsContainer) {
      void questionsContainer.offsetHeight;
    }
    
    console.log('[ChatDialog] Page summary with questions rendered');
  },
  
  /**
   * Render possible questions below a chat message
   * @param {Array<string>} possibleQuestions - Array of question strings
   * @returns {HTMLElement|null} The questions container element or null if no valid questions
   */
  renderMessageQuestions(possibleQuestions) {
    console.log('[ChatDialog] renderMessageQuestions called with:', possibleQuestions);
    console.log('[ChatDialog] renderMessageQuestions type:', typeof possibleQuestions);
    console.log('[ChatDialog] renderMessageQuestions is array:', Array.isArray(possibleQuestions));
    
    if (!possibleQuestions || possibleQuestions.length === 0) {
      console.log('[ChatDialog] renderMessageQuestions: No questions or empty array, returning null');
      return null;
    }
    
    const validQuestions = possibleQuestions.filter(q => q && q.trim() !== '');
    console.log('[ChatDialog] renderMessageQuestions: Valid questions after filtering:', validQuestions);
    if (validQuestions.length === 0) {
      console.log('[ChatDialog] renderMessageQuestions: No valid questions after filtering, returning null');
      return null;
    }
    
    // Create questions container
    const questionsContainer = document.createElement('div');
    questionsContainer.className = 'vocab-chat-message-questions-container';
    
    // Build questions HTML
    const questionsHTML = `
      <h4 class="vocab-chat-message-questions-header">You might be interested on:</h4>
      <div class="vocab-chat-message-questions-list">
        ${validQuestions.map((question, index) => `
          <div class="vocab-chat-message-question-item" data-question="${this.escapeHtml(question)}">
            <span class="vocab-chat-message-question-icon">+</span>
            <span>${this.escapeHtml(question)}</span>
          </div>
        `).join('')}
      </div>
    `;
    
    questionsContainer.innerHTML = questionsHTML;
    
    // Add click handlers to question items
    const questionItems = questionsContainer.querySelectorAll('.vocab-chat-message-question-item');
    questionItems.forEach(item => {
      item.addEventListener('click', () => {
        const question = item.getAttribute('data-question');
        console.log('[ChatDialog] Message question clicked:', question);
        this.askQuestion(question);
      });
    });
    
    // Trigger animation by forcing a reflow
    void questionsContainer.offsetHeight;
    
    // Scroll to bottom after questions are rendered to ensure they're visible
    const chatContainer = document.getElementById('vocab-chat-messages');
    if (chatContainer) {
      // Use setTimeout to ensure DOM is fully updated before scrolling
      setTimeout(() => {
        this.scrollToBottom(chatContainer, false);
      }, 50);
    }
    
    return questionsContainer;
  },
  
  /**
   * Escape HTML to prevent XSS
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  },
  
  /**
   * Ask a question by setting it in the input and sending it
   * @param {string} question - The question to ask
   */
  askQuestion(question) {
    if (!question || question.trim() === '') {
      return;
    }
    
    // Find the input field
    const inputField = document.getElementById('vocab-chat-input');
    if (!inputField) {
      console.warn('[ChatDialog] Input field not found');
      return;
    }
    
    // Set the question in the input field
    inputField.value = question.trim();
    
    // Trigger input event to ensure UI updates
    inputField.dispatchEvent(new Event('input', { bubbles: true }));
    
    // Focus the input
    inputField.focus();
    
    // Send the message
    setTimeout(() => {
      this.sendMessage();
    }, 100);
    
    console.log('[ChatDialog] Question set in input and sent:', question);
  },
  
  /**
   * Clear the page summary and reset the button
   */
  clearSummary() {
    console.log('[ChatDialog] Clearing page summary and questions');
    
    // Clear the summary data and questions in instance variables
    this.pageSummary = '';
    this.pagePossibleQuestions = [];
    this.simplifiedPossibleQuestions = []; // Also clear simplified questions
    
    // Clear global variables
    window.pageSummary = null;
    window.pageSummaryPossibleQuestions = null;
    console.log('[ChatDialog] Summary and questions data cleared (both instance and global)');
    
    // Remove summary container (which includes questions)
    const summaryContainer = document.getElementById('vocab-chat-page-summary-container');
    if (summaryContainer) {
      summaryContainer.remove();
      console.log('[ChatDialog] Summary container (including questions) removed');
    }
    
    // Reset button to "Summarise the page"
    const summariseBtn = document.getElementById('vocab-chat-summarise-page-btn');
    if (summariseBtn) {
      summariseBtn.disabled = false;
      summariseBtn.classList.remove('disabled', 'loading');
      summariseBtn.innerHTML = `${this.createSparkleIcon()} Summarise this page`;
      summariseBtn.style.display = 'block';
      
      // Update click handler back to handleSummarisePage
      summariseBtn.replaceWith(summariseBtn.cloneNode(true));
      const newBtn = document.getElementById('vocab-chat-summarise-page-btn');
      newBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        console.log('[ChatDialog] Summarise button clicked!');
        this.handleSummarisePage();
      }, true);
      
      console.log('[ChatDialog] Button reset to "Summarise the page"');
    }
  },
  
  /**
   * Create ask/chat content
   */
  createAskContent() {
    const content = document.createElement('div');
    content.className = this.mode === 'simplified' ? 'vocab-chat-tab-content' : 'vocab-chat-tab-content active';
    content.setAttribute('data-content', 'ask');
    
    if (this.mode === 'simplified') {
      content.style.display = 'none';
    }
    
    // Create summary container (above button) for ask-about-page chat
    if (this.chatContext === 'general' && this.currentTextKey && this.currentTextKey.startsWith('page-general')) {
      // Check global variables first
      const hasGlobalSummary = window.pageSummary !== null && window.pageSummaryPossibleQuestions !== null;
      
      // Only create and render summary container if global variables are not null
      if (hasGlobalSummary) {
        const summaryContainer = document.createElement('div');
        summaryContainer.id = 'vocab-chat-page-summary-container';
        summaryContainer.className = 'vocab-chat-page-summary-container';
        
        // Load from global variables to instance variables if needed
        if (!this.pageSummary) {
          this.pageSummary = window.pageSummary;
          this.pagePossibleQuestions = window.pageSummaryPossibleQuestions;
        }
        
        // Render summary if it exists
        if (this.pageSummary) {
          this.renderPageSummaryWithQuestions(summaryContainer);
        }
        
        content.appendChild(summaryContainer);
      }
    }
    
    // Create "Summarise the page" button container for ask-about-page chat
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'vocab-chat-simplify-more-container';
    
    // Show "Summarise the page" button for ask-about-page chat (page-general)
    // Check for both 'page-general' and 'page-general-generic' (the transformed key)
    if (this.chatContext === 'general' && this.currentTextKey && this.currentTextKey.startsWith('page-general')) {
      // Check global variables first
      const hasGlobalSummary = window.pageSummary !== null && window.pageSummaryPossibleQuestions !== null;
      
      console.log('[ChatDialog] Adding Summarise the page button to ask content');
      const summariseBtn = document.createElement('button');
      summariseBtn.className = 'vocab-chat-simplify-more-btn';
      summariseBtn.innerHTML = `${this.createSparkleIcon()} Summarise this page`;
      summariseBtn.id = 'vocab-chat-summarise-page-btn';
      
      // If global summary exists, show "Clear summary" button
      if (hasGlobalSummary) {
        // Load from global variables to instance variables if needed
        if (!this.pageSummary) {
          this.pageSummary = window.pageSummary;
          this.pagePossibleQuestions = window.pageSummaryPossibleQuestions;
        }
        
        summariseBtn.innerHTML = 'Clear summary';
        summariseBtn.disabled = false;
        summariseBtn.classList.remove('disabled');
        console.log('[ChatDialog] Global summary exists - showing "Clear summary" button');
        
        // Add onclick handler to clear summary
        summariseBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          console.log('[ChatDialog] Clear summary button clicked!');
          this.clearSummary();
        }, true); // Use capture phase
      } else {
      // Add onclick handler to call summarise API
      summariseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        console.log('[ChatDialog] Summarise button clicked!');
        this.handleSummarisePage();
      }, true); // Use capture phase
      }
      
      buttonContainer.appendChild(summariseBtn);
      content.appendChild(buttonContainer);
    }
    
    // Create chat messages container
    const chatContainer = document.createElement('div');
    chatContainer.className = 'vocab-chat-messages';
    chatContainer.id = 'vocab-chat-messages';
    
    // If we have existing chat history, render it
    if (this.chatHistory && this.chatHistory.length > 0) {
      this.chatHistory.forEach(item => {
        this.renderChatMessage(chatContainer, item.type, item.message, item.possibleQuestions || []);
      });
      
      // Update delete button visibility and scroll to bottom after rendering
      setTimeout(() => {
        this.updateGlobalClearButton();
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }, 10);
    } else {
      // Show appropriate message based on chat context
      const promptText = this.chatContext === 'selected' 
        ? 'Ask anything on the selected content' 
        : 'Ask anything about the page';
      
      const noChatsMsg = document.createElement('div');
      noChatsMsg.className = 'vocab-chat-no-messages';
      noChatsMsg.innerHTML = `
        <div class="vocab-chat-no-messages-content">
          ${this.createChatEmptyIcon()}
          <span>${promptText}</span>
        </div>
      `;
      chatContainer.appendChild(noChatsMsg);
    }
    
    content.appendChild(chatContainer);
    
    return content;
  },
  
  /**
   * Re-render all chat messages in the existing container
   */
  renderChatMessages() {
    console.log('[ChatDialog] Re-rendering chat messages, chatHistory length:', this.chatHistory.length);
    
    const chatContainer = document.getElementById('vocab-chat-messages');
    if (!chatContainer) {
      console.log('[ChatDialog] Chat container not found, cannot re-render messages');
      return;
    }
    
    // Clear existing messages
    chatContainer.innerHTML = '';
    
    // If we have existing chat history, render it
    if (this.chatHistory && this.chatHistory.length > 0) {
      this.chatHistory.forEach(item => {
        this.renderChatMessage(chatContainer, item.type, item.message, item.possibleQuestions || []);
      });
      
      // Update delete button visibility and scroll to bottom after rendering
      setTimeout(() => {
        this.updateGlobalClearButton();
        this.scrollToBottom(chatContainer);
      }, 10);
    } else {
      // Show appropriate message based on chat context
      const promptText = this.chatContext === 'selected' 
        ? 'Ask anything on the selected content' 
        : 'Ask anything about the page';
      
      const noChatsMsg = document.createElement('div');
      noChatsMsg.className = 'vocab-chat-no-messages';
      noChatsMsg.innerHTML = `
        <div class="vocab-chat-no-messages-content">
          ${this.createChatEmptyIcon()}
          <span>${promptText}</span>
        </div>
      `;
      chatContainer.appendChild(noChatsMsg);
    }
    
    console.log('[ChatDialog] Chat messages re-rendered successfully');
  },
  
  /**
   * Render a chat message in the container
   * @param {HTMLElement} container - Container element
   * @param {string} type - Message type ('user' or 'assistant')
   * @param {string} message - Message content
   */
  renderChatMessage(container, type, message, possibleQuestions = []) {
    // Create message bubble with correct class names
    const messageBubble = document.createElement('div');
    messageBubble.className = `vocab-chat-message vocab-chat-message-${type}`;
    
    const messageContent = document.createElement('div');
    messageContent.className = 'vocab-chat-message-content';
    
    // For AI messages, render markdown; for user messages, use textContent
    if (type === 'ai') {
      messageContent.innerHTML = this.renderMarkdown(message);
    } else {
      messageContent.textContent = message;
    }
    
    messageBubble.appendChild(messageContent);
    
    // Add questions below AI messages if they exist
    if (type === 'ai' && possibleQuestions && possibleQuestions.length > 0) {
      const questionsContainer = this.renderMessageQuestions(possibleQuestions);
      if (questionsContainer) {
        messageBubble.appendChild(questionsContainer);
      }
    }
    
    container.appendChild(messageBubble);
  },
  
  /**
   * Create input area
   */
  createInputArea() {
    console.log('[ChatDialog] ===== CREATE INPUT AREA FUNCTION CALLED =====');
    const inputArea = document.createElement('div');
    inputArea.className = 'vocab-chat-input-area';
    
    const inputField = document.createElement('textarea');
    inputField.className = 'vocab-chat-input';
    inputField.id = 'vocab-chat-input';
    // Set placeholder based on chat context
    // If opened from ask-about-page button (general context with page-general textKey), show "Ask AI anything about the page"
    // Otherwise, show the default placeholder for selected text
    if (this.chatContext === 'general' && this.currentTextKey && 
        (this.currentTextKey === 'page-general' || this.currentTextKey.startsWith('page-general'))) {
      inputField.placeholder = 'Ask AI anything about the page';
    } else {
      inputField.placeholder = 'Ask AI about the selected content';
    }
    inputField.rows = 1;
    
    // Apply inline styles as a fallback to ensure visibility even if CSS is overridden
    // Inline styles have the highest specificity and will override most site CSS
    inputField.style.color = '#1f2937';
    inputField.style.caretColor = '#9527F5';
    inputField.style.backgroundColor = 'white';
    
    console.log('[ChatDialog] Input field created with ID:', inputField.id);
    
    // Reapply visibility styles if they get removed (safeguard against site JavaScript)
    const ensureVisibility = () => {
      inputField.style.color = '#1f2937';
      inputField.style.caretColor = '#9527F5';
      inputField.style.backgroundColor = 'white';
    };
    
    // Ensure visibility on focus and key events (in case site JavaScript tries to override)
    inputField.addEventListener('focus', ensureVisibility);
    inputField.addEventListener('keydown', ensureVisibility);
    inputField.addEventListener('keyup', ensureVisibility);
    
    // Auto-resize textarea with scroll when max height reached
    inputField.addEventListener('input', (e) => {
      e.target.style.height = 'auto';
      const maxHeight = 120; // Maximum height in pixels
      const newHeight = Math.min(e.target.scrollHeight, maxHeight);
      e.target.style.height = newHeight + 'px';
      
      // Add scroll when max height is reached
      if (e.target.scrollHeight > maxHeight) {
        e.target.style.overflowY = 'auto';
      } else {
        e.target.style.overflowY = 'hidden';
      }
      
      // Ensure visibility is maintained during input
      ensureVisibility();
    });
    
    // Handle Enter key (Shift+Enter for new line)
    inputField.addEventListener('keydown', (e) => {
      console.log('[ChatDialog] ===== KEYDOWN EVENT =====');
      console.log('[ChatDialog] Key pressed:', e.key, 'Shift:', e.shiftKey);
      if (e.key === 'Enter' && !e.shiftKey) {
        console.log('[ChatDialog] Enter key pressed, calling sendMessage()');
        e.preventDefault();
        this.sendMessage();
      }
    });
    
    // Create send button (restore original styling but same size as delete)
    const sendBtn = document.createElement('button');
    sendBtn.className = 'vocab-chat-send-btn';
    sendBtn.setAttribute('aria-label', 'Send message');
    sendBtn.innerHTML = this.createSendIcon();
    sendBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      console.log('[ChatDialog] ===== SEND BUTTON CLICKED =====');
      
      // Check if API call is in progress (stop icon is shown)
      const isStopIcon = sendBtn.querySelector('rect[fill="#9527F5"]');
      if (isStopIcon) {
        // Abort the API call
        const abortFn = this.dialogContainer?._currentAbortFn;
        if (abortFn && typeof abortFn === 'function') {
          console.log('[ChatDialog] Aborting API call');
          abortFn();
          
          // Get accumulated text from dialog container or extract from DOM
          let accumulatedText = '';
          if (this.dialogContainer?._currentAccumulatedText) {
            accumulatedText = this.dialogContainer._currentAccumulatedText;
          } else {
            // Fallback: extract from streaming message in DOM
            const chatContainer = document.getElementById('vocab-chat-messages');
            if (chatContainer) {
              const lastAiMessage = chatContainer.querySelector('.vocab-chat-message-ai:last-child');
              if (lastAiMessage) {
                const messageContent = lastAiMessage.querySelector('.vocab-chat-message-content');
                if (messageContent) {
                  accumulatedText = messageContent.textContent || messageContent.innerText || '';
                }
              }
            }
          }
          
          // Save accumulated response to chat history if we have text
          if (accumulatedText && accumulatedText.trim()) {
            // Use the requestTextKey from when the request was made (in case user switched tabs)
            const requestTextKey = this.dialogContainer?._currentRequestTextKey || this.currentTextKey;
            
            // Get the chat history for the correct textKey
            const chatHistoryForRequest = this.chatHistories.get(requestTextKey) || [];
            
            // Add AI response to the chat history
            chatHistoryForRequest.push({
              type: 'ai',
              message: accumulatedText.trim(),
              timestamp: new Date().toISOString()
            });
            
            // Update stored chat history for this textKey
            if (requestTextKey) {
              this.chatHistories.set(requestTextKey, chatHistoryForRequest);
              
              // If we're still in the same chat, also update current chatHistory
              if (this.currentTextKey === requestTextKey) {
                this.chatHistory = [...chatHistoryForRequest];
              }
              
              console.log('[ChatDialog] Saved stopped response to chat history for textKey:', requestTextKey);
            }
          } else {
            // No accumulated text - remove the streaming message bubble (with typing indicator)
            const chatContainer = document.getElementById('vocab-chat-messages');
            if (chatContainer) {
              const lastAiMessage = chatContainer.querySelector('.vocab-chat-message-ai:last-child');
              if (lastAiMessage) {
                const messageContent = lastAiMessage.querySelector('.vocab-chat-message-content');
                // Check if it's showing the typing indicator
                if (messageContent && messageContent.querySelector('.vocab-chat-typing-indicator')) {
                  lastAiMessage.remove();
                  console.log('[ChatDialog] Removed streaming message bubble with typing indicator (no content received)');
                }
              }
            }
          }
          
          // Clear abort function, accumulated text, and requestTextKey
          if (this.dialogContainer) {
            this.dialogContainer._currentAbortFn = null;
            this.dialogContainer._currentAccumulatedText = null;
            this.dialogContainer._currentRequestTextKey = null;
          }
          
          // Restore send icon
          sendBtn.innerHTML = this.createSendIcon();
          sendBtn.setAttribute('aria-label', 'Send message');
          sendBtn.disabled = false;
        }
      } else {
        // Normal send action
        console.log('[ChatDialog] Send button clicked, calling sendMessage()');
        this.sendMessage();
      }
    });
    
    // Create delete button (same size as send button)
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'vocab-chat-delete-conversation-btn';
    deleteBtn.id = 'vocab-chat-delete-conversation-btn';
    deleteBtn.setAttribute('aria-label', 'Delete conversation');
    deleteBtn.title = 'Delete conversation';
    deleteBtn.innerHTML = this.createTrashIcon();
    deleteBtn.style.display = 'none'; // Hidden by default
    deleteBtn.addEventListener('click', () => this.deleteConversation());
    
    inputArea.appendChild(inputField);
    inputArea.appendChild(sendBtn);
    inputArea.appendChild(deleteBtn);
    
    console.log('[ChatDialog] Input area assembled with input field, send button, and delete button');
    console.log('[ChatDialog] Input field in DOM:', !!document.getElementById('vocab-chat-input'));
    
    return inputArea;
  },
  
  /**
   * Switch between tabs
   * @param {string} tabName - Tab name ('simplified' or 'ask')
   */
  switchTab(tabName) {
    console.log('[ChatDialog] Switching to tab:', tabName);
    
    // Update tab buttons
    const tabs = this.dialogContainer.querySelectorAll('.vocab-chat-tab');
    tabs.forEach(tab => {
      tab.classList.remove('active');
      if (tab.getAttribute('data-tab') === tabName) {
        tab.classList.add('active');
      }
    });
    
    // Update tab content
    const contents = this.dialogContainer.querySelectorAll('.vocab-chat-tab-content');
    contents.forEach(content => {
      content.classList.remove('active');
      content.style.display = 'none';
      if (content.getAttribute('data-content') === tabName) {
        content.classList.add('active');
        content.style.display = 'flex';
      }
    });
    
    // Update indicator position
    this.updateIndicatorPosition();
    
    // If switching to ask tab, focus the input and scroll to bottom
    if (tabName === 'ask') {
      const inputField = document.getElementById('vocab-chat-input');
      if (inputField) {
        setTimeout(() => inputField.focus(), 100);
      }
      
      // Auto-scroll to bottom when switching to chat tab (if there are messages)
      setTimeout(() => {
        const chatContainer = document.getElementById('vocab-chat-messages');
        if (chatContainer && this.chatHistory.length > 0) {
          this.scrollToBottom(chatContainer);
          console.log('[ChatDialog] Auto-scrolled to bottom on tab switch to ask');
        }
      }, 150);
    }
  },
  
  /**
   * Update indicator position to match active tab
   */
  updateIndicatorPosition() {
    const indicator = document.getElementById('vocab-chat-tab-indicator');
    if (!indicator) return;
    
    const activeTab = this.dialogContainer.querySelector('.vocab-chat-tab.active');
    if (!activeTab) return;
    
    const tabsContainer = activeTab.parentElement;
    const containerRect = tabsContainer.getBoundingClientRect();
    const tabRect = activeTab.getBoundingClientRect();
    
    // Calculate position relative to container
    const left = tabRect.left - containerRect.left;
    const width = tabRect.width;
    
    // Update indicator position and width
    indicator.style.left = `${left}px`;
    indicator.style.width = `${width}px`;
  },
  
  /**
   * Send message in chat
   */
  async sendMessage() {
    console.log('[ChatDialog] ===== SEND MESSAGE FUNCTION CALLED =====');
    const inputField = document.getElementById('vocab-chat-input');
    console.log('[ChatDialog] Input field found:', !!inputField);
    
    if (!inputField) {
      console.log('[ChatDialog] ERROR: Input field not found!');
      return;
    }
    
    const message = inputField.value.trim();
    console.log('[ChatDialog] Message to send:', message);
    
    if (!message) {
      console.log('[ChatDialog] Empty message, returning');
      return;
    }
    
    console.log('[ChatDialog] Current textKey:', this.currentTextKey);
    console.log('[ChatDialog] Current mode:', this.mode);
    
    // Add user message to chat
    this.addMessageToChat('user', message);
    
    // Clear input
    inputField.value = '';
    inputField.style.height = 'auto';
    
    // Show loading animation
    this.showLoadingAnimation();
    
    // Capture the current textKey and text at the time of making the request
    // This ensures the response goes to the correct chat even if user switches tabs
    const requestTextKey = this.currentTextKey;
    const requestText = this.currentText;
    
    // Get context from simplifiedData if available (for simplified mode chat sessions)
    // The context should be the same as what was used in the simplify API call
    let initialContext = requestText; // Default to selected text
    if (this.simplifiedData && this.simplifiedData.context) {
      initialContext = this.simplifiedData.context;
      console.log('[ChatDialog] Using context from simplifiedData for ask API:', initialContext.length, 'characters');
    } else {
      console.log('[ChatDialog] No context in simplifiedData, using requestText as initial_context');
    }
    
    // Determine context_type based on mode and chatContext
    // TEXT: for simplified mode (selected text chat)
    // PAGE: for ask mode with general context (page/summary chat)
    let contextType = null;
    if (this.mode === 'simplified') {
      contextType = 'TEXT';
    } else if (this.mode === 'ask' && this.chatContext === 'general') {
      contextType = 'PAGE';
    }
    console.log('[ChatDialog] Determined context_type:', contextType, 'for mode:', this.mode, 'chatContext:', this.chatContext);
    
    // Prepare chat history from chatHistory
    const chat_history = this.chatHistory.map(item => ({
      role: item.type === 'user' ? 'user' : 'assistant',
      content: item.message
    }));
    
    // Create empty AI message bubble for streaming
    let streamingMessageContent = null;
    let streamingMessageBubble = null;
    let accumulatedText = '';
    let possibleQuestions = []; // Store possibleQuestions during streaming
    let abortRequest = null;
    
    // Get send button and change to stop icon
    const sendBtn = this.dialogContainer.querySelector('.vocab-chat-send-btn');
    if (sendBtn) {
      sendBtn.innerHTML = this.createStopIcon();
      sendBtn.setAttribute('aria-label', 'Stop request');
      sendBtn.disabled = false; // Keep enabled so user can click to stop
    }
    
    // Store requestTextKey on dialog container for use when stopping
    if (this.dialogContainer) {
      this.dialogContainer._currentRequestTextKey = requestTextKey;
    }
    
    // Check if we're still in the same chat tab that initiated the request
    const isSameChat = this.currentTextKey === requestTextKey;
    
    if (isSameChat) {
      // Create streaming message bubble
      const streamingBubble = this.createStreamingMessageBubble();
      streamingMessageBubble = streamingBubble.messageBubble;
      streamingMessageContent = streamingBubble.messageContent;
    }
    
    try {
      // Remove loading animation
      this.removeLoadingAnimation();
      
      // Call streaming API
      abortRequest = await ApiService.ask({
        initial_context: initialContext,
        chat_history: chat_history,
        question: message,
        context_type: contextType,
        onChunk: (chunk, accumulated) => {
          console.log('[ChatDialog] Received chunk:', chunk, 'accumulated:', accumulated);
          
          // Update accumulated text
          accumulatedText = accumulated || '';
          
          // Store accumulated text on dialog container for access when stopping
          if (this.dialogContainer) {
            this.dialogContainer._currentAccumulatedText = accumulatedText;
          }
          
          // Check if we're still in the same chat tab
          if (this.currentTextKey === requestTextKey && streamingMessageContent) {
            // Update the message bubble in real-time (don't pass possibleQuestions during streaming)
            this.updateStreamingMessage(streamingMessageContent, accumulatedText, undefined);
          } else if (!isSameChat) {
            // User switched tabs, but we still want to update if they switch back
            // We'll handle this in the complete callback
            console.log('[ChatDialog] User switched tabs during streaming, will update on complete');
          }
        },
        onComplete: (chat_history, receivedPossibleQuestions = []) => {
          console.log('[ChatDialog] ===== ONCOMPLETE CALLBACK CALLED =====');
          console.log('[ChatDialog] Stream complete, chat_history:', chat_history);
          console.log('[ChatDialog] Received possibleQuestions parameter:', receivedPossibleQuestions);
          console.log('[ChatDialog] Received possibleQuestions type:', typeof receivedPossibleQuestions);
          console.log('[ChatDialog] Received possibleQuestions is array:', Array.isArray(receivedPossibleQuestions));
          console.log('[ChatDialog] Received possibleQuestions length:', receivedPossibleQuestions?.length || 0);
          console.log('[ChatDialog] Received possibleQuestions value (stringified):', JSON.stringify(receivedPossibleQuestions));
      
      // Remove loading animation
      this.removeLoadingAnimation();
      
      // Clear abort function, accumulated text, and requestTextKey, restore send button icon
      if (this.dialogContainer) {
        this.dialogContainer._currentAbortFn = null;
        this.dialogContainer._currentAccumulatedText = null;
        this.dialogContainer._currentRequestTextKey = null;
      }
      if (sendBtn) {
        sendBtn.innerHTML = this.createSendIcon();
        sendBtn.setAttribute('aria-label', 'Send message');
        sendBtn.disabled = false;
      }
      
          // Store the received possibleQuestions - ensure it's an array
          if (Array.isArray(receivedPossibleQuestions)) {
            possibleQuestions = receivedPossibleQuestions;
          } else if (receivedPossibleQuestions) {
            console.log('[ChatDialog] WARNING: receivedPossibleQuestions is not an array, converting:', receivedPossibleQuestions);
            possibleQuestions = [receivedPossibleQuestions];
          } else {
            possibleQuestions = [];
          }
          console.log('[ChatDialog] Stored possibleQuestions:', possibleQuestions);
          console.log('[ChatDialog] Stored possibleQuestions length:', possibleQuestions.length);
      
          // Get the final AI response
          let aiResponse = accumulatedText || 'No response received';
          
          // If we have chat_history from the complete event, extract the latest assistant message
          if (chat_history && Array.isArray(chat_history)) {
            for (let i = chat_history.length - 1; i >= 0; i--) {
              if (chat_history[i].role === 'assistant') {
                aiResponse = chat_history[i].content;
            break;
              }
          }
        }
        
          console.log('[ChatDialog] Final AI response:', aiResponse);
          console.log('[ChatDialog] Final possibleQuestions to display:', possibleQuestions);
        
        // Check if we're still in the same chat tab that initiated the request
        if (this.currentTextKey === requestTextKey) {
            // We're still in the same chat, update the streaming message or add it if it doesn't exist
            if (streamingMessageContent) {
              // Update the existing streaming message with final content and questions
              this.updateStreamingMessage(streamingMessageContent, aiResponse, possibleQuestions);
              
              // Add the AI response to history (user message was already added before API call)
              this.chatHistory.push({
                type: 'ai',
                message: aiResponse,
                possibleQuestions: possibleQuestions,
                timestamp: new Date().toISOString()
              });
            } else {
              // Message bubble was removed or doesn't exist, add it normally
          this.addMessageToChat('ai', aiResponse, possibleQuestions);
            }
            
            // Update stored chat history
            if (this.currentTextKey) {
              this.chatHistories.set(this.currentTextKey, [...this.chatHistory]);
            }
        } else {
          // User switched to a different chat tab, add response to the correct chat history
          console.log('[ChatDialog] User switched tabs, adding response to correct chat history for textKey:', requestTextKey);
          
          // Get the chat history for the original textKey
          const originalChatHistory = this.chatHistories.get(requestTextKey) || [];
          
            // Add the AI response (user message was already added when request was made)
          originalChatHistory.push({
            type: 'ai',
            message: aiResponse,
            possibleQuestions: possibleQuestions,
            timestamp: new Date().toISOString()
          });
          
          // Update the stored chat history
          this.chatHistories.set(requestTextKey, originalChatHistory);
          
          console.log('[ChatDialog] Added AI response to original chat history for textKey:', requestTextKey);
        }
        },
        onError: (error) => {
          console.error('[ChatDialog] Stream error:', error);
          
          // Remove loading animation
          this.removeLoadingAnimation();
          
          // Clear abort function and restore send button icon
          if (this.dialogContainer) {
            this.dialogContainer._currentAbortFn = null;
          }
          if (sendBtn) {
            sendBtn.innerHTML = this.createSendIcon();
            sendBtn.setAttribute('aria-label', 'Send message');
            sendBtn.disabled = false;
          }
          
        // Check if it's a 429 rate limit error
          const isRateLimit = error.status === 429 || 
                             error.message.includes('429') || 
                             error.message.includes('Rate limit') ||
                             error.message.includes('too fast');
        
        if (isRateLimit && typeof ErrorBanner !== 'undefined') {
            ErrorBanner.show('You are requesting too fast, please retry after few seconds');
          
          // If this is a text selection (not page-general), stop pulsating and return to normal state
          if (requestTextKey && !requestTextKey.startsWith('page-general')) {
            const highlight = TextSelector.textToHighlights.get(requestTextKey);
            if (highlight) {
              // Stop pulsating animation
              highlight.classList.remove('vocab-text-loading', 'vocab-text-pulsate', 'vocab-text-pulsate-green');
              
              // Restore magic-meaning button from loading state
              TextSelector.restoreMagicMeaningButton(requestTextKey);
              
              console.log('[ChatDialog] Stopped pulsating animation and restored normal state for text selection');
            }
          }
        }
          
          // Remove streaming message bubble if it exists
          if (streamingMessageBubble && streamingMessageBubble.parentNode) {
            streamingMessageBubble.remove();
          }
          
          // Check if it's a LOGIN_REQUIRED error - don't show error message in chat container
          if (error.errorCode === 'LOGIN_REQUIRED') {
            console.log('[ChatDialog] LOGIN_REQUIRED error detected, skipping chat message (login modal will be shown via event)');
            return;
          }
          
          // Handle error case - check if we're still in the same chat
          const errorMessage = `⚠️ **Error:**\n\n${error.message || 'Failed to get response from server'}`;
        
        if (this.currentTextKey === requestTextKey) {
            this.addMessageToChat('ai', errorMessage);
        } else {
          // Add error to the original chat history
          const originalChatHistory = this.chatHistories.get(requestTextKey) || [];
          
          // Only add the error response (user message was already added when request was made)
          originalChatHistory.push({
            type: 'ai',
              message: errorMessage,
            timestamp: new Date().toISOString()
          });
          
          this.chatHistories.set(requestTextKey, originalChatHistory);
          console.log('[ChatDialog] Added error response to original chat history for textKey:', requestTextKey);
        }
      }
      });
      
      // Store abort function on dialog container for stop functionality
      if (this.dialogContainer && abortRequest) {
        this.dialogContainer._currentAbortFn = abortRequest;
      }
      
    } catch (error) {
      console.error('[ChatDialog] Error initiating streaming request:', error);
      this.removeLoadingAnimation();
      
      // Clear abort function, accumulated text, and requestTextKey, restore send button icon
      if (this.dialogContainer) {
        this.dialogContainer._currentAbortFn = null;
        this.dialogContainer._currentAccumulatedText = null;
        this.dialogContainer._currentRequestTextKey = null;
      }
      if (sendBtn) {
        sendBtn.innerHTML = this.createSendIcon();
        sendBtn.setAttribute('aria-label', 'Send message');
        sendBtn.disabled = false;
      }
      
      // Remove streaming message bubble if it exists
      if (streamingMessageBubble && streamingMessageBubble.parentNode) {
        streamingMessageBubble.remove();
      }
      
      // Check if it's a 429 rate limit error
      const isRateLimit = error.status === 429 || 
                         error.message.includes('429') || 
                         error.message.includes('Rate limit') ||
                         error.message.includes('too fast');
      
      if (isRateLimit && typeof ErrorBanner !== 'undefined') {
        await ErrorBanner.show('You are requesting too fast, please retry after few seconds');
        
        // If this is a text selection (not page-general), stop pulsating and return to normal state
        if (requestTextKey && !requestTextKey.startsWith('page-general')) {
          const highlight = TextSelector.textToHighlights.get(requestTextKey);
          if (highlight) {
            // Stop pulsating animation
            highlight.classList.remove('vocab-text-loading', 'vocab-text-pulsate', 'vocab-text-pulsate-green');
            
            // Restore magic-meaning button from loading state
            TextSelector.restoreMagicMeaningButton(requestTextKey);
            
            console.log('[ChatDialog] Stopped pulsating animation and restored normal state for text selection');
          }
        }
      }
      
      // Check if it's a LOGIN_REQUIRED error - don't show error message in chat container
      if (error.errorCode === 'LOGIN_REQUIRED') {
        console.log('[ChatDialog] LOGIN_REQUIRED error detected in catch block, skipping chat message (login modal will be shown via event)');
        return;
      }
      
      // Handle error case - check if we're still in the same chat
      if (this.currentTextKey === requestTextKey) {
        this.addMessageToChat('ai', `Error: Failed to initiate request to server`);
      } else {
        // Add error to the original chat history
        const originalChatHistory = this.chatHistories.get(requestTextKey) || [];
        
        // Only add the error response (user message was already added when request was made)
        originalChatHistory.push({
          type: 'ai',
          message: `Error: Failed to initiate request to server`,
          timestamp: new Date().toISOString()
        });
        
        this.chatHistories.set(requestTextKey, originalChatHistory);
        console.log('[ChatDialog] Added error response to original chat history for textKey:', requestTextKey);
      }
    }
    
    console.log('[ChatDialog] Message sent:', message);
  },
  
  /**
   * Add message to chat
   * @param {string} type - 'user' or 'ai'
   * @param {string} message - Message content
   * @returns {HTMLElement|null} The message bubble element (for streaming updates)
   */
  addMessageToChat(type, message, possibleQuestions = []) {
    const chatContainer = document.getElementById('vocab-chat-messages');
    
    // Remove "Ask me anything about the page" message if exists
    const noChatsMsg = chatContainer.querySelector('.vocab-chat-no-messages');
    if (noChatsMsg) {
      noChatsMsg.remove();
    }
    
    // Create message bubble
    const messageBubble = document.createElement('div');
    messageBubble.className = `vocab-chat-message vocab-chat-message-${type}`;
    
    const messageContent = document.createElement('div');
    messageContent.className = 'vocab-chat-message-content';
    
    // For AI messages, render markdown
    if (type === 'ai') {
      messageContent.innerHTML = this.renderMarkdown(message);
    } else {
      messageContent.textContent = message;
    }
    
    messageBubble.appendChild(messageContent);
    
    // Add questions below AI messages if they exist
    console.log('[ChatDialog] addMessageToChat: type=', type, 'possibleQuestions=', possibleQuestions);
    if (type === 'ai' && possibleQuestions && possibleQuestions.length > 0) {
      console.log('[ChatDialog] addMessageToChat: Questions found, calling renderMessageQuestions');
      const questionsContainer = this.renderMessageQuestions(possibleQuestions);
      if (questionsContainer) {
        console.log('[ChatDialog] addMessageToChat: Questions container created, appending to message bubble');
        messageBubble.appendChild(questionsContainer);
      } else {
        console.log('[ChatDialog] addMessageToChat: Questions container is null, not appending');
      }
    } else {
      console.log('[ChatDialog] addMessageToChat: No questions (type is not ai or questions are empty)');
    }
    
    chatContainer.appendChild(messageBubble);
    
    // Show global clear button
    this.updateGlobalClearButton();
    
    // Auto-scroll to bottom with smooth behavior
    this.scrollToBottom(chatContainer);
    
    // Fallback: Also try scrolling after a short delay to ensure DOM is fully updated
    setTimeout(() => {
      this.scrollToBottom(chatContainer);
    }, 100);
    
    // Store in history
    const messageData = { type, message, possibleQuestions: possibleQuestions || [], timestamp: new Date().toISOString() };
    this.chatHistory.push(messageData);
    
    // Also update the stored chat history for this textKey
    if (this.currentTextKey) {
      console.log('[ChatDialog] ===== SAVING TO CHATHISTORIES MAP =====');
      console.log('[ChatDialog] Saving to chatHistories with key:', this.currentTextKey);
      console.log('[ChatDialog] Messages to save:', this.chatHistory.length);
      console.log('[ChatDialog] ChatHistories Map before set:', Array.from(this.chatHistories.keys()));
      
      this.chatHistories.set(this.currentTextKey, [...this.chatHistory]);
      
      console.log('[ChatDialog] ChatHistories Map after set:', Array.from(this.chatHistories.keys()));
    }
    
    // Store chat message in analysis data for persistence
    if (this.currentTextKey && window.ButtonPanel && window.ButtonPanel.topicsModal && window.ButtonPanel.topicsModal.customContentModal && window.ButtonPanel.topicsModal.customContentModal.activeTabId) {
      const activeContent = window.ButtonPanel.topicsModal.customContentModal.getContentByTabId(parseInt(window.ButtonPanel.topicsModal.customContentModal.activeTabId));
      if (activeContent && activeContent.analysis) {
        // Ensure chats array is initialized
        if (!activeContent.analysis.chats) {
          activeContent.analysis.chats = [];
          console.log('[ChatDialog] Initialized chats array in analysis data');
        }
        
        console.log('[ChatDialog] Storing chat message for currentTextKey:', this.currentTextKey, 'ChatContext:', this.chatContext);
        console.log('[ChatDialog] Available chats in analysis:', activeContent.analysis.chats.map(c => c.textKey));
        // Check if this textKey already exists in chats
        const existingChatIndex = activeContent.analysis.chats.findIndex(c => 
          c.textKey === this.currentTextKey
        );
        
        const chatData = {
          textKey: this.currentTextKey,
          messages: [...this.chatHistory], // Store all messages for this textKey
          lastUpdated: new Date().toISOString()
        };
        
        if (existingChatIndex !== -1) {
          // Update existing chat
          activeContent.analysis.chats[existingChatIndex] = chatData;
          console.log(`[ChatDialog] Updated existing chat for textKey "${this.currentTextKey}" in analysis data`);
        } else {
          // Add new chat
          activeContent.analysis.chats.push(chatData);
          console.log(`[ChatDialog] Added new chat for textKey "${this.currentTextKey}" to analysis data`);
        }
        console.log('[ChatDialog] Final chats in analysis:', activeContent.analysis.chats.map(c => c.textKey));
      }
    }
    
    console.log('[ChatDialog] ===== MESSAGE SAVED IMMEDIATELY =====');
    console.log('[ChatDialog] Message type:', type, 'Total messages:', this.chatHistory.length);
    
    // Return the message bubble for streaming updates
    return messageBubble;
  },
  
  /**
   * Create an empty AI message bubble for streaming updates
   * @returns {HTMLElement} The message bubble element
   */
  createStreamingMessageBubble() {
    const chatContainer = document.getElementById('vocab-chat-messages');
    
    // Remove "Ask me anything about the page" message if exists
    const noChatsMsg = chatContainer.querySelector('.vocab-chat-no-messages');
    if (noChatsMsg) {
      noChatsMsg.remove();
    }
    
    // Create message bubble
    const messageBubble = document.createElement('div');
    messageBubble.className = 'vocab-chat-message vocab-chat-message-ai';
    
    const messageContent = document.createElement('div');
    messageContent.className = 'vocab-chat-message-content';
    // Show 3-dot typing indicator while waiting for first event
    messageContent.innerHTML = `
      <div class="vocab-chat-typing-indicator">
        <span class="vocab-chat-typing-dot"></span>
        <span class="vocab-chat-typing-dot"></span>
        <span class="vocab-chat-typing-dot"></span>
      </div>
    `;
    
    messageBubble.appendChild(messageContent);
    chatContainer.appendChild(messageBubble);
    
    // Show global clear button
    this.updateGlobalClearButton();
    
    // Auto-scroll to bottom
    this.scrollToBottom(chatContainer);
    
    return { messageBubble, messageContent };
  },
  
  /**
   * Update streaming message bubble with new content
   * @param {HTMLElement} messageContent - The message content element
   * @param {string} accumulatedText - The accumulated text to display
   */
  updateStreamingMessage(messageContent, accumulatedText, possibleQuestions = undefined) {
    if (!messageContent) return;
    
    // Show typing indicator if no content yet, otherwise show the content
    if (!accumulatedText || accumulatedText.trim().length === 0) {
      messageContent.innerHTML = `
        <div class="vocab-chat-typing-indicator">
          <span class="vocab-chat-typing-dot"></span>
          <span class="vocab-chat-typing-dot"></span>
          <span class="vocab-chat-typing-dot"></span>
        </div>
      `;
      return;
    }
    
    // Update the content with markdown rendering
    messageContent.innerHTML = this.renderMarkdown(accumulatedText);
    
    // Attach click handlers to reference markers
    this.attachReferenceMarkerHandlers(messageContent);
    
    // Get the message bubble parent
    const messageBubble = messageContent.closest('.vocab-chat-message');
    let questionsAdded = false;
    
    if (messageBubble) {
      // Only update questions if possibleQuestions is explicitly provided (not undefined)
      // This prevents removing questions during streaming updates
      if (possibleQuestions !== undefined) {
        // Remove existing questions container if any
        const existingQuestions = messageBubble.querySelector('.vocab-chat-message-questions-container');
        if (existingQuestions) {
          existingQuestions.remove();
        }
        
        // Add questions if they exist and are non-empty
        console.log('[ChatDialog] updateStreamingMessage: Checking for possibleQuestions:', possibleQuestions);
        if (possibleQuestions && Array.isArray(possibleQuestions) && possibleQuestions.length > 0) {
          console.log('[ChatDialog] updateStreamingMessage: Questions found, calling renderMessageQuestions');
          const questionsContainer = this.renderMessageQuestions(possibleQuestions);
          if (questionsContainer) {
            console.log('[ChatDialog] updateStreamingMessage: Questions container created, appending to message bubble');
            messageBubble.appendChild(questionsContainer);
            questionsAdded = true;
          } else {
            console.log('[ChatDialog] updateStreamingMessage: Questions container is null, not appending');
          }
        } else {
          console.log('[ChatDialog] updateStreamingMessage: No questions or empty array');
        }
      } else {
        console.log('[ChatDialog] updateStreamingMessage: possibleQuestions is undefined, preserving existing questions');
      }
    }
    
    // Auto-scroll to bottom
    // Use immediate scroll during streaming (when possibleQuestions is undefined)
    // Use normal scroll when questions are added (to ensure smooth transition)
    // Only scroll if user is already at bottom (conditional auto-scroll)
    const chatContainer = document.getElementById('vocab-chat-messages');
    if (chatContainer) {
      const isStreaming = possibleQuestions === undefined;
      // During streaming, only auto-scroll if user is at bottom
      // When questions are added (complete), always scroll to show them
      const onlyIfAtBottom = isStreaming;
      this.scrollToBottom(chatContainer, isStreaming, onlyIfAtBottom);
      
      // If questions were added, scroll again after a short delay to ensure DOM is fully updated
      // Always scroll when questions are added (user wants to see them)
      if (questionsAdded) {
        setTimeout(() => {
          this.scrollToBottom(chatContainer, false, false);
        }, 100);
      }
    }
  },
  
  /**
   * Scroll chat container to bottom with smooth behavior
   * @param {HTMLElement} chatContainer - The chat messages container
   * @param {boolean} immediate - If true, use immediate scroll (no smooth animation). Default: false
   * @param {boolean} onlyIfAtBottom - If true, only scroll if user is already at bottom. Default: false
   */
  scrollToBottom(chatContainer, immediate = false, onlyIfAtBottom = false) {
    if (!chatContainer) {
      console.log('[ChatDialog] scrollToBottom: No chat container provided');
      return;
    }
    
    // Find the scrollable content container (vocab-chat-scrollable-content)
    // This is the actual scrollable element, not the tab content
    const scrollableContent = chatContainer.closest('.vocab-chat-scrollable-content');
    if (!scrollableContent) {
      // Fallback: try to find it from tab content
      const tabContent = chatContainer.closest('.vocab-chat-tab-content');
      if (tabContent) {
        const foundScrollable = tabContent.querySelector('.vocab-chat-scrollable-content');
        if (foundScrollable) {
          this.scrollScrollableContent(foundScrollable, immediate, onlyIfAtBottom);
          return;
        }
      }
      console.log('[ChatDialog] scrollToBottom: No scrollable content found');
      return;
    }
    
    this.scrollScrollableContent(scrollableContent, immediate, onlyIfAtBottom);
  },
  
  /**
   * Check if user is at or near the bottom of the scrollable content
   * @param {HTMLElement} scrollableContent - The scrollable content container
   * @param {number} tolerance - Pixel tolerance for "near bottom" (default: 50px)
   * @returns {boolean} True if user is at or near the bottom
   */
  isAtBottom(scrollableContent, tolerance = 50) {
    if (!scrollableContent) return false;
    
    const currentScroll = scrollableContent.scrollTop;
    const maxScroll = scrollableContent.scrollHeight - scrollableContent.clientHeight;
    const distanceFromBottom = maxScroll - currentScroll;
    
    // User is at bottom if they're within tolerance pixels of the bottom
    return distanceFromBottom <= tolerance;
  },
  
  /**
   * Scroll the scrollable content container to bottom
   * @param {HTMLElement} scrollableContent - The scrollable content container
   * @param {boolean} immediate - If true, use immediate scroll (no smooth animation). Default: false
   * @param {boolean} onlyIfAtBottom - If true, only scroll if user is already at bottom. Default: false
   */
  scrollScrollableContent(scrollableContent, immediate = false, onlyIfAtBottom = false) {
    if (!scrollableContent) return;
    
    // If onlyIfAtBottom is true, check if user is at bottom before scrolling
    if (onlyIfAtBottom && !this.isAtBottom(scrollableContent)) {
      console.log('[ChatDialog] scrollScrollableContent: User has scrolled up, skipping auto-scroll');
      return;
    }
    
    console.log('[ChatDialog] scrollScrollableContent: Scrolling to bottom, immediate:', immediate);
    console.log('[ChatDialog] scrollScrollableContent: scrollHeight:', scrollableContent.scrollHeight);
    console.log('[ChatDialog] scrollScrollableContent: clientHeight:', scrollableContent.clientHeight);
    
    // Function to perform the actual scroll
    const performScroll = () => {
      if (immediate) {
        // For immediate scroll (during streaming), use instant scroll
        scrollableContent.scrollTop = scrollableContent.scrollHeight;
      } else {
        // For normal scroll, use smooth behavior
        scrollableContent.scrollTo({
          top: scrollableContent.scrollHeight,
          behavior: 'smooth'
        });
      }
    };
    
    // Use requestAnimationFrame to ensure DOM updates are complete
    requestAnimationFrame(() => {
      performScroll();
      
      // Multiple scroll attempts to handle async DOM updates and layout recalculation
      // This is especially important during streaming when content is added word by word
      setTimeout(() => {
        performScroll();
      }, 0);
      
      setTimeout(() => {
        performScroll();
      }, 10);
      
      // Final check with a small delay to ensure we're at the bottom
      setTimeout(() => {
        const currentScroll = scrollableContent.scrollTop;
        const maxScroll = scrollableContent.scrollHeight - scrollableContent.clientHeight;
        // If we're not at the bottom (within 10px tolerance), scroll again
        if (Math.abs(currentScroll - maxScroll) > 10) {
          scrollableContent.scrollTop = scrollableContent.scrollHeight;
        }
      }, 50);
    });
  },
  
  /**
   * Show loading animation (three dots waving)
   */
  showLoadingAnimation() {
    const chatContainer = document.getElementById('vocab-chat-messages');
    
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'vocab-chat-typing-indicator';
    loadingIndicator.id = 'vocab-chat-loading';
    loadingIndicator.innerHTML = `
      <span></span>
      <span></span>
      <span></span>
    `;
    
    chatContainer.appendChild(loadingIndicator);
    
    // Auto-scroll to bottom with smooth behavior
    this.scrollToBottom(chatContainer);
  },
  
  /**
   * Remove loading animation
   */
  removeLoadingAnimation() {
    const loadingBubble = document.getElementById('vocab-chat-loading');
    if (loadingBubble) {
      loadingBubble.remove();
    }
  },
  
  /**
   * Parse and replace reference markers with clickable buttons
   * Handles two patterns:
   * 1. [[[(N) example_substring]]] - uses the number from the pattern, renders as rectangular button
   * 2. [[[ some string ]]] - assigns sequential numbers (1, 2, 3...), renders as circular button
   * @param {string} text - Text that may contain reference markers
   * @returns {string} Text with reference markers replaced by HTML buttons
   */
  parseReferenceMarkers(text) {
    if (!text) return text;
    
    let result = text;
    let sequentialNumber = 1;
    
    // First, handle patterns with explicit numbers: [[[(N) example_substring]]]
    // Pattern matches: [[[( followed by a number in parentheses, optionally followed by space, 
    // then any text, followed by )]]]
    const numberedPattern = /\[\[\[\((\d+)\)\s*([^\]]+?)\]\]\]/g;
    result = result.replace(numberedPattern, (match, refNumber, substring) => {
      // Trim any leading/trailing whitespace from substring
      substring = substring.trim();
      
      // Create a unique ID for this reference marker
      const refId = `vocab-ref-${refNumber}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Return HTML for clickable reference button (small solid purple circular button with white text)
      return `<button class="vocab-ref-button-circular" data-ref-number="${refNumber}" data-substring="${this.escapeHtml(substring)}" data-ref-id="${refId}" type="button">${refNumber}</button>`;
    });
    
    // Then, handle patterns without numbers: [[[ some string ]]]
    // Pattern matches: [[[ followed by any text, followed by ]]]
    // Since numbered patterns are already replaced with HTML, this will only match unnumbered patterns
    // We use a more robust pattern that handles content with ] characters by looking for the closing ]]]
    const unnumberedPattern = /\[\[\[((?:(?!\]\]\]).)+?)\]\]\]/g;
    result = result.replace(unnumberedPattern, (match, substring) => {
      // Trim any leading/trailing whitespace from substring
      substring = substring.trim();
      
      // Skip empty substrings
      if (!substring) {
        return match; // Return as-is if empty
      }
      
      // Assign sequential number
      const refNumber = sequentialNumber++;
      
      // Create a unique ID for this reference marker
      const refId = `vocab-ref-${refNumber}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Return HTML for clickable circular reference button (small solid purple circle with white text)
      return `<button class="vocab-ref-button-circular" data-ref-number="${refNumber}" data-substring="${this.escapeHtml(substring)}" data-ref-id="${refId}" type="button">${refNumber}</button>`;
    });
    
    return result;
  },
  
  /**
   * Escape HTML special characters
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  },
  
  /**
   * Find and highlight HTML element containing the substring using fuzzy matching
   * Searches all HTML element types: p, h1-h6, div, span, article, section, main, header, footer, aside, nav, etc.
   * @param {string} substring - The substring to find
   */
  scrollToAndHighlightParagraph(substring) {
    console.log('[ChatDialog] scrollToAndHighlightParagraph called with substring:', substring);
    
    if (!substring) {
      console.warn('[ChatDialog] No substring provided to scrollToAndHighlightParagraph');
      return null;
    }
    
    // Remove any existing highlights
    this.removeReferenceHighlights();
    
    const searchText = substring.trim();
    if (!searchText) {
      console.warn('[ChatDialog] Substring is empty after trimming');
      return null;
    }
    
    console.log('[ChatDialog] Search text:', searchText);
    console.log('[ChatDialog] Search text length:', searchText.length);
    
    const lowerSearchText = searchText.toLowerCase();
    const searchWords = searchText.split(/\s+/).filter(w => w.length > 2); // Filter out very short words
    
    console.log('[ChatDialog] Search words:', searchWords);
    console.log('[ChatDialog] Search words count:', searchWords.length);
    
    // Search in all HTML element types
    const searchableSelectors = 'p, h1, h2, h3, h4, h5, h6, div, span, article, section, main, header, footer, aside, nav, li, td, th, blockquote, pre, code, label, figcaption, summary, details';
    const allElements = document.body.querySelectorAll(searchableSelectors);
    
    console.log('[ChatDialog] Total elements to search:', allElements.length);
    
    let bestMatch = null;
    let bestMatchScore = 0;
    
    // Fuzzy matching function - calculates similarity score
    const calculateSimilarity = (text1, text2) => {
      const lower1 = text1.toLowerCase();
      const lower2 = text2.toLowerCase();
      
      // Exact match gets highest score
      if (lower1 === lower2) return 100;
      
      // Contains match
      if (lower2.includes(lower1)) return 90;
      if (lower1.includes(lower2)) return 85;
      
      // Word-based matching
      const words1 = lower1.split(/\s+/).filter(w => w.length > 0);
      const words2 = lower2.split(/\s+/).filter(w => w.length > 0);
      
      if (words1.length === 0 || words2.length === 0) return 0;
      
      // Count matching words
      let matchingWords = 0;
      for (const word1 of words1) {
        if (words2.some(word2 => word2.includes(word1) || word1.includes(word2))) {
          matchingWords++;
        }
      }
      
      // Calculate score based on word matches
      const wordMatchRatio = matchingWords / Math.max(words1.length, words2.length);
      return wordMatchRatio * 80;
    };
    
    // First, collect all matching elements with their scores
    const matchingElements = [];
    
    // Get chat dialog container to exclude from search
    const chatDialog = document.getElementById('vocab-chat-dialog');
    
    // Helper function to check if element is inside chat dialog
    const isInsideChatDialog = (element) => {
      if (!chatDialog) return false;
      return chatDialog.contains(element) || element === chatDialog;
    };
    
    // Search through all elements
    for (const elem of allElements) {
      // Skip if element is inside chat dialog
      if (isInsideChatDialog(elem)) {
        continue;
      }
      
      // Skip if element is hidden or too small
      const style = window.getComputedStyle(elem);
      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
        continue;
      }
      
      const elemText = elem.innerText || elem.textContent || '';
      if (!elemText.trim()) continue;
      
      const lowerElemText = elemText.toLowerCase();
      let score = 0;
      let isMatch = false;
      
      // Try exact match first
      if (lowerElemText.includes(lowerSearchText)) {
        score = calculateSimilarity(searchText, elemText);
        isMatch = true;
      }
      // Try fuzzy matching with word-based approach
      else if (searchWords.length > 0) {
        // Check if all significant words are present
        const significantWords = searchWords.filter(w => w.length > 3);
        if (significantWords.length > 0) {
          const allWordsPresent = significantWords.every(word => 
            lowerElemText.includes(word.toLowerCase())
          );
          
          if (allWordsPresent) {
            score = calculateSimilarity(searchText, elemText);
            isMatch = true;
          }
        }
        
        // Try matching first few words
        if (!isMatch && searchWords.length >= 2) {
          const firstFewWords = searchWords.slice(0, Math.min(3, searchWords.length)).join(' ').toLowerCase();
          if (lowerElemText.includes(firstFewWords)) {
            score = calculateSimilarity(searchText, elemText);
            isMatch = true;
          }
        }
        
        // Try partial word matching
        if (!isMatch) {
          const matchingWords = searchWords.filter(word => {
            const lowerWord = word.toLowerCase();
            return lowerElemText.includes(lowerWord) || 
                   Array.from(lowerElemText.split(/\s+/)).some(elemWord => 
                     elemWord.includes(lowerWord) || lowerWord.includes(elemWord)
                   );
          });
          
          if (matchingWords.length >= Math.ceil(searchWords.length * 0.6)) {
            score = calculateSimilarity(searchText, elemText);
            isMatch = true;
          }
        }
      }
      
      if (isMatch && score > 20) {
        matchingElements.push({ element: elem, score: score });
      }
    }
    
    console.log('[ChatDialog] Found', matchingElements.length, 'matching elements');
    
    if (matchingElements.length === 0) {
      console.warn('[ChatDialog] No matching elements found');
      return null;
    }
    
    // Sort by score (highest first)
    matchingElements.sort((a, b) => b.score - a.score);
    
    // Find the leaf node (most specific element)
    // A leaf node is one that contains the text but none of its children also contain the text
    // OR it's the deepest element in the DOM tree among matches
    let leafMatch = null;
    let leafMatchScore = 0;
    
    for (const match of matchingElements) {
      const elem = match.element;
      const score = match.score;
      
      // Check if this element is a leaf node (no child elements also match)
      // Get all child elements that are also in our searchable selectors
      const childMatches = Array.from(elem.querySelectorAll(searchableSelectors)).filter(child => {
        // Check if this child is also in our matching elements
        return matchingElements.some(m => m.element === child);
      });
      
      // If no child elements match, this is a leaf node
      if (childMatches.length === 0) {
        // This is a leaf node - use it if it has a better or equal score
        if (score >= leafMatchScore) {
          leafMatch = elem;
          leafMatchScore = score;
          console.log('[ChatDialog] Found leaf node match:', elem.tagName, 'score:', score);
        }
      } else {
        // This element has children that also match
        // Check if any of the children are leaf nodes with better scores
        let hasBetterLeafChild = false;
        for (const childMatch of childMatches) {
          const childMatchData = matchingElements.find(m => m.element === childMatch);
          if (childMatchData) {
            // Check if this child is a leaf (no matching grandchildren)
            const grandchildMatches = Array.from(childMatch.querySelectorAll(searchableSelectors)).filter(grandchild => {
              return matchingElements.some(m => m.element === grandchild);
            });
            
            if (grandchildMatches.length === 0 && childMatchData.score >= leafMatchScore) {
              hasBetterLeafChild = true;
              break;
            }
          }
        }
        
        // Only use this element if it doesn't have better leaf children
        if (!hasBetterLeafChild && score > leafMatchScore) {
          // But prefer elements that are more specific (have fewer children with matches)
          // Actually, let's skip non-leaf nodes and only use leaf nodes
          continue;
        }
      }
    }
    
    // If we found a leaf match, use it
    if (leafMatch) {
      bestMatch = leafMatch;
      bestMatchScore = leafMatchScore;
    } else {
      // Fallback: use the highest scoring element, but try to find the deepest one
      // among elements with the same highest score
      const highestScore = matchingElements[0].score;
      const topMatches = matchingElements.filter(m => m.score === highestScore);
      
      // Find the deepest element (most nested)
      let deepestElement = null;
      let maxDepth = -1;
      
      for (const match of topMatches) {
        const elem = match.element;
        // Calculate depth in DOM tree
        let depth = 0;
        let current = elem;
        while (current && current !== document.body) {
          depth++;
          current = current.parentElement;
        }
        
        if (depth > maxDepth) {
          maxDepth = depth;
          deepestElement = elem;
        }
      }
      
      if (deepestElement) {
        bestMatch = deepestElement;
        bestMatchScore = highestScore;
        console.log('[ChatDialog] Using deepest element as fallback:', deepestElement.tagName, 'depth:', maxDepth);
      } else {
        // Last resort: use highest scoring element
        bestMatch = matchingElements[0].element;
        bestMatchScore = matchingElements[0].score;
      }
    }
    
    console.log('[ChatDialog] Search completed. Best match score:', bestMatchScore);
    
    if (bestMatch && bestMatchScore > 20) {
      console.log('[ChatDialog] ===== MATCH FOUND =====');
      console.log('[ChatDialog] Best match element tag:', bestMatch.tagName);
      console.log('[ChatDialog] Best match element class:', bestMatch.className);
      console.log('[ChatDialog] Best match element ID:', bestMatch.id);
      console.log('[ChatDialog] Best match score:', bestMatchScore);
      console.log('[ChatDialog] Best match text content:', bestMatch.innerText || bestMatch.textContent || '');
      console.log('[ChatDialog] Best match text length:', (bestMatch.innerText || bestMatch.textContent || '').length);
      console.log('[ChatDialog] Best match HTML (first 500 chars):', bestMatch.outerHTML.substring(0, 500));
      
      // Remove any existing fade-out animation class first
      bestMatch.classList.remove('vocab-reference-highlight-removing');
      
      // Highlight the matched element with smooth fade-in
      bestMatch.classList.add('vocab-reference-highlight');
      console.log('[ChatDialog] Added vocab-reference-highlight class to element');
      
      // Ensure inline elements can display background properly
      const computedStyle = window.getComputedStyle(bestMatch);
      if (computedStyle.display === 'inline') {
        bestMatch.style.setProperty('display', 'inline-block', 'important');
        console.log('[ChatDialog] Changed display to inline-block for inline element');
      }
      
      // Force a reflow to ensure styles are applied
      void bestMatch.offsetHeight;
      
      // Verify the highlight class is applied
      requestAnimationFrame(() => {
        const hasClass = bestMatch.classList.contains('vocab-reference-highlight');
        const computedBg = window.getComputedStyle(bestMatch).backgroundColor;
        console.log('[ChatDialog] Highlight class applied:', hasClass);
        console.log('[ChatDialog] Computed background color:', computedBg);
      });
      
      // Function to scroll to element with multiple fallback methods
      const scrollToElement = (element) => {
        console.log('[ChatDialog] Scrolling to element...');
        
        // Method 1: Try scrollIntoView with smooth behavior
        try {
          element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
          console.log('[ChatDialog] Scroll command executed (scrollIntoView)');
        } catch (e) {
          console.warn('[ChatDialog] scrollIntoView failed:', e);
        }
        
        // Method 2: Also try scrolling the window directly as fallback
        requestAnimationFrame(() => {
          try {
            const rect = element.getBoundingClientRect();
            const elementTop = rect.top + window.pageYOffset;
            const elementCenter = elementTop - (window.innerHeight / 2) + (rect.height / 2);
            
            // Check if element is already in view
            const isInView = rect.top >= 0 && rect.bottom <= window.innerHeight;
            
            if (!isInView) {
              window.scrollTo({
                top: elementCenter,
                behavior: 'smooth'
              });
              console.log('[ChatDialog] Window scroll executed as fallback');
            }
          } catch (e) {
            console.warn('[ChatDialog] Window scroll failed:', e);
          }
        });
        
        // Method 3: Handle scrollable containers
        requestAnimationFrame(() => {
          try {
            let parent = element.parentElement;
            while (parent && parent !== document.body) {
              const parentStyle = window.getComputedStyle(parent);
              const overflowY = parentStyle.overflowY;
              
              if (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay') {
                const parentRect = parent.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                const elementTopRelative = elementRect.top - parentRect.top + parent.scrollTop;
                const scrollTarget = elementTopRelative - (parentRect.height / 2) + (elementRect.height / 2);
                
                parent.scrollTo({
                  top: scrollTarget,
                  behavior: 'smooth'
                });
                console.log('[ChatDialog] Scrolled scrollable container');
                break;
              }
              
              parent = parent.parentElement;
            }
          } catch (e) {
            console.warn('[ChatDialog] Container scroll failed:', e);
          }
        });
      };
      
      // Wait a frame to ensure styles are applied, then scroll
      requestAnimationFrame(() => {
        scrollToElement(bestMatch);
      });
      
      // Return the matched element so it can be stored for toggle functionality
      this._lastHighlightedElement = bestMatch;
      
      console.log('[ChatDialog] Found and highlighted element:', bestMatch.tagName, 'with score:', bestMatchScore, 'for substring:', substring);
      return bestMatch;
    } else {
      console.warn('[ChatDialog] ===== NO MATCH FOUND =====');
      console.warn('[ChatDialog] Could not find matching element for substring:', substring);
      console.warn('[ChatDialog] Best score achieved:', bestMatchScore, '(minimum required: 20)');
      if (bestMatch) {
        console.warn('[ChatDialog] Best match element (score too low):', bestMatch.tagName, bestMatch.className);
      }
      return null;
    }
  },
  
  /**
   * Get all text nodes in the document
   * @param {Node} root - Root node to search from
   * @returns {Array<Node>} Array of text nodes
   */
  getTextNodes(root) {
    const textNodes = [];
    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    
    return textNodes;
  },
  
  /**
   * Remove all reference highlights with smooth fade-out animation
   */
  removeReferenceHighlights() {
    const highlighted = document.querySelectorAll('.vocab-reference-highlight');
    highlighted.forEach(elem => {
      // Add fade-out class for smooth transition
      elem.classList.add('vocab-reference-highlight-removing');
      
      // Remove the highlight class after animation completes
      setTimeout(() => {
        elem.classList.remove('vocab-reference-highlight', 'vocab-reference-highlight-removing');
      }, 400); // Match animation duration
    });
    // Clear active reference tracking when highlights are removed
    this._activeReferenceId = null;
  },
  
  /**
   * Attach click handlers to reference markers in a container
   * @param {HTMLElement} container - Container element to search for reference markers
   */
  attachReferenceMarkerHandlers(container) {
    console.log('[ChatDialog] attachReferenceMarkerHandlers called');
    console.log('[ChatDialog] Container:', container);
    console.log('[ChatDialog] Container tag:', container ? container.tagName : 'null');
    console.log('[ChatDialog] Container class:', container ? container.className : 'null');
    
    if (!container) {
      console.warn('[ChatDialog] No container provided to attachReferenceMarkerHandlers');
      return;
    }
    
    // Initialize active reference tracking if not exists
    if (!this._activeReferenceId) {
      this._activeReferenceId = null;
    }
    
    // Store reference to element for each refId to enable scrolling even when toggling
    if (!this._referenceElements) {
      this._referenceElements = new Map();
    }
    
    // Query for all reference marker and button classes
    const markers = container.querySelectorAll('.vocab-reference-marker, .vocab-ref-button, .vocab-ref-button-circular');
    console.log('[ChatDialog] Found', markers.length, 'reference markers/buttons in container');
    
    if (markers.length === 0) {
      // Try to find buttons in the entire document to debug
      const allButtons = document.querySelectorAll('.vocab-ref-button-circular');
      console.log('[ChatDialog] Total vocab-ref-button-circular buttons in document:', allButtons.length);
      if (allButtons.length > 0) {
        console.log('[ChatDialog] First button found:', allButtons[0]);
        console.log('[ChatDialog] First button classes:', allButtons[0].className);
        console.log('[ChatDialog] First button parent:', allButtons[0].parentElement);
        console.log('[ChatDialog] Container contains first button?', container.contains(allButtons[0]));
      }
    }
    
    markers.forEach((marker, index) => {
      console.log(`[ChatDialog] Processing marker ${index + 1}/${markers.length}:`, marker);
      // Remove existing listeners by cloning
      const newMarker = marker.cloneNode(true);
      marker.parentNode.replaceChild(newMarker, marker);
      
      console.log(`[ChatDialog] Attached click handler to marker ${index + 1}`);
      console.log(`[ChatDialog] Marker classes:`, newMarker.className);
      console.log(`[ChatDialog] Marker data-ref-id:`, newMarker.getAttribute('data-ref-id'));
      console.log(`[ChatDialog] Marker data-substring:`, newMarker.getAttribute('data-substring'));
      
      // Add click handler
      newMarker.addEventListener('click', (e) => {
        console.log('[ChatDialog] ===== CLICK EVENT FIRED =====');
        console.log('[ChatDialog] Event target:', e.target);
        console.log('[ChatDialog] Event currentTarget:', e.currentTarget);
        e.preventDefault();
        e.stopPropagation();
        
        const refId = newMarker.getAttribute('data-ref-id');
        const substring = newMarker.getAttribute('data-substring');
        const refNumber = newMarker.getAttribute('data-ref-number');
        
        console.log('========================================');
        console.log('[ChatDialog] ===== REF BUTTON CLICKED =====');
        console.log('[ChatDialog] Ref Button Number:', refNumber);
        console.log('[ChatDialog] Ref ID:', refId);
        console.log('[ChatDialog] Substring from button:', substring);
        console.log('[ChatDialog] Substring length:', substring ? substring.length : 0);
        console.log('[ChatDialog] Substring preview:', substring ? substring.substring(0, 100) : 'null');
        
        if (!substring) {
          console.warn('[ChatDialog] No substring found in ref button!');
          return;
        }
        
        // Check if this is the same button that's currently active
        const isCurrentlyActive = this._activeReferenceId === refId;
        const hasHighlights = document.querySelectorAll('.vocab-reference-highlight').length > 0;
        const storedElement = this._referenceElements.get(refId);
        
        console.log('[ChatDialog] Is currently active:', isCurrentlyActive);
        console.log('[ChatDialog] Has existing highlights:', hasHighlights);
        console.log('[ChatDialog] Stored element exists:', !!storedElement);
        
        // If same button clicked and highlights exist, toggle off (remove highlights)
        if (isCurrentlyActive && hasHighlights) {
          console.log('[ChatDialog] Toggling OFF highlight...');
          // Remove highlights
          this.removeReferenceHighlights();
          this._activeReferenceId = null;
          
          // Still scroll to the element even when toggling off (if we have it stored)
          if (storedElement && storedElement.parentNode) {
            console.log('[ChatDialog] Scrolling to stored element (toggle off):');
            console.log('[ChatDialog] Element tag:', storedElement.tagName);
            console.log('[ChatDialog] Element class:', storedElement.className);
            console.log('[ChatDialog] Element ID:', storedElement.id);
            console.log('[ChatDialog] Element text preview:', (storedElement.innerText || storedElement.textContent || '').substring(0, 100));
            console.log('[ChatDialog] Element HTML:', storedElement.outerHTML.substring(0, 200));
            storedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          } else {
            console.warn('[ChatDialog] No stored element found for scrolling (toggle off)');
          }
          
          console.log('[ChatDialog] Toggled off highlight for reference:', refId);
        } else {
          console.log('[ChatDialog] Searching for element to highlight...');
          // Different button or no highlights - do normal highlight flow
          const highlightedElement = this.scrollToAndHighlightParagraph(substring);
          this._activeReferenceId = refId;
          
          // Store the highlighted element for this refId so we can scroll to it later
          if (highlightedElement) {
            this._referenceElements.set(refId, highlightedElement);
            console.log('[ChatDialog] ===== ELEMENT FOUND AND HIGHLIGHTED =====');
            console.log('[ChatDialog] Element tag:', highlightedElement.tagName);
            console.log('[ChatDialog] Element class:', highlightedElement.className);
            console.log('[ChatDialog] Element ID:', highlightedElement.id);
            console.log('[ChatDialog] Element text content:', highlightedElement.innerText || highlightedElement.textContent || '');
            console.log('[ChatDialog] Element text length:', (highlightedElement.innerText || highlightedElement.textContent || '').length);
            console.log('[ChatDialog] Element HTML (first 500 chars):', highlightedElement.outerHTML.substring(0, 500));
            console.log('[ChatDialog] Element will be auto-scrolled to view');
          } else {
            console.warn('[ChatDialog] ===== NO ELEMENT FOUND =====');
            console.warn('[ChatDialog] Could not find matching element for substring:', substring);
          }
          
          console.log('[ChatDialog] Highlighted reference:', refId);
        }
        console.log('========================================');
      });
    });
    
    // Add event delegation on document as fallback to catch clicks on buttons
    // even if they're created dynamically after handlers are attached
    if (!this._referenceDelegationHandler) {
      console.log('[ChatDialog] Setting up document-level event delegation for ref buttons');
      this._referenceDelegationHandler = (e) => {
        // Check if click is on a reference button
        const clickedButton = e.target.closest('.vocab-ref-button-circular, .vocab-ref-button, .vocab-reference-marker');
        if (clickedButton) {
          console.log('[ChatDialog] ===== DELEGATION: Ref button clicked =====');
          console.log('[ChatDialog] Clicked button:', clickedButton);
          console.log('[ChatDialog] Button classes:', clickedButton.className);
          
          e.preventDefault();
          e.stopPropagation();
          
          const refId = clickedButton.getAttribute('data-ref-id');
          const substring = clickedButton.getAttribute('data-substring');
          const refNumber = clickedButton.getAttribute('data-ref-number');
          
          console.log('[ChatDialog] Ref ID:', refId);
          console.log('[ChatDialog] Substring:', substring);
          console.log('[ChatDialog] Ref Number:', refNumber);
          
          if (!substring) {
            console.warn('[ChatDialog] No substring found in clicked button');
            return;
          }
          
          // Check if this is the same button that's currently active
          const isCurrentlyActive = this._activeReferenceId === refId;
          const hasHighlights = document.querySelectorAll('.vocab-reference-highlight').length > 0;
          const storedElement = this._referenceElements ? this._referenceElements.get(refId) : null;
          
          console.log('[ChatDialog] Is currently active:', isCurrentlyActive);
          console.log('[ChatDialog] Has existing highlights:', hasHighlights);
          console.log('[ChatDialog] Stored element exists:', !!storedElement);
          
          // If same button clicked and highlights exist, toggle off (remove highlights)
          if (isCurrentlyActive && hasHighlights) {
            console.log('[ChatDialog] Toggling OFF highlight (delegation)...');
            this.removeReferenceHighlights();
            this._activeReferenceId = null;
            
            // Still scroll to the element even when toggling off
            if (storedElement && storedElement.parentNode) {
              console.log('[ChatDialog] Scrolling to stored element (toggle off, delegation)');
              storedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          } else {
            console.log('[ChatDialog] Searching for element to highlight (delegation)...');
            const highlightedElement = this.scrollToAndHighlightParagraph(substring);
            this._activeReferenceId = refId;
            
            if (highlightedElement) {
              if (!this._referenceElements) {
                this._referenceElements = new Map();
              }
              this._referenceElements.set(refId, highlightedElement);
              console.log('[ChatDialog] Element found and stored (delegation)');
            }
          }
        } else {
          // Check if click is outside reference markers - remove highlights
          if (!e.target.closest('.vocab-reference-marker, .vocab-ref-button, .vocab-ref-button-circular')) {
            this.removeReferenceHighlights();
          }
        }
      };
      
      // Use capture phase to catch events early
      document.addEventListener('click', this._referenceDelegationHandler, true);
      console.log('[ChatDialog] Document-level event delegation handler attached');
    }
    
    // Add click handler to document to remove highlights when clicking elsewhere
    const removeHighlightHandler = (e) => {
      // Check if click is on a reference marker or button
      if (!e.target.closest('.vocab-reference-marker, .vocab-ref-button, .vocab-ref-button-circular')) {
        this.removeReferenceHighlights();
        document.removeEventListener('click', removeHighlightHandler);
      }
    };
    
    // Remove old listener if exists
    if (this._referenceHighlightHandler) {
      document.removeEventListener('click', this._referenceHighlightHandler);
    }
    
    this._referenceHighlightHandler = removeHighlightHandler;
    // Use setTimeout to avoid immediate trigger
    setTimeout(() => {
      document.addEventListener('click', removeHighlightHandler);
    }, 100);
  },
  
  /**
   * Simple markdown renderer
   * @param {string} text - Markdown text
   * @returns {string} HTML string
   */
  renderMarkdown(text) {
    if (!text) return '';
    
    let html = text;
    
    // Parse reference markers first (before escaping HTML)
    html = this.parseReferenceMarkers(html);
    
    // Escape HTML (but preserve the reference marker HTML we just added)
    // We need to escape only the parts that aren't already HTML
    // This is a bit tricky - we'll escape, then parse references again
    // Actually, let's parse references after escaping to avoid issues
    // Let me rethink this...
    
    // Better approach: parse references, then escape the remaining text
    // But we already parsed references above, so we need to protect them
    // Let's use a placeholder approach
    
    // Store reference markers and buttons temporarily
    const refPlaceholders = [];
    // Handle old span markers and new button markers (both rectangular and circular)
    html = html.replace(/<(span|button) class="vocab-(?:reference-marker|ref-button(?:-circular)?)"[^>]*>(\d+)<\/(span|button)>/g, (match, tag1, num, tag2) => {
      const placeholder = `__REF_PLACEHOLDER_${refPlaceholders.length}__`;
      refPlaceholders.push(match);
      return placeholder;
    });
    
    // Escape HTML
    html = html.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;');
    
    // Restore reference markers
    refPlaceholders.forEach((placeholder, index) => {
      html = html.replace(`__REF_PLACEHOLDER_${index}__`, placeholder);
    });
    
    // Code blocks (```)
    html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
    
    // Inline code (`)
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Bold (**text** or __text__)
    html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    
    // Italic (*text* or _text_)
    html = html.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
    html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
    
    // Links [text](url)
    html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
    
    // Headings
    html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
    
    // Line breaks
    html = html.replace(/\n\n/g, '<br><br>');
    html = html.replace(/\n/g, '<br>');
    
    // Lists
    html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
    html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
    
    // Wrap consecutive <li> in <ul>
    html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
    
    return html;
  },
  
  /**
   * Clear chat history (but preserve summary if it exists)
   * Summary is stored separately and displayed above the button, not in chat history
   */
  clearChat() {
    const chatContainer = document.getElementById('vocab-chat-messages');
    
    // Summary is stored separately in pageSummary variable and displayed above button
    // It's NOT in chat history, so we don't need to preserve it here
    // The summary container is separate from chat messages
    
    chatContainer.innerHTML = '';
    
    // Show appropriate message based on chat context
    const promptText = this.chatContext === 'selected' 
      ? 'Ask anything on the selected content' 
      : 'Ask anything about the page';
    
    const noChatsMsg = document.createElement('div');
    noChatsMsg.className = 'vocab-chat-no-messages';
    noChatsMsg.innerHTML = `
      <div class="vocab-chat-no-messages-content">
        ${this.createChatEmptyIcon()}
        <span>${promptText}</span>
      </div>
    `;
    chatContainer.appendChild(noChatsMsg);
    
    // Clear chat history (but keep pageSummary variable - it's separate)
    this.chatHistory = [];
    
    // Update stored chat history for this textKey (but keep pageSummary)
    if (this.currentTextKey) {
      this.chatHistories.set(this.currentTextKey, []);
    }
    
    // Hide global clear button if no messages
    // Note: Summary is separate, so we only check chatHistory
    this.updateGlobalClearButton();
    
    console.log('[ChatDialog] Chat cleared (summary is separate and preserved)');
  },
  
  /**
   * Update visibility of delete conversation button
   */
  updateGlobalClearButton() {
    const deleteBtn = document.getElementById('vocab-chat-delete-conversation-btn');
    if (!deleteBtn) return;
    
    // Show button if there are messages OR if there's a summary
    // (Summary is preserved separately, so we check both)
    if (this.chatHistory.length > 0 || this.pageSummary) {
      deleteBtn.style.setProperty('display', 'flex', 'important');
      deleteBtn.classList.remove('hidden');
    } else {
      deleteBtn.style.setProperty('display', 'none', 'important');
      deleteBtn.classList.add('hidden');
    }
  },
  
  /**
   * Show dialog
   */
  show() {
    console.log('[ChatDialog] ===== SHOW FUNCTION CALLED =====');
    console.log('[ChatDialog] Dialog container exists:', !!this.dialogContainer);
    if (this.dialogContainer) {
      console.log('[ChatDialog] Setting isOpen to true');
      this.isOpen = true;
      
      // Check if we should expand from book icon (only for selected text chat with textKey)
      const shouldExpandFromBook = this.currentTextKey && this.chatContext === 'selected';
      
      // Check if we should expand from ask-about-page button (for page-general context)
      const shouldExpandFromAskAboutPage = this.currentTextKey && this.chatContext === 'general' && 
        (this.currentTextKey === 'page-general' || this.currentTextKey.startsWith('page-general'));
      
      if (shouldExpandFromBook) {
        console.log('[ChatDialog] Opening from book icon - setting up expansion animation');
        
        // Find the book icon - try multiple strategies
        let bookIcon = null;
        let iconsWrapper = null;
        
        // Strategy 1: Try exact match with currentTextKey (use safe method to avoid CSS selector issues)
        const allIconsWrappersForExpansion = document.querySelectorAll('.vocab-text-icons-wrapper');
        for (const wrapper of allIconsWrappersForExpansion) {
          const wrapperTextKey = wrapper.getAttribute('data-text-key');
          if (wrapperTextKey === this.currentTextKey) {
            iconsWrapper = wrapper;
            bookIcon = iconsWrapper.querySelector('.vocab-text-book-btn');
            if (bookIcon) {
              console.log('[ChatDialog] Found book icon with exact currentTextKey:', this.currentTextKey);
              break;
            }
          }
        }
        
        // Strategy 2: Try variations of currentTextKey
        if (!bookIcon) {
          const textKeysToTry = [this.currentTextKey];
          
          // Remove -selected suffix if present
          if (this.currentTextKey.endsWith('-selected')) {
            textKeysToTry.push(this.currentTextKey.replace(/-selected$/, ''));
          }
          
          // Try extracting base key from format: contentType-tabId-startIndex-length
          const parts = this.currentTextKey.split('-');
          if (parts.length >= 4) {
            // Try: contentType-tabId-startIndex-length
            textKeysToTry.push(this.currentTextKey);
            // Try: contentType-tabId-startIndex (without length)
            if (parts.length >= 3) {
              textKeysToTry.push(parts.slice(0, -1).join('-'));
            }
          }
          
          for (const textKey of textKeysToTry) {
            if (textKey === this.currentTextKey) continue; // Already tried
            for (const wrapper of allIconsWrappersForExpansion) {
              const wrapperTextKey = wrapper.getAttribute('data-text-key');
              if (wrapperTextKey === textKey) {
                iconsWrapper = wrapper;
                bookIcon = iconsWrapper.querySelector('.vocab-text-book-btn');
                if (bookIcon) {
                  console.log('[ChatDialog] Found book icon with textKey variation:', textKey);
                  break;
                }
              }
            }
            if (bookIcon) break;
          }
        }
        
        // Strategy 3: Search all book icons and match by simplifiedData if available
        if (!bookIcon && this.simplifiedData) {
          console.log('[ChatDialog] Trying to find book icon by matching simplifiedData...');
          const allIconsWrappers = document.querySelectorAll('.vocab-text-icons-wrapper');
          for (const wrapper of allIconsWrappers) {
            const wrapperTextKey = wrapper.getAttribute('data-text-key');
            const simplifiedData = TextSelector.simplifiedTexts.get(wrapperTextKey);
            if (simplifiedData && 
                simplifiedData.textStartIndex === this.simplifiedData.textStartIndex &&
                simplifiedData.textLength === this.simplifiedData.textLength) {
              bookIcon = wrapper.querySelector('.vocab-text-book-btn');
              if (bookIcon) {
                console.log('[ChatDialog] Found book icon by matching simplifiedData with textKey:', wrapperTextKey);
                iconsWrapper = wrapper;
                break;
              }
            }
          }
        }
        
        // Strategy 4: Retry finding book icon with a small delay if not found (for auto-open case)
        if (!bookIcon && this.simplifiedData) {
          console.log('[ChatDialog] Book icon not found immediately, retrying after short delay...');
          // Wait a bit and try again (book icon might still be animating in)
          setTimeout(() => {
            const allIconsWrappers = document.querySelectorAll('.vocab-text-icons-wrapper');
            for (const wrapper of allIconsWrappers) {
              const wrapperTextKey = wrapper.getAttribute('data-text-key');
              const simplifiedData = TextSelector.simplifiedTexts.get(wrapperTextKey);
              if (simplifiedData && 
                  simplifiedData.textStartIndex === this.simplifiedData.textStartIndex &&
                  simplifiedData.textLength === this.simplifiedData.textLength) {
                const retryBookIcon = wrapper.querySelector('.vocab-text-book-btn');
                if (retryBookIcon && this.dialogContainer && this.dialogContainer.classList.contains('expanding')) {
                  console.log('[ChatDialog] Found book icon on retry, updating animation...');
                  // Update animation if dialog is still expanding
                  const bookIconRect = retryBookIcon.getBoundingClientRect();
                  const bookIconCenterX = bookIconRect.left + bookIconRect.width / 2;
                  const bookIconCenterY = bookIconRect.top + retryBookIcon.height / 2;
                  
                  const dialogRect = this.dialogContainer.getBoundingClientRect();
                  const dialogHeight = dialogRect.height || 600;
                  const viewportHeight = window.innerHeight;
                  const dialogTop = viewportHeight / 2;
                  const targetCenterY = bookIconCenterY;
                  const translateYOffset = targetCenterY - dialogTop;
                  const finalTranslateY = -dialogHeight / 2 + translateYOffset;
                  
                  const dialogWidth = dialogRect.width || 400;
                  const dialogCenterX = window.innerWidth - dialogWidth / 2;
                  const targetX = bookIconCenterX - dialogCenterX;
                  
                  const startTransform = `translateY(${finalTranslateY}px) translateX(${targetX}px) scale(0)`;
                  this.dialogContainer.style.setProperty('--expand-start-transform', startTransform);
                  this.dialogContainer.style.setProperty('--expand-end-transform', 'translateY(-50%) translateX(0) scale(1)');
                  this.dialogContainer.style.setProperty('transform', startTransform);
                  break;
                }
              }
            }
          }, 100);
        }
        
        // Check for Summarise button first, then home-options-btn if textKey is 'page-general' (for book icon context)
        let homeOptionsButton = null;
        let summariseButton = null;
        if (this.currentTextKey === 'page-general' || this.currentTextKey.startsWith('page-general')) {
          // Prioritize Summarise button (the menu item that was clicked)
          summariseButton = document.getElementById('home-options-summarise-btn');
          if (summariseButton) {
            console.log('[ChatDialog] ✓✓✓ FOUND SUMMARISE BUTTON! Starting expansion animation...');
          } else {
            // Fallback to home-options-btn
            homeOptionsButton = document.getElementById('home-options-btn');
            if (homeOptionsButton) {
              console.log('[ChatDialog] ✓✓✓ FOUND HOME-OPTIONS BUTTON! Starting expansion animation...');
            }
          }
        }
        
        if (bookIcon) {
          console.log('[ChatDialog] ✓✓✓ FOUND BOOK ICON! Starting expansion animation...');
          
          // Get book icon position
          const bookIconRect = bookIcon.getBoundingClientRect();
          const bookIconCenterX = bookIconRect.left + bookIconRect.width / 2;
          const bookIconCenterY = bookIconRect.top + bookIconRect.height / 2;
          
          // Get dialog dimensions
          const dialogRect = this.dialogContainer.getBoundingClientRect();
          const dialogHeight = dialogRect.height || 600;
          const viewportHeight = window.innerHeight;
          const dialogTop = viewportHeight / 2;
          const currentCenterY = dialogTop;
          const targetCenterY = bookIconCenterY;
          const translateYOffset = targetCenterY - currentCenterY;
          const finalTranslateY = -dialogHeight / 2 + translateYOffset;
          
          // Calculate target X (book icon center X - dialog center X)
          const dialogWidth = dialogRect.width || 400;
          const dialogCenterX = window.innerWidth - dialogWidth / 2;
          const targetX = bookIconCenterX - dialogCenterX;
          
          // Set initial position at book icon (small scale)
          const startTransform = `translateY(${finalTranslateY}px) translateX(${targetX}px) scale(0)`;
          this.dialogContainer.style.setProperty('transform', startTransform);
          this.dialogContainer.style.setProperty('transition', 'none');
          
          // Set CSS variables for expansion animation
          this.dialogContainer.style.setProperty('--expand-target-x', `${targetX}px`);
          this.dialogContainer.style.setProperty('--expand-target-y', `${finalTranslateY}px`);
          this.dialogContainer.style.setProperty('--expand-start-transform', startTransform);
          this.dialogContainer.style.setProperty('--expand-end-transform', 'translateY(-50%) translateX(0) scale(1)');
          
          // Force a reflow to ensure initial position is set
          this.dialogContainer.offsetHeight;
          
          // Add expanding class to trigger animation
          this.dialogContainer.classList.add('expanding');
          
          // Add visible class immediately (but animation will override transform)
          this.dialogContainer.classList.add('visible');
          
          // Remove expanding class after animation completes and restore normal state
          setTimeout(() => {
            // Set final transform explicitly to ensure dialog stays in position
            this.dialogContainer.style.setProperty('transform', 'translateY(-50%) translateX(0) scale(1)');
            // Remove expanding class after transform is set
            this.dialogContainer.classList.remove('expanding');
            // Restore transition for normal interactions
            this.dialogContainer.style.setProperty('transition', '');
            // Clean up CSS variables
            this.dialogContainer.style.removeProperty('--expand-target-x');
            this.dialogContainer.style.removeProperty('--expand-target-y');
            this.dialogContainer.style.removeProperty('--expand-start-transform');
            this.dialogContainer.style.removeProperty('--expand-end-transform');
            // Re-enable pointer events
            this.dialogContainer.style.setProperty('pointer-events', '');
            this.dialogContainer.style.setProperty('will-change', '');
          }, 300); // 0.3s animation duration (same as appearing animation)
        } else if (summariseButton) {
          console.log('[ChatDialog] ✓✓✓ FOUND SUMMARISE BUTTON! Starting expansion animation...');
          
          // Get Summarise button position
          const buttonRect = summariseButton.getBoundingClientRect();
          const buttonCenterX = buttonRect.left + buttonRect.width / 2;
          const buttonCenterY = buttonRect.top + buttonRect.height / 2;
          
          // Get dialog dimensions
          const dialogRect = this.dialogContainer.getBoundingClientRect();
          const dialogHeight = dialogRect.height || 600;
          const viewportHeight = window.innerHeight;
          const dialogTop = viewportHeight / 2;
          const currentCenterY = dialogTop;
          const targetCenterY = buttonCenterY;
          const translateYOffset = targetCenterY - currentCenterY;
          const finalTranslateY = -dialogHeight / 2 + translateYOffset;
          
          // Calculate target X (button center X - dialog center X)
          const dialogWidth = dialogRect.width || 400;
          const dialogCenterX = window.innerWidth - dialogWidth / 2;
          const targetX = buttonCenterX - dialogCenterX;
          
          // Set initial position at button (small scale)
          const startTransform = `translateY(${finalTranslateY}px) translateX(${targetX}px) scale(0)`;
          this.dialogContainer.style.setProperty('transform', startTransform);
          this.dialogContainer.style.setProperty('transition', 'none');
          
          // Set CSS variables for expansion animation
          this.dialogContainer.style.setProperty('--expand-target-x', `${targetX}px`);
          this.dialogContainer.style.setProperty('--expand-target-y', `${finalTranslateY}px`);
          this.dialogContainer.style.setProperty('--expand-start-transform', startTransform);
          this.dialogContainer.style.setProperty('--expand-end-transform', 'translateY(-50%) translateX(0) scale(1)');
          
          // Force a reflow to ensure initial position is set
          this.dialogContainer.offsetHeight;
          
          // Add expanding class to trigger animation
          this.dialogContainer.classList.add('expanding');
          
          // Add visible class immediately (but animation will override transform)
          this.dialogContainer.classList.add('visible');
          
          // Remove expanding class after animation completes and restore normal state
          setTimeout(() => {
            // Set final transform explicitly to ensure dialog stays in position
            this.dialogContainer.style.setProperty('transform', 'translateY(-50%) translateX(0) scale(1)');
            // Remove expanding class after transform is set
            this.dialogContainer.classList.remove('expanding');
            // Restore transition for normal interactions
            this.dialogContainer.style.setProperty('transition', '');
            // Clean up CSS variables
            this.dialogContainer.style.removeProperty('--expand-target-x');
            this.dialogContainer.style.removeProperty('--expand-target-y');
            this.dialogContainer.style.removeProperty('--expand-start-transform');
            this.dialogContainer.style.removeProperty('--expand-end-transform');
            // Re-enable pointer events
            this.dialogContainer.style.setProperty('pointer-events', '');
            this.dialogContainer.style.setProperty('will-change', '');
          }, 300); // 0.3s animation duration (same as appearing animation)
        } else if (homeOptionsButton) {
          console.log('[ChatDialog] ✓✓✓ FOUND HOME-OPTIONS BUTTON! Starting expansion animation...');
          
          // Get home-options button position
          const buttonRect = homeOptionsButton.getBoundingClientRect();
          const buttonCenterX = buttonRect.left + buttonRect.width / 2;
          const buttonCenterY = buttonRect.top + buttonRect.height / 2;
          
          // Get dialog dimensions
          const dialogRect = this.dialogContainer.getBoundingClientRect();
          const dialogHeight = dialogRect.height || 600;
          const viewportHeight = window.innerHeight;
          const dialogTop = viewportHeight / 2;
          const currentCenterY = dialogTop;
          const targetCenterY = buttonCenterY;
          const translateYOffset = targetCenterY - currentCenterY;
          const finalTranslateY = -dialogHeight / 2 + translateYOffset;
          
          // Calculate target X (button center X - dialog center X)
          const dialogWidth = dialogRect.width || 400;
          const dialogCenterX = window.innerWidth - dialogWidth / 2;
          const targetX = buttonCenterX - dialogCenterX;
          
          // Set initial position at button (small scale)
          const startTransform = `translateY(${finalTranslateY}px) translateX(${targetX}px) scale(0)`;
          this.dialogContainer.style.setProperty('transform', startTransform);
          this.dialogContainer.style.setProperty('transition', 'none');
          
          // Set CSS variables for expansion animation
          this.dialogContainer.style.setProperty('--expand-target-x', `${targetX}px`);
          this.dialogContainer.style.setProperty('--expand-target-y', `${finalTranslateY}px`);
          this.dialogContainer.style.setProperty('--expand-start-transform', startTransform);
          this.dialogContainer.style.setProperty('--expand-end-transform', 'translateY(-50%) translateX(0) scale(1)');
          
          // Force a reflow to ensure initial position is set
          this.dialogContainer.offsetHeight;
          
          // Add expanding class to trigger animation
          this.dialogContainer.classList.add('expanding');
          
          // Add visible class immediately (but animation will override transform)
          this.dialogContainer.classList.add('visible');
          
          // Remove expanding class after animation completes and restore normal state
          setTimeout(() => {
            // Set final transform explicitly to ensure dialog stays in position
            this.dialogContainer.style.setProperty('transform', 'translateY(-50%) translateX(0) scale(1)');
            // Remove expanding class after transform is set
            this.dialogContainer.classList.remove('expanding');
            // Restore transition for normal interactions
            this.dialogContainer.style.setProperty('transition', '');
            // Clean up CSS variables
            this.dialogContainer.style.removeProperty('--expand-target-x');
            this.dialogContainer.style.removeProperty('--expand-target-y');
            this.dialogContainer.style.removeProperty('--expand-start-transform');
            this.dialogContainer.style.removeProperty('--expand-end-transform');
            // Re-enable pointer events
            this.dialogContainer.style.setProperty('pointer-events', '');
            this.dialogContainer.style.setProperty('will-change', '');
          }, 300); // 0.3s animation duration (same as appearing animation)
        } else {
          console.log('[ChatDialog] Book icon not found, using normal slide-in animation');
          setTimeout(() => {
            this.dialogContainer.classList.add('visible');
          }, 10);
        }
      } else if (shouldExpandFromAskAboutPage) {
        // Expand from ask-about-page button
        console.log('[ChatDialog] Opening from ask-about-page button - setting up expansion animation');
        
        const askAboutPageButton = document.getElementById('vocab-ask-about-page-btn');
        if (askAboutPageButton) {
          console.log('[ChatDialog] ✓✓✓ FOUND ASK-ABOUT-PAGE BUTTON! Starting expansion animation...');
          
          // Get ask-about-page button position
          const buttonRect = askAboutPageButton.getBoundingClientRect();
          const buttonCenterX = buttonRect.left + buttonRect.width / 2;
          const buttonCenterY = buttonRect.top + buttonRect.height / 2;
          
          // Get dialog dimensions
          const dialogRect = this.dialogContainer.getBoundingClientRect();
          const dialogHeight = dialogRect.height || 600;
          const viewportHeight = window.innerHeight;
          const dialogTop = viewportHeight / 2;
          const currentCenterY = dialogTop;
          const targetCenterY = buttonCenterY;
          const translateYOffset = targetCenterY - currentCenterY;
          const finalTranslateY = -dialogHeight / 2 + translateYOffset;
          
          // Calculate target X (button center X - dialog center X)
          const dialogWidth = dialogRect.width || 400;
          const dialogCenterX = window.innerWidth - dialogWidth / 2;
          const targetX = buttonCenterX - dialogCenterX;
          
          // Set initial position at button (small scale)
          const startTransform = `translateY(${finalTranslateY}px) translateX(${targetX}px) scale(0)`;
          this.dialogContainer.style.setProperty('transform', startTransform);
          this.dialogContainer.style.setProperty('transition', 'none');
          
          // Set CSS variables for expansion animation
          this.dialogContainer.style.setProperty('--expand-target-x', `${targetX}px`);
          this.dialogContainer.style.setProperty('--expand-target-y', `${finalTranslateY}px`);
          this.dialogContainer.style.setProperty('--expand-start-transform', startTransform);
          this.dialogContainer.style.setProperty('--expand-end-transform', 'translateY(-50%) translateX(0) scale(1)');
          
          // Force a reflow to ensure initial position is set
          this.dialogContainer.offsetHeight;
          
          // Add expanding class to trigger animation
          this.dialogContainer.classList.add('expanding');
          
          // Add visible class immediately (but animation will override transform)
          this.dialogContainer.classList.add('visible');
          
          // Remove expanding class after animation completes and restore normal state
          setTimeout(() => {
            // Set final transform explicitly to ensure dialog stays in position
            this.dialogContainer.style.setProperty('transform', 'translateY(-50%) translateX(0) scale(1)');
            // Remove expanding class after transform is set
            this.dialogContainer.classList.remove('expanding');
            // Restore transition for normal interactions
            this.dialogContainer.style.setProperty('transition', '');
            // Clean up CSS variables
            this.dialogContainer.style.removeProperty('--expand-target-x');
            this.dialogContainer.style.removeProperty('--expand-target-y');
            this.dialogContainer.style.removeProperty('--expand-start-transform');
            this.dialogContainer.style.removeProperty('--expand-end-transform');
            // Re-enable pointer events
            this.dialogContainer.style.setProperty('pointer-events', '');
            this.dialogContainer.style.setProperty('will-change', '');
          }, 300); // 0.3s animation duration (same as appearing animation)
        } else {
          console.log('[ChatDialog] Ask-about-page button not found, using normal slide-in animation');
          setTimeout(() => {
            this.dialogContainer.classList.add('visible');
          }, 10);
        }
      } else {
        // Normal slide-in animation
        setTimeout(() => {
          console.log('[ChatDialog] Adding visible class to dialog');
          this.dialogContainer.classList.add('visible');
          console.log('[ChatDialog] Dialog should now be visible');
        }, 10);
      }
      
      // Auto-focus the question input for both generic and selected text chat
      setTimeout(() => {
        const questionInput = this.dialogContainer.querySelector('.vocab-chat-input');
        if (questionInput) {
          questionInput.focus();
          console.log(`[ChatDialog] Auto-focused question input for ${this.chatContext} chat`);
        }
      }, 100);
      
      // Auto-scroll to bottom when dialog opens (if there are messages)
      setTimeout(() => {
        const chatContainer = document.getElementById('vocab-chat-messages');
        if (chatContainer && this.chatHistory.length > 0) {
          this.scrollToBottom(chatContainer);
          console.log('[ChatDialog] Auto-scrolled to bottom on dialog open');
        }
      }, 150);
      
      // Ensure focus buttons are hidden/shown based on chat context after dialog is rendered
      setTimeout(() => {
        this.hideFocusButtonsForCustomContent(this.currentTextKey);
      }, 200);
    } else {
      console.log('[ChatDialog] ERROR: Dialog container not found!');
    }
  },
  
  /**
   * Hide dialog
   */
  hide() {
    console.log('[ChatDialog] ===== HIDE FUNCTION CALLED =====');
    console.log('[ChatDialog] Dialog container exists:', !!this.dialogContainer);
    if (this.dialogContainer) {
      console.log('[ChatDialog] Removing visible class from dialog');
      this.dialogContainer.classList.remove('visible');
      console.log('[ChatDialog] Dialog should now be hidden');
    } else {
      console.log('[ChatDialog] ERROR: Dialog container not found for hiding!');
    }
  },
  
  /**
   * Create collapse icon (minus/hyphen icon)
   */
  createCollapseIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M4 10H16" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Calculate common text length between two strings for fuzzy matching
   * @param {string} text1 - First text string
   * @param {string} text2 - Second text string
   * @returns {number} Length of common text
   */
  calculateCommonTextLength(text1, text2) {
    // Remove common suffixes that might differ (like coordinates)
    const cleanText1 = text1.replace(/-\d+-\d+$/, '').trim();
    const cleanText2 = text2.replace(/-\d+-\d+$/, '').trim();
    
    // Find the longest common substring
    let maxLength = 0;
    const len1 = cleanText1.length;
    const len2 = cleanText2.length;
    
    // Use dynamic programming to find longest common substring
    const dp = Array(len1 + 1).fill().map(() => Array(len2 + 1).fill(0));
    
    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        if (cleanText1[i - 1] === cleanText2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
          maxLength = Math.max(maxLength, dp[i][j]);
        } else {
          dp[i][j] = 0;
        }
      }
    }
    
    return maxLength;
  },
  
  /**
   * Create delete icon
   */
  createDeleteIcon() {
    return `
      <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2.25 4.5h13.5M6 4.5V3a1.5 1.5 0 0 1 1.5-1.5h3A1.5 1.5 0 0 1 12 3v1.5m2.25 0v10.5a1.5 1.5 0 0 1-1.5 1.5h-7.5a1.5 1.5 0 0 1-1.5-1.5V4.5h10.5Z" stroke="#ef4444" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M7.5 8.25v4.5M10.5 8.25v4.5" stroke="#ef4444" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Delete the conversation history (clear chat messages)
   * NOTE: This does NOT clear pageSummary - the summary is preserved
   */
  deleteConversation() {
    if (!this.currentTextKey) return;
    
    // IMPORTANT: Do NOT clear pageSummary - preserve it
    // The summary should remain in the variable and UI
    
    // Clear the current chat history
    this.chatHistory = [];
    
    // Clear the stored chat history for this textKey
    this.chatHistories.set(this.currentTextKey, []);
    
    // Clear the chat display (this will preserve the summary in UI)
    this.clearChat();
    
    console.log('[ChatDialog] Conversation history cleared for textKey:', this.currentTextKey, '(summary preserved:', !!this.pageSummary, ')');
  },
  
  /**
   * Create send icon (up arrow) - purple color for wireframe button
   */
  createSendIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 15V5M10 5L5 10M10 5L15 10" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Create stop icon (square purple)
   */
  createStopIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block !important; visibility: visible !important;">
        <rect x="4" y="4" width="12" height="12" fill="#9527F5" stroke="none" style="display: block !important; visibility: visible !important;"/>
      </svg>
    `;
  },
  
  /**
   * Create trash icon - red color for wireframe button
   */
  createTrashIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 5h14M6.5 5V3.5a1.5 1.5 0 0 1 1.5-1.5h4a1.5 1.5 0 0 1 1.5 1.5V5M15 5v10.5a1.5 1.5 0 0 1-1.5 1.5h-7a1.5 1.5 0 0 1-1.5-1.5V5h10Z" stroke="#ef4444" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M8 9v5M12 9v5" stroke="#ef4444" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },
  
  /**
   * Create AI sparkle icon SVG (solid white, for button)
   * @param {number} size - Icon size in pixels (default: 18)
   * @returns {string} SVG markup
   */
  createSparkleIcon(size = 18) {
    return `
      <svg width="${size}" height="${size}" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M14 0L17 8L25 11L17 14L14 22L11 14L3 11L11 8L14 0Z" fill="white"/>
        <path d="M22 16L23.5 20L27.5 21.5L23.5 23L22 27L20.5 23L16.5 21.5L20.5 20L22 16Z" fill="white"/>
        <path d="M8 21L9.5 24.5L13 26L9.5 27.5L8 31L6.5 27.5L3 26L6.5 24.5L8 21Z" fill="white"/>
      </svg>
    `;
  },
  
  /**
   * Create chat empty icon (professional purple)
   */
  createChatEmptyIcon() {
    // Cat icon removed - return empty string
    return '';
  },
  
  /**
   * Inject styles for chat dialog
   */
  injectStyles() {
    const styleId = 'vocab-chat-dialog-styles';
    
    if (document.getElementById(styleId)) {
      return;
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      /* Global button underline prevention */
      button, .vocab-btn, .vocab-chat-tab, .vocab-chat-focus-btn, .vocab-chat-send-btn, .vocab-chat-delete-conversation-btn, .vocab-chat-collapse-btn, .vocab-chat-simplify-more-btn, .vocab-chat-collapse-btn-small, .vocab-chat-delete-conversation-btn-small, .vocab-chat-focus-btn-top-right {
        text-decoration: none !important;
      }
      
      button:hover, .vocab-btn:hover, .vocab-chat-tab:hover, .vocab-chat-focus-btn:hover, .vocab-chat-send-btn:hover, .vocab-chat-delete-conversation-btn:hover, .vocab-chat-collapse-btn:hover, .vocab-chat-simplify-more-btn:hover, .vocab-chat-collapse-btn-small:hover, .vocab-chat-delete-conversation-btn-small:hover, .vocab-chat-focus-btn-top-right:hover {
        text-decoration: none !important;
      }
      
      /* Chat Dialog Container */
      .vocab-chat-dialog {
        position: fixed;
        right: 0;
        top: 50%;
        transform: translateY(-50%) translateX(100%);
        width: 600px !important;
        max-width: 90vw;
        height: 800px !important;
        max-height: 80vh;
        z-index: 2147483647 !important; /* Maximum z-index to ensure chat dialog is always on top of ads and other elements */
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        user-select: none;  /* Disable text selection in popup */
        background: white !important;
        border-radius: 30px 0 0 30px; /* top-left top-right bottom-right bottom-left */
      }
      
      .vocab-chat-dialog.visible {
        transform: translateY(-50%) translateX(0);
      }
      
      /* Minimize Animation - Scale down and move to book icon */
      /* IMPORTANT: When minimizing, completely override all transitions and use animation only */
      .vocab-chat-dialog.minimizing {
        animation: minimizeChatDialogToBook 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important; /* Same duration as appearing animation */
        transition: none !important; /* Completely disable transition during animation */
        pointer-events: none !important;
        z-index: 2147483647 !important; /* Maximum z-index to ensure dialog appears above everything during animation */
        will-change: transform !important; /* Optimize for animation */
      }
      
      /* Completely disable transition when minimizing - even if visible class is present */
      .vocab-chat-dialog.minimizing.visible {
        transition: none !important;
        /* Don't override transform - let animation handle it */
      }

      @keyframes minimizeChatDialogToBook {
        0% {
          transform: var(--minimize-start-transform, translateY(-50%) translateX(0)) scale(1) !important;
          opacity: 1;
        }
        100% {
          transform: var(--minimize-end-transform, translateY(-50%) translateX(0)) scale(0) !important;
          opacity: 1;
        }
      }
      
      /* Expand Animation - Scale up and move from book icon (reverse of minimize) */
      .vocab-chat-dialog.expanding {
        animation: expandChatDialogFromBook 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important; /* Same duration as appearing animation */
        transition: none !important; /* Completely disable transition during animation */
        pointer-events: none !important;
        z-index: 2147483647 !important; /* Maximum z-index to ensure dialog appears above everything during animation */
        will-change: transform !important; /* Optimize for animation */
        opacity: 1 !important;
      }
      
      /* Ensure dialog stays visible after expansion animation */
      .vocab-chat-dialog.expanding.visible {
        animation: expandChatDialogFromBook 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important; /* Same duration as appearing animation */
        transition: none !important;
      }
      
      @keyframes expandChatDialogFromBook {
        0% {
          transform: var(--expand-start-transform, translateY(-50%) translateX(0) scale(0)) !important;
          opacity: 1;
        }
        100% {
          transform: var(--expand-end-transform, translateY(-50%) translateX(0) scale(1)) !important;
          opacity: 1;
        }
      }
      
      /* Dialog Content */
      .vocab-chat-content {
        background: white !important;
        height: 100%;
        border-radius: 30px 0 0 30px; /* top-left top-right bottom-right bottom-left */
        box-shadow: -4px 0 24px rgba(149, 39, 245, 0.2), -2px 0 12px rgba(149, 39, 245, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
      }
      
      /* Collapse Button */
      .vocab-chat-collapse-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 32px;
        height: 32px;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 10;
        transition: all 0.2s ease;
        margin-bottom: 8px;
        text-decoration: none;
      }
      
      .vocab-chat-collapse-btn:hover {
        background: #f9fafb;
        border-color: #9527F5;
        text-decoration: none;
      }
      
      /* Horizontally flip collapse icon to left-pointing arrow */
      .vocab-chat-collapse-btn-small svg {
        transform: scaleX(-1);
      }
      
      /* Left Button Container */
      .vocab-chat-left-buttons {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 10;
      }
      
      /* Small Collapse Button */
      .vocab-chat-collapse-btn-small {
        width: 32px !important;
        height: 32px !important;
        min-width: 32px !important;
        min-height: 32px !important;
        max-width: 32px !important;
        max-height: 32px !important;
        background: white !important;
        border: 1.5px solid #d1d5db !important;
        border-radius: 8px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        transition: all 0.2s ease !important;
        text-decoration: none !important;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08) !important;
        opacity: 0.95 !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        padding: 0 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-chat-collapse-btn-small:hover {
        background: #f3f4f6;
        border-color: #9527F5;
        box-shadow: 0 3px 6px rgba(149, 39, 245, 0.15);
        transform: scale(1.05);
        opacity: 1;
        text-decoration: none;
      }
      
      .vocab-chat-collapse-btn-small:active {
        transform: scale(0.95);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      
      .vocab-chat-collapse-btn-small svg {
        width: 16px !important;
        height: 16px !important;
        min-width: 16px !important;
        min-height: 16px !important;
        max-width: 16px !important;
        max-height: 16px !important;
        opacity: 0.7 !important;
        transition: opacity 0.2s ease !important;
        display: block !important;
        visibility: visible !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-chat-collapse-btn-small svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      .vocab-chat-collapse-btn-small:hover svg {
        opacity: 1;
      }
      
      /* Small Delete Button */
      .vocab-chat-delete-conversation-btn-small {
        width: 24px;
        height: 24px;
        background: white;
        border: 1px solid #ef4444;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
      }
      
      .vocab-chat-delete-conversation-btn-small:hover {
        background: #fef2f2;
        border-color: #dc2626;
        text-decoration: none;
      }
      
      .vocab-chat-delete-conversation-btn-small svg {
        width: 12px;
        height: 12px;
      }
      
      /* Circular Delete Button - Bottom Right */
      .vocab-chat-delete-conversation-btn-circular {
        width: 32px;
        height: 32px;
        background: white;
        border: 2px solid #ef4444;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        flex-shrink: 0;
        margin-left: 8px;
      }
      
      .vocab-chat-delete-conversation-btn-circular:hover {
        background: #fef2f2;
        border-color: #dc2626;
        transform: translateY(-1px);
        text-decoration: none;
      }
      
      .vocab-chat-delete-conversation-btn-circular:active {
        transform: translateY(0) scale(0.95);
      }
      
      .vocab-chat-delete-conversation-btn-circular svg {
        width: 14px;
        height: 14px;
      }
      
      
      /* Focus Button - Top Right */
      .vocab-chat-focus-btn-top-right {
        position: absolute !important;
        top: 20px !important;
        right: 20px !important;
        padding: 6px 12px !important;
        background: #9527F5 !important;
        border: none !important;
        border-radius: 6px !important;
        display: flex !important;
        flex-direction: row !important;
        align-items: center !important;
        justify-content: center !important;
        gap: 6px !important;
        cursor: pointer !important;
        z-index: 10 !important;
        transition: all 0.2s ease !important;
        font-size: 12px !important;
        font-weight: 500 !important;
        color: white !important;
        text-decoration: none !important;
        width: auto !important;
        height: auto !important;
        min-width: auto !important;
        min-height: auto !important;
        max-width: none !important;
        max-height: none !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-chat-focus-btn-top-right:hover {
        background: #7a1fd9;
        text-decoration: none;
      }
      
      .vocab-chat-focus-btn-top-right svg {
        flex-shrink: 0 !important;
        display: inline-block !important;
        width: 16px !important;
        height: 16px !important;
        order: 1 !important;
      }
      
      .vocab-chat-focus-btn-top-right span {
        font-size: 12px;
        font-weight: 500;
        color: white;
        order: 2 !important;
        display: inline-block !important;
      }
      
      /* Tabs */
      .vocab-chat-tabs {
        display: flex;
        gap: 0;
        padding: 12px 60px 0px 60px;
        border-bottom: 1px solid #e5e7eb;
        width: 100%;
        box-sizing: border-box;
        position: relative;
      }
      
      .vocab-chat-tab {
        flex: 1;
        padding: 10px 8px 12px 8px;
        border: none;
        background: transparent;
        border-radius: 0;
        font-size: 12px;
        font-weight: 600;
        color: #6b7280;
        cursor: pointer;
        transition: color 0.2s ease, background-color 0.2s ease;
        letter-spacing: 0.5px;
        text-align: center;
        margin: 0 4px;
        min-width: 0;
        position: relative;
        text-decoration: none;
      }
      
      .vocab-chat-tab:first-child {
        margin-left: 0;
      }
      
      .vocab-chat-tab:last-child {
        margin-right: 0;
      }
      
      .vocab-chat-tab.active {
        color: #9527F5;
      }
      
      .vocab-chat-tab:hover:not(.active) {
        color: #9ca3af;
        text-decoration: none;
      }
      
      /* Sliding tab indicator */
      .vocab-chat-tab-indicator {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 3px;
        background: #9527F5;
        border-radius: 3px 3px 0 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1;
      }
      
      /* Content Area */
      .vocab-chat-content-area {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        padding-top: 50px; /* Add padding to account for focus button */
      }
      
      .vocab-chat-tab-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: none;
        flex-direction: column;
        background: white !important;
      }
      
      .vocab-chat-tab-content.active {
        display: flex;
      }
      
      /* Tab content sliding animations */
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      
      @keyframes slideOutRight {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(-20px);
        }
      }
      
      .vocab-chat-tab-content.slide-in {
        animation: slideIn 0.3s ease-out;
      }
      
      .vocab-chat-tab-content.slide-out-right {
        animation: slideOutRight 0.3s ease-out;
      }
      
      /* Scrollable Content Container */
      .vocab-chat-scrollable-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 #f1f5f9;
        background: white !important;
      }
      
      .vocab-chat-scrollable-content::-webkit-scrollbar {
        width: 6px;
      }
      
      .vocab-chat-scrollable-content::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 3px;
      }
      
      .vocab-chat-scrollable-content::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }
      
      .vocab-chat-scrollable-content::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      
      /* Original Text Content */
      .vocab-chat-original-text {
        padding: 16px;
        background: #f9fafb;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.6;
        color: #374151;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      
      /* Simplified Text */
      .vocab-chat-simplified-text {
        padding: 16px;
        background: #ffffff;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.6;
        color: #374151;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin-bottom: 12px;
      }
      
      .vocab-chat-simplified-header {
        text-align: center;
        color: #9527F5;
        font-weight: 600;
        font-size: 18px;
        margin: 0 0 12px 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        letter-spacing: 0.5px;
      }
      
      .vocab-chat-simplified-item {
        margin-bottom: 16px;
      }
      
      .vocab-chat-simplified-item:last-child {
        margin-bottom: 0;
      }
      
      /* Brain icon CSS removed - no longer needed */
      
      /* Page Summary Container - Above "Summarise the page" button */
      .vocab-chat-page-summary-container {
        margin: 16px;
        margin-bottom: 12px;
        padding: 0;
      }
      
      .vocab-chat-typing-indicator {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 12px 16px;
        gap: 4px;
      }
      
      .vocab-chat-typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #9527F5;
        display: inline-block;
        animation: vocab-chat-typing-bounce 1.4s infinite ease-in-out;
        opacity: 0.4;
      }
      
      .vocab-chat-typing-dot:nth-child(1) {
        animation-delay: -0.32s;
      }
      
      .vocab-chat-typing-dot:nth-child(2) {
        animation-delay: -0.16s;
      }
      
      .vocab-chat-typing-dot:nth-child(3) {
        animation-delay: 0;
      }
      
      @keyframes vocab-chat-typing-bounce {
        0%, 80%, 100% {
          transform: scale(0.8);
          opacity: 0.4;
        }
        40% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      .vocab-chat-page-summary-header {
        text-align: center;
        color: #9527F5;
        font-weight: 600;
        font-size: 18px;
        margin: 0 0 12px 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        letter-spacing: 0.5px;
      }
      
      .vocab-chat-page-summary-content {
        padding: 16px;
        background: #ffffff;
        border: none;
        border-radius: 20px;
        font-size: 14px;
        line-height: 1.6;
        color: #374151;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      
      .vocab-chat-page-summary-content p {
        margin: 0 0 12px 0;
      }
      
      .vocab-chat-page-summary-content p:last-child {
        margin-bottom: 0;
      }
      
      .vocab-chat-page-summary-content strong {
        font-weight: 600;
        color: #1f2937;
      }
      
      /* Page Summary Questions */
      .vocab-chat-page-questions-container {
        margin-top: 5px;
        padding-top: 16px;
        // border-top: 1px solid #e5e7eb;
        animation: vocab-chat-questions-fade-in 0.5s ease-out;
      }
      
      @keyframes vocab-chat-questions-fade-in {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .vocab-chat-page-questions-header {
        font-size: 14px;
        font-weight: 600;
        color: #9527F5;
        margin: 0 0 12px 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }
      
      .vocab-chat-page-questions-list {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      
      .vocab-chat-page-question-item {
        padding: 2px;
        margin: 2px;
        background: #ffffff;
        border: none;
        border-top: 1px solid rgba(149, 39, 245, 0.2);
        border-radius: 0;
        font-size: 14px;
        line-height: 1.5;
        color: #6b7280;
        cursor: pointer;
        transition: color 0.2s ease, transform 0.15s ease;
        word-wrap: break-word;
        display: flex;
        align-items: center;
        gap: 8px;
        animation: vocab-chat-question-item-fade-in 0.4s ease-out backwards;
      }
      
      .vocab-chat-page-question-item:nth-child(1) {
        animation-delay: 0.1s;
      }
      
      .vocab-chat-page-question-item:nth-child(2) {
        animation-delay: 0.15s;
      }
      
      .vocab-chat-page-question-item:nth-child(3) {
        animation-delay: 0.2s;
      }
      
      .vocab-chat-page-question-item:nth-child(4) {
        animation-delay: 0.25s;
      }
      
      .vocab-chat-page-question-item:nth-child(5) {
        animation-delay: 0.3s;
      }
      
      @keyframes vocab-chat-question-item-fade-in {
        from {
          opacity: 0;
          transform: translateX(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      
      .vocab-chat-page-question-item:hover {
        color: #9527F5;
      }
      
      .vocab-chat-page-question-item:active {
        color: #7a1fd9;
      }
      
      .vocab-chat-page-question-icon {
        flex-shrink: 0;
        color: #9527F5;
        font-weight: 600;
        font-size: 16px;
      }
      
      /* Message Questions Container - Below AI messages */
      .vocab-chat-message-questions-container {
        margin-top: 12px;
        padding: 16px;
        animation: vocab-chat-questions-fade-in 0.5s ease-out;
      }
      
      .vocab-chat-message-questions-header {
        font-size: 13px;
        font-weight: 500;
        color: #9527F5;
        margin: 0 0 8px 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }
      
      .vocab-chat-message-questions-list {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      
      .vocab-chat-message-question-item {
        padding: 2px;
        margin: 2px;
        background: #ffffff;
        border: none;
        border-top: 1px solid rgba(149, 39, 245, 0.2);
        border-radius: 0;
        font-size: 14px;
        line-height: 1.5;
        color: #6b7280;
        cursor: pointer;
        transition: color 0.2s ease, transform 0.15s ease;
        word-wrap: break-word;
        display: flex;
        align-items: center;
        gap: 8px;
        animation: vocab-chat-question-item-fade-in 0.4s ease-out backwards;
      }
      
      .vocab-chat-message-question-item:nth-child(1) {
        animation-delay: 0.1s;
      }
      
      .vocab-chat-message-question-item:nth-child(2) {
        animation-delay: 0.15s;
      }
      
      .vocab-chat-message-question-item:nth-child(3) {
        animation-delay: 0.2s;
      }
      
      .vocab-chat-message-question-item:nth-child(4) {
        animation-delay: 0.25s;
      }
      
      .vocab-chat-message-question-item:nth-child(5) {
        animation-delay: 0.3s;
      }
      
      .vocab-chat-message-question-item:hover {
        color: #9527F5;
      }
      
      .vocab-chat-message-question-item:active {
        color: #7a1fd9;
        transform: scale(0.95);
      }
      
      .vocab-chat-message-question-icon {
        flex-shrink: 0;
        color: #9527F5;
        font-weight: 600;
        font-size: 16px;
      }
      
      .vocab-chat-simplify-more-container {
        display: flex;
        justify-content: flex-end;
        margin-top: 12px;
        margin-right: 0;
        padding-right: 0;
        width: 100%;
        box-sizing: border-box;
      }
      
      .vocab-chat-stop-summarise-btn {
        background: #ef4444 !important;
        color: white !important;
        border: none !important;
        border-radius: 12px !important;
        padding: 10px 20px !important;
        font-size: 14px !important;
        font-weight: 500 !important;
        cursor: pointer !important;
        margin: 16px !important;
        margin-bottom: 8px !important;
        display: block !important;
        width: calc(100% - 32px) !important;
        box-sizing: border-box !important;
        transition: all 0.2s ease !important;
      }
      
      .vocab-chat-stop-summarise-btn:hover {
        background: #dc2626 !important;
        transform: translateY(-1px) !important;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3) !important;
      }
      
      .vocab-chat-stop-summarise-btn:active {
        transform: translateY(0) scale(0.95) !important;
      }
      
      .vocab-chat-simplify-more-btn {
        background: #9527F5 !important;
        color: white !important;
        border: none !important;
        border-radius: 12px !important;
        padding: 10px 20px !important;
        font-size: 14px !important;
        font-weight: 500 !important;
        display: flex !important;
        align-items: center !important;
        gap: 8px !important;
        cursor: pointer !important;
        transition: all 0.2s ease !important;
        font-family: inherit !important;
        text-decoration: none !important;
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.3) !important;
        width: auto !important;
        height: auto !important;
        min-width: auto !important;
        min-height: auto !important;
        max-width: none !important;
        max-height: none !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-chat-simplify-more-btn:hover:not(.disabled) {
        background: #7a1fd9;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(149, 39, 245, 0.3);
        text-decoration: none;
      }
      
      .vocab-chat-simplify-more-btn:active:not(.disabled) {
        transform: translateY(0) scale(0.95);
      }
      
      .vocab-chat-simplify-more-btn.disabled {
        background: #d1d5db;
        cursor: not-allowed;
        opacity: 0.6;
      }
      
      .vocab-chat-simplify-more-btn.loading {
        position: relative;
        color: transparent;
      }
      
      .vocab-chat-simplify-more-btn.loading::after {
        content: '';
        position: absolute;
        width: 16px;
        height: 16px;
        top: 50%;
        left: 50%;
        margin-left: -8px;
        margin-top: -8px;
        border: 2px solid white;
        border-radius: 50%;
        border-top-color: transparent;
        animation: vocab-chat-spin 0.6s linear infinite;
      }
      
      @keyframes vocab-chat-spin {
        to {
          transform: rotate(360deg);
        }
      }
      
      /* Chat Messages */
      .vocab-chat-messages {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 0;
      }
      
      /* No Messages State */
      .vocab-chat-no-messages {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .vocab-chat-no-messages-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        opacity: 0.5;
      }
      
      .vocab-chat-no-messages-content span {
        font-size: 16px;
        font-weight: 500;
        color: #9527F5;
      }
      
      @keyframes pulse {
        0%, 100% {
          opacity: 0.6;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.05);
        }
      }
      
      /* Cat icon with breathing animation */
      .vocab-chat-empty-cat-icon {
        width: 80px;
        height: 80px;
        object-fit: contain;
        animation: catBreathing 2s ease-in-out infinite;
        display: block;
        filter: brightness(1.1) saturate(1.4) hue-rotate(5deg);
      }
      
      @keyframes catBreathing {
        0%, 100% {
          transform: scale(1);
          filter: brightness(1.1) saturate(1.4) hue-rotate(5deg) drop-shadow(0 0 8px rgba(160, 32, 240, 0.4));
        }
        50% {
          transform: scale(1.15);
          filter: brightness(1.1) saturate(1.4) hue-rotate(5deg) drop-shadow(0 0 20px rgba(160, 32, 240, 0.8)) drop-shadow(0 0 30px rgba(160, 32, 240, 0.5));
        }
      }
      
      /* Message Bubbles */
      .vocab-chat-message {
        display: flex;
        flex-direction: column;
        position: relative;
      }
      
      .vocab-chat-message-user {
        align-items: flex-end;
        margin-right: 8px;
      }
      
      .vocab-chat-message-ai {
        align-items: center;
        margin-left: 0;
        margin-right: 0;
        width: 100%;
      }
      
      .vocab-chat-message-content {
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.5;
        max-width: 85%;
        word-wrap: break-word;
        white-space: pre-wrap;
      }
      
      .vocab-chat-message-user .vocab-chat-message-content {
        background: #f3e8ff;
        color: #374151;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content {
        padding: 16px;
        background: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        line-height: 1.6;
        color: #374151;
        word-wrap: break-word;
        overflow-wrap: break-word;
        box-shadow: none;
        max-width: none;
        width: auto;
      }
      
      /* Loading Animation - Three Dots Waving */
      .vocab-chat-typing-indicator {
        display: flex;
        gap: 3px;
        align-items: center;
        padding: 12px 0;
        justify-content: flex-start;
        margin-left: 16px;
      }
      
      .vocab-chat-typing-indicator span {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: #9527F5;
        animation: typing-wave 1.4s ease-in-out infinite;
        opacity: 0.7;
      }
      
      .vocab-chat-typing-indicator span:nth-child(1) {
        animation-delay: 0s;
      }
      
      .vocab-chat-typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }
      
      .vocab-chat-typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }
      
      @keyframes typing-wave {
        0%, 60%, 100% {
          transform: translateY(0);
          opacity: 0.7;
        }
        30% {
          transform: translateY(-6px);
          opacity: 1;
        }
      }
      
      /* Markdown Styling in AI Messages */
      .vocab-chat-message-ai .vocab-chat-message-content code {
        background: #f3f4f6;
        color: #9527F5;
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'Courier New', Courier, monospace;
        font-size: 13px;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content pre {
        background: #f3f4f6;
        padding: 12px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 8px 0;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content pre code {
        background: transparent;
        padding: 0;
        font-size: 12px;
        line-height: 1.5;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content p {
        margin: 0 0 12px 0;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content p:last-child {
        margin-bottom: 0;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content strong {
        font-weight: 600;
        color: #1f2937;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content em {
        font-style: italic;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content a {
        color: #9527F5;
        text-decoration: underline;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content a:hover {
        color: #7a1fd9;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content h1,
      .vocab-chat-message-ai .vocab-chat-message-content h2,
      .vocab-chat-message-ai .vocab-chat-message-content h3 {
        font-weight: 600;
        margin: 8px 0;
        color: #1f2937;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content h1 {
        font-size: 18px;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content h2 {
        font-size: 16px;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content h3 {
        font-size: 15px;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content ul {
        margin: 8px 0;
        padding-left: 20px;
      }
      
      .vocab-chat-message-ai .vocab-chat-message-content li {
        margin: 4px 0;
      }
      
      /* Input Area */
      .vocab-chat-input-area {
        display: flex;
        gap: 8px;
        padding: 16px;
        border-top: 1px solid #e5e7eb;
        background: white;
        align-items: center; /* centers items vertically on the same horizontal axis */
        justify-content: center; /* centers items horizontally */
      }
      
      .vocab-chat-input {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        font-size: 14px;
        font-family: inherit;
        resize: none;
        outline: none;
        transition: border-color 0.2s ease;
        min-height: 40px;
        max-height: 120px;
        color: #1f2937 !important; /* Ensure text is visible */
        caret-color: #9527F5 !important; /* Ensure cursor is visible */
        background-color: white !important; /* Ensure background is white */
      }
      
      .vocab-chat-input:focus {
        border-color: #9527F5;
        color: #1f2937 !important; /* Ensure text is visible on focus */
        caret-color: #9527F5 !important; /* Ensure cursor is visible on focus */
      }
      
      .vocab-chat-input::placeholder {
        color: #9ca3af !important; /* Ensure placeholder is visible */
      }
      
      /* Send Button - Wireframe Purple Circular */
      .vocab-chat-send-btn {
        width: 30px !important;
        height: 30px !important;
        min-width: 30px !important;
        min-height: 30px !important;
        max-width: 30px !important;
        max-height: 30px !important;
        background: white !important;
        border: 2px solid #9527F5 !important;
        border-radius: 50% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        transition: all 0.2s ease !important;
        flex-shrink: 0 !important;
        text-decoration: none !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      .vocab-chat-send-btn svg {
        width: 20px !important;
        height: 20px !important;
        min-width: 20px !important;
        min-height: 20px !important;
        max-width: 20px !important;
        max-height: 20px !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-chat-send-btn svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      .vocab-chat-send-btn:hover {
        background: #f0e6ff;
        border-color: #7a1fd9;
        transform: translateY(-1px);
        text-decoration: none;
      }
      
      .vocab-chat-send-btn:active {
        transform: translateY(0) scale(0.95);
      }
      
      /* Delete Conversation Button - Wireframe Red Circular */
      .vocab-chat-delete-conversation-btn {
        width: 35px !important;
        height: 35px !important;
        min-width: 35px !important;
        min-height: 35px !important;
        max-width: 35px !important;
        max-height: 35px !important;
        background: white !important;
        border: 2px solid #ef4444 !important;
        border-radius: 50% !important;
        display: flex !important; /* Changed from 'none' to 'flex' - visibility controlled by inline style */
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        transition: all 0.2s ease !important;
        flex-shrink: 0 !important;
        margin-left: 4px !important;
        text-decoration: none !important;
        box-sizing: border-box !important;
        padding: 0 !important;
      }
      
      /* Allow inline style to control visibility - use setProperty for higher specificity */
      .vocab-chat-delete-conversation-btn.hidden {
        display: none !important;
      }
      
      .vocab-chat-delete-conversation-btn svg {
        width: 18px !important;
        height: 18px !important;
        min-width: 18px !important;
        min-height: 18px !important;
        max-width: 18px !important;
        max-height: 18px !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-shrink: 0 !important;
      }
      
      .vocab-chat-delete-conversation-btn svg * {
        display: block !important;
        visibility: visible !important;
      }
      
      .vocab-chat-delete-conversation-btn:hover {
        background: #fef2f2;
        border-color: #dc2626;
        transform: translateY(-1px);
        text-decoration: none;
      }
      
      .vocab-chat-delete-conversation-btn:active {
        transform: translateY(0) scale(0.95);
      }
      
      /* Resize Handles */
      .vocab-chat-resize-handle {
        position: absolute;
        z-index: 1000001;
      }
      
      .vocab-chat-resize-left {
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        cursor: ew-resize;
        background: transparent;
        transition: all 0.2s ease;
      }
      
      .vocab-chat-resize-left::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 4px;
        height: 40px;
        border-radius: 2px;
        background: #9527F5;
        box-shadow: 0 0 8px rgba(149, 39, 245, 0.3);
        transition: all 0.2s ease;
      }
      
      .vocab-chat-resize-left:hover::before {
        background: #9527F5;
        box-shadow: 0 0 12px rgba(149, 39, 245, 0.5);
        transform: translate(-50%, -50%) scale(1.1);
      }
      
      .vocab-chat-resize-bottom {
        left: 0;
        right: 0;
        bottom: 0;
        height: 4px;
        cursor: ns-resize;
        background: transparent;
        transition: background 0.2s ease;
      }
      
      .vocab-chat-resize-bottom:hover {
        background: rgba(149, 39, 245, 0.3);
      }
      
      .vocab-chat-resize-bottom-left {
        left: 0;
        bottom: 0;
        width: 20px;
        height: 20px;
        cursor: nesw-resize;
        background: transparent;
      }
      
      .vocab-chat-resize-bottom-left::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        background: transparent;
        box-shadow: none;
        border-bottom: 4px solid #9527F5;
        border-left: 4px solid #9527F5;
        border-right: none;
        border-top: none;
        border-radius: 0 0 0 20px;
        transition: all 0.2s ease;
      }
      
      .vocab-chat-resize-bottom-left:hover::before {
        transform: translate(-50%, -50%) scale(1.1);
        box-shadow: none;
      }
      
      .vocab-chat-resize-top-left {
        left: 0;
        top: 0;
        width: 20px;
        height: 20px;
        cursor: nw-resize;
        background: transparent;
      }
      
      .vocab-chat-resize-top-left::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        background: transparent;
        box-shadow: none;
        border-top: 4px solid #9527F5;
        border-left: 4px solid #9527F5;
        border-right: none;
        border-bottom: none;
        border-radius: 20px 0 0 0;
        transition: all 0.2s ease;
      }
      
      .vocab-chat-resize-top-left:hover::before {
        transform: translate(-50%, -50%) scale(1.1);
        box-shadow: none;
      }
      
      /* Focus Button Styles */
      .vocab-chat-focus-btn-container {
        padding: 16px 16px 12px 16px;
        margin-bottom: 12px;
      }
      
      .vocab-chat-focus-btn {
        display: inline-flex !important;
        flex-direction: row !important;
        align-items: center !important;
        justify-content: center !important;
        gap: 6px !important;
        width: auto;
        padding: 8px 14px;
        margin: 0;
        background: white;
        border: 2px solid #9527F5;
        border-radius: 6px;
        color: #9527F5;
        font-weight: 500;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 1px 2px rgba(149, 39, 245, 0.05);
        text-decoration: none;
      }
      
      .vocab-chat-focus-btn:hover {
        background: #f9f5ff;
        border-color: #7a1fd9;
        box-shadow: 0 2px 4px rgba(149, 39, 245, 0.1);
        text-decoration: none;
      }
      
      .vocab-chat-focus-btn:active {
        transform: scale(0.98);
      }
      
      .vocab-chat-focus-btn svg {
        flex-shrink: 0 !important;
        display: inline-block !important;
        width: 16px !important;
        height: 16px !important;
        order: 1 !important;
      }
      
      .vocab-chat-focus-btn span {
        color: #9527F5;
        font-weight: 500;
        order: 2 !important;
        display: inline-block !important;
      }
      
      /* Responsive */
      @media (max-width: 768px) {
        .vocab-chat-dialog {
          width: 100vw;
          max-width: 100vw;
          height: 100vh;
          max-height: 100vh;
        }
        
        .vocab-chat-resize-handle {
          display: none;
        }
      }

      /* Processing Overlay Styles */
      .vocab-processing-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        border-radius: 20px;
      }

      .vocab-processing-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .vocab-processing-content {
        background: transparent;
        border-radius: 20px;
        padding: 40px;
        box-shadow: none;
        text-align: center;
        max-width: 400px;
        width: 90%;
      }

      .vocab-processing-text {
        font-size: 20px;
        font-weight: 600;
        color: #A24EFF;
        margin-bottom: 20px;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .vocab-processing-icon {
        width: 40px;
        height: 40px;
        margin: 20px auto 0 auto;
        position: relative;
      }

      /* Image Processing Overlay Styles */
      .vocab-image-processing-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        border-radius: 20px;
      }

      .vocab-image-processing-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .vocab-image-processing-content {
        background: transparent;
        border-radius: 20px;
        padding: 40px;
        box-shadow: none;
        text-align: center;
        max-width: 400px;
        width: 90%;
      }

      .vocab-image-processing-text {
        margin-bottom: 0;
      }

      .vocab-image-processing-main {
        font-size: 20px;
        font-weight: 600;
        color: #A24EFF;
        margin-bottom: 8px;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .vocab-image-processing-sub {
        font-size: 14px;
        font-weight: 400;
        color: #666;
        margin: 0;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .vocab-image-processing-spinner {
        width: 40px;
        height: 40px;
        margin: 0 auto 20px;
        position: relative;
      }

      .vocab-image-processing-spinner-circle {
        width: 100%;
        height: 100%;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #A24EFF;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .vocab-processing-icon::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(45deg, #A24EFF, #8B3AE8);
        border-radius: 50%;
        animation: vocab-processing-pulse 1.5s ease-in-out infinite;
      }

      .vocab-processing-icon::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: vocab-processing-bounce 1.5s ease-in-out infinite;
      }

      @keyframes vocab-processing-pulse {
        0%, 100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.7;
        }
      }

      @keyframes vocab-processing-bounce {
        0%, 100% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.3);
        }
      }


      /* Blur icons wrapper when other modals are open (image, pdf, text, topics) */
      body.vocab-image-modal-open .vocab-text-icons-wrapper,
      body.vocab-pdf-modal-open .vocab-text-icons-wrapper,
      body.vocab-text-modal-open .vocab-text-icons-wrapper,
      body.vocab-topics-modal-open .vocab-text-icons-wrapper {
        filter: blur(8px) !important;
        opacity: 0.3 !important;
        pointer-events: none !important;
        transition: filter 0.3s ease, opacity 0.3s ease;
      }
      
      /* Hide individual buttons when other modals are open */
      body.vocab-image-modal-open .vocab-word-remove-explained-btn,
      body.vocab-image-modal-open .vocab-text-book-btn,
      body.vocab-image-modal-open .vocab-text-remove-btn,
      body.vocab-image-modal-open .vocab-text-chat-btn,
      body.vocab-image-modal-open .vocab-text-remove-green-btn,
      body.vocab-pdf-modal-open .vocab-word-remove-explained-btn,
      body.vocab-pdf-modal-open .vocab-text-book-btn,
      body.vocab-pdf-modal-open .vocab-text-remove-btn,
      body.vocab-pdf-modal-open .vocab-text-chat-btn,
      body.vocab-pdf-modal-open .vocab-text-remove-green-btn,
      body.vocab-text-modal-open .vocab-word-remove-explained-btn,
      body.vocab-text-modal-open .vocab-text-book-btn,
      body.vocab-text-modal-open .vocab-text-remove-btn,
      body.vocab-text-modal-open .vocab-text-chat-btn,
      body.vocab-text-modal-open .vocab-text-remove-green-btn,
      body.vocab-topics-modal-open .vocab-word-remove-explained-btn,
      body.vocab-topics-modal-open .vocab-text-book-btn,
      body.vocab-topics-modal-open .vocab-text-remove-btn,
      body.vocab-topics-modal-open .vocab-text-chat-btn,
      body.vocab-topics-modal-open .vocab-text-remove-green-btn {
        opacity: 0 !important;
        visibility: hidden !important;
        pointer-events: none !important;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
    `;
    
    document.head.appendChild(style);
  },
  
  /**
   * Save chat history to analysis data for persistence
   */
  saveChatHistoryToAnalysisData() {
    if (!this.currentTextKey || !window.ButtonPanel || !window.ButtonPanel.topicsModal || !window.ButtonPanel.topicsModal.customContentModal || !window.ButtonPanel.topicsModal.customContentModal.activeTabId) {
      console.log('[ChatDialog] Cannot save to analysis data - missing required components');
      return;
    }
    
    const activeContent = window.ButtonPanel.topicsModal.customContentModal.getContentByTabId(parseInt(window.ButtonPanel.topicsModal.customContentModal.activeTabId));
    if (!activeContent || !activeContent.analysis) {
      console.log('[ChatDialog] Cannot save to analysis data - no active content or analysis');
      return;
    }
    
    // Ensure chats array is initialized
    if (!activeContent.analysis.chats) {
      activeContent.analysis.chats = [];
      console.log('[ChatDialog] Initialized chats array in analysis data (close function)');
    }
    
    // Extract the tab ID from the currentTextKey
    const chatTabId = this.currentTextKey.replace(/^[^-]+-(\d+)-.*/, '$1');
    console.log('[ChatDialog] Saving chat history to analysis data for tab:', chatTabId);
    
    // Check if this textKey already exists in chats
    const existingChatIndex = activeContent.analysis.chats.findIndex(c => 
      c.textKey === this.currentTextKey
    );
    
    const chatData = {
      textKey: this.currentTextKey,
      messages: [...this.chatHistory],
      lastUpdated: new Date().toISOString()
    };
    
    if (existingChatIndex !== -1) {
      // Update existing chat
      activeContent.analysis.chats[existingChatIndex] = chatData;
      console.log(`[ChatDialog] Updated existing chat for textKey "${this.currentTextKey}" in analysis data`);
    } else {
      // Add new chat
      activeContent.analysis.chats.push(chatData);
      console.log(`[ChatDialog] Added new chat for textKey "${this.currentTextKey}" to analysis data`);
    }
  }
};
// Button Panel Module - Manages the floating button UI
// ===================================
const ButtonPanel = {
  panelContainer: null,
  upperButtonGroup: null,
  
  // State variables for button visibility and enabled states
  state: {
    isMagicMeaningEnabled: false,  // Controls enabled/disabled state of "Magic meaning" button
    showAsk: false                // Controls visibility of "Ask" button
  },

  // API completion tracking
  apiCompletionState: {
    simplifyCompleted: true,
    wordsExplanationCompleted: true,
    shouldTrack: false  // Only track when magic meaning is clicked
  },

  /**
   * Initialize the button panel
   */
  async init() {
    this.createPanel();
    
    // Load and apply saved position
    await this.loadAndApplyPosition();
    
    // Initialize drag functionality - drag the entire panel container
    const dragHandle = document.getElementById('vocab-drag-handle');
    if (dragHandle && this.panelContainer) {
      DragHandle.init(dragHandle, this.panelContainer);
    }
    
    // Apply initial state
    this.updateButtonStates();
    
    // Attach event listeners after panel is created and added to DOM
    this.attachEventListeners();
    
    // Check if extension is enabled and show/hide accordingly
    const isEnabled = await this.checkExtensionEnabled();
    if (isEnabled) {
      this.show();
    } else {
      this.hide();
    }
    
    console.log('Button panel initialized. Enabled:', isEnabled);
    
    // Expose ButtonPanel to window for debugging
    window.ButtonPanel = ButtonPanel;
    console.log('[ButtonPanel] Exposed to window.ButtonPanel for debugging');
  },

  /**
   * Load and apply saved position to the panel
   */
  async loadAndApplyPosition() {
    try {
      const savedPosition = await PositionManager.loadPosition();
      if (savedPosition && this.panelContainer) {
        // Apply constraints to ensure panel stays within viewport
        const constraints = this.calculateConstraints();
        const constrainedLeft = Math.max(constraints.minX, Math.min(constraints.maxX, savedPosition.left));
        const constrainedTop = Math.max(constraints.minY, Math.min(constraints.maxY, savedPosition.top));
        
        // Check if saved position is valid (not off-screen on the right)
        // If left position is too far right, reset to default left position
        if (constrainedLeft > window.innerWidth / 2) {
          console.log('[ButtonPanel] Saved position appears to be from right-side config, resetting...');
          await PositionManager.clearPosition();
          return; // Let CSS handle default positioning
        }
        
        // Apply the position
        this.panelContainer.style.left = `${constrainedLeft}px`;
        this.panelContainer.style.top = `${constrainedTop}px`;
        this.panelContainer.style.right = 'auto';
        this.panelContainer.style.transform = 'translateY(-50%)';
        
        console.log('[ButtonPanel] Applied saved position:', { left: constrainedLeft, top: constrainedTop });
      }
    } catch (error) {
      console.error('[ButtonPanel] Error loading position:', error);
    }
  },

  /**
   * Calculate viewport constraints to keep panel fully visible
   * @returns {Object} Constraint boundaries
   */
  calculateConstraints() {
    if (!this.panelContainer) {
      return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
    }
    
    const panelRect = this.panelContainer.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    return {
      minX: 0,
      maxX: viewportWidth - panelRect.width,
      minY: 0,
      maxY: viewportHeight - panelRect.height
    };
  },

  /**
   * Check if extension is enabled from storage for current domain
   * @returns {Promise<boolean>} Whether the extension is enabled
   */
  async checkExtensionEnabled() {
    try {
      const GLOBAL_STORAGE_KEY = 'is_extension_globally_enabled';
      const result = await chrome.storage.local.get([GLOBAL_STORAGE_KEY]);
      let isEnabled = result[GLOBAL_STORAGE_KEY];
      
      // If not found, create it and set to true (enabled by default)
      if (isEnabled === undefined) {
        isEnabled = true;
        await chrome.storage.local.set({ [GLOBAL_STORAGE_KEY]: isEnabled });
        console.log('[ButtonPanel] Global toggle state not found, created with default value: true');
      }
      
      return isEnabled;
    } catch (error) {
      console.error('[ButtonPanel] Error checking global extension state:', error);
      return true; // Default to true (enabled) on error
    }
  },

  /**
   * Create the button panel DOM structure
   */
  createPanel() {
    // Create main container
    this.panelContainer = document.createElement('div');
    this.panelContainer.id = 'vocab-helper-button-panel';
    this.panelContainer.className = 'vocab-helper-panel';

    // Create wrapper container (invisible, holds button group + pan button)
    const wrapperContainer = document.createElement('div');
    wrapperContainer.id = 'vocab-wrapper-container';
    wrapperContainer.className = 'vocab-wrapper-container';

    // Create main button group container with shadow
    const mainButtonGroup = document.createElement('div');
    mainButtonGroup.className = 'vocab-button-group-main';

    // Create upper button group (Remove all meanings)
    this.upperButtonGroup = document.createElement('div');
    this.upperButtonGroup.className = 'vocab-button-group-upper';

    const upperButtons = [];

    upperButtons.forEach(btnConfig => {
      const button = this.createButton(btnConfig);
      this.upperButtonGroup.appendChild(button);
    });

    // Create lower button group (Magic meaning, Ask, Custom content)
    const lowerButtonGroup = document.createElement('div');
    lowerButtonGroup.className = 'vocab-button-group-lower';

    const lowerButtons = [
      {
        id: 'magic-meaning',
        className: 'vocab-btn vocab-btn-solid-purple',
        icon: this.createSparkleIcon(),
        text: 'Magic meaning',
        type: 'solid-purple'
      },
      {
        id: 'ask',
        className: 'vocab-btn vocab-btn-solid-purple',
        icon: this.createChatIcon(),
        text: 'Ask anything',
        type: 'solid-purple'
      }
    ];

    lowerButtons.forEach(btnConfig => {
      const button = this.createButton(btnConfig);
      lowerButtonGroup.appendChild(button);
    });

    // Append upper and lower groups to main group
    mainButtonGroup.appendChild(this.upperButtonGroup);
    mainButtonGroup.appendChild(lowerButtonGroup);

    // Create drag handle (separate from button group)
    const dragHandle = this.createDragHandle();

    // Append button group and drag handle to wrapper
    wrapperContainer.appendChild(mainButtonGroup);
    wrapperContainer.appendChild(dragHandle);

    // Append wrapper to panel
    this.panelContainer.appendChild(wrapperContainer);

    // Inject styles
    this.injectStyles();

    // Append to body
    document.body.appendChild(this.panelContainer);
  },
  
  /**
   * Create drag handle element
   * @returns {HTMLElement} Drag handle element
   */
  createDragHandle() {
    const dragHandle = document.createElement('div');
    dragHandle.id = 'vocab-drag-handle';
    dragHandle.className = 'vocab-drag-handle';
    dragHandle.title = 'Drag to reposition';
    
    // Add pan icon
    dragHandle.innerHTML = this.createPanIcon();
    
    return dragHandle;
  },
  
  /**
   * Create pan/move icon SVG - Simple grip dots icon
   * @returns {string} SVG markup
   */
  createPanIcon() {
    return `
      <svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="6" cy="4" r="1.5" fill="#d4b5f5"/>
        <circle cx="10" cy="4" r="1.5" fill="#d4b5f5"/>
        <circle cx="14" cy="4" r="1.5" fill="#d4b5f5"/>
        <circle cx="6" cy="8" r="1.5" fill="#d4b5f5"/>
        <circle cx="10" cy="8" r="1.5" fill="#d4b5f5"/>
        <circle cx="14" cy="8" r="1.5" fill="#d4b5f5"/>
        <circle cx="6" cy="12" r="1.5" fill="#d4b5f5"/>
        <circle cx="10" cy="12" r="1.5" fill="#d4b5f5"/>
        <circle cx="14" cy="12" r="1.5" fill="#d4b5f5"/>
      </svg>
    `;
  },

  /**
   * Create a button element
   * @param {Object} config - Button configuration
   * @returns {HTMLElement} Button element
   */
  createButton(config) {
    const button = document.createElement('button');
    button.id = config.id;
    button.className = config.className;
    button.setAttribute('data-type', config.type);

    // Create icon container
    const iconSpan = document.createElement('span');
    iconSpan.className = 'vocab-btn-icon';
    iconSpan.innerHTML = config.icon;

    // Create text span
    const textSpan = document.createElement('span');
    textSpan.className = 'vocab-btn-text';
    textSpan.textContent = config.text;

    button.appendChild(iconSpan);
    button.appendChild(textSpan);

    return button;
  },



  /**
   * Create trash icon SVG
   * @param {string} color - Icon color (green or purple)
   * @returns {string} SVG markup
   */
  createTrashIcon(color) {
    const strokeColor = color === 'green' ? '#16a34a' : '#9527F5';
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 5h14M6.5 5V3.5a1.5 1.5 0 0 1 1.5-1.5h4a1.5 1.5 0 0 1 1.5 1.5V5M15 5v10.5a1.5 1.5 0 0 1-1.5 1.5h-7a1.5 1.5 0 0 1-1.5-1.5V5h10Z" stroke="${strokeColor}" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M8 9v5M12 9v5" stroke="${strokeColor}" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },

  /**
   * Create AI sparkle icon SVG (solid white, larger and prominent)
   * @returns {string} SVG markup
   */
  createSparkleIcon(size = 18) {
    return `
      <svg width="${size}" height="${size}" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M14 0L17 8L25 11L17 14L14 22L11 14L3 11L11 8L14 0Z" fill="white"/>
        <path d="M22 16L23.5 20L27.5 21.5L23.5 23L22 27L20.5 23L16.5 21.5L20.5 20L22 16Z" fill="white"/>
        <path d="M8 21L9.5 24.5L13 26L9.5 27.5L8 31L6.5 27.5L3 26L6.5 24.5L8 21Z" fill="white"/>
      </svg>
    `;
  },

  /**
   * Create chat bubble icon SVG - Purple wireframe chatbot agent
   * @returns {string} SVG markup
   */
  createChatIcon() {
    return `
      <svg width="16" height="16" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="4" y="4" width="12" height="10" rx="2" stroke="#9527F5" stroke-width="2" fill="none"/>
        <line x1="10" y1="2" x2="10" y2="4" stroke="#9527F5" stroke-width="2" stroke-linecap="round"/>
        <circle cx="10" cy="1.5" r="0.8" fill="#9527F5"/>
        <circle cx="7.5" cy="8.5" r="1.2" fill="#9527F5"/>
        <circle cx="12.5" cy="8.5" r="1.2" fill="#9527F5"/>
        <path d="M7 11C7.5 11.8 8.5 12.5 10 12.5C11.5 12.5 12.5 11.8 13 11" stroke="#9527F5" stroke-width="2" stroke-linecap="round" fill="none"/>
        <path d="M10 14L10 16.5L8 15" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },


  /**
   * Create processing spinner icon SVG
   * @returns {string} SVG markup
   */
  createProcessingSpinner() {
    return `
      <svg class="vocab-processing-spinner" width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="14" cy="14" r="10" stroke="white" stroke-width="3" stroke-opacity="0.3" fill="none"/>
        <path d="M14 4 A10 10 0 0 1 24 14" stroke="white" stroke-width="3" stroke-linecap="round" fill="none"/>
      </svg>
    `;
  },

  /**
   * Create success check icon SVG
   * @returns {string} SVG markup
   */
  createSuccessCheckIcon() {
    return `
      <svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M6 14L11 19L22 8" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },

  /**
   * Create content icon SVG (solid white)
   * @returns {string} SVG markup
   */
  createContentIcon() {
    return `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="5" cy="10" r="1.5" fill="#9527F5"/>
        <circle cx="10" cy="10" r="1.5" fill="#9527F5"/>
        <circle cx="15" cy="10" r="1.5" fill="#9527F5"/>
      </svg>
    `;
  },


  /**
   * Update magic meaning button to show processing state
   */
  setMagicMeaningProcessing() {
    const magicBtn = document.getElementById('magic-meaning');
    if (magicBtn) {
      const iconSpan = magicBtn.querySelector('.vocab-btn-icon');
      if (iconSpan) {
        iconSpan.innerHTML = this.createProcessingSpinner();
      }
      magicBtn.classList.add('processing');
      magicBtn.disabled = true;
      
      // Remove any existing tooltips when state changes
      this.removeAllTooltips();
    }
  },

  /**
   * Update magic meaning button to show success state
   */
  setMagicMeaningSuccess() {
    const magicBtn = document.getElementById('magic-meaning');
    if (magicBtn) {
      const iconSpan = magicBtn.querySelector('.vocab-btn-icon');
      if (iconSpan) {
        iconSpan.innerHTML = this.createSuccessCheckIcon();
      }
      magicBtn.classList.remove('processing');
      magicBtn.classList.add('success');
      // Keep button disabled during success animation
      magicBtn.disabled = true;
      
      // Remove any existing tooltips when state changes
      this.removeAllTooltips();
    }
  },

  /**
   * Reset magic meaning button to its proper state based on selections
   */
  resetMagicMeaningButton() {
    const magicBtn = document.getElementById('magic-meaning');
    if (magicBtn) {
      const iconSpan = magicBtn.querySelector('.vocab-btn-icon');
      if (iconSpan) {
        iconSpan.innerHTML = this.createSparkleIcon();
      }
      magicBtn.classList.remove('processing', 'success');
      
      // Remove any existing tooltips when state changes
      this.removeAllTooltips();
      
      // Update button state based on current selections
      // This will enable the button if there are new selections, or disable it if there aren't
      this.updateButtonStatesFromSelections();
    }
  },

  /**
   * Remove all tooltips from the page
   */
  removeAllTooltips() {
    const tooltips = document.querySelectorAll('.vocab-btn-tooltip');
    tooltips.forEach(tooltip => {
      tooltip.classList.remove('visible');
      tooltip.remove();
    });
  },

  /**
   * Check if all APIs have completed
   */
  checkAPICompletion() {
    if (!this.apiCompletionState.shouldTrack) {
      return;
    }

    console.log('[ButtonPanel] Checking API completion:', this.apiCompletionState);

    if (this.apiCompletionState.simplifyCompleted && this.apiCompletionState.wordsExplanationCompleted) {
      console.log('[ButtonPanel] All APIs completed!');
      
      // Stop tracking
      this.apiCompletionState.shouldTrack = false;

      // Show success state
      this.setMagicMeaningSuccess();

      // Reset button after 2 seconds
      setTimeout(() => {
        this.resetMagicMeaningButton();
      }, 2000);
    }
  },

  /**
   * Inject CSS styles for the button panel
   */
  injectStyles() {
    const styleId = 'vocab-helper-button-panel-styles';
    
    // Check if styles already injected
    if (document.getElementById(styleId)) {
      return;
    }

    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      /* Main Panel Container */
      .vocab-helper-panel {
        position: fixed;
        left: 0;
        top: 50%;
        transform: translateY(-50%) translateX(-100%);
        z-index: 999999;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        opacity: 1;
      }

      /* Panel visible state */
      .vocab-helper-panel.visible {
        transform: translateY(-50%) translateX(0);
      }

      /* Wrapper Container - Unified container for button group + drag handle */
      .vocab-wrapper-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0;
        overflow: visible !important;
        border-radius: 100px;
        box-shadow: 0 4px 20px rgba(149, 39, 245, 0.3), 0 2px 8px rgba(149, 39, 245, 0.2);
        background: white;
        transform-origin: center;
      }

      /* Pop-in animation for wrapper container appearing */
      .vocab-wrapper-container.pop-in {
        animation: wrapperContainerPopIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }

      /* Pop-out animation for wrapper container disappearing */
      .vocab-wrapper-container.pop-out {
        animation: wrapperContainerPopOut 0.3s cubic-bezier(0.6, 0, 0.4, 1) forwards;
      }

      @keyframes wrapperContainerPopIn {
        0% {
          opacity: 0;
          transform: scale(0);
        }
        60% {
          opacity: 1;
          transform: scale(1.1);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes wrapperContainerPopOut {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(0);
        }
      }

      /* Main Button Group with Purple Shadow */
      .vocab-button-group-main {
        display: none !important;
        flex-direction: column;
        gap: 0;
        background: white;
        padding: 0;
        border-radius: 100px;
        box-shadow: none;
        // border: 1px solid rgba(149, 39, 245, 0.15);
        border: none;
        overflow: visible !important;
      }

      /* Upper Button Group with smooth transitions */
      .vocab-button-group-upper {
        display: flex;
        flex-direction: column;
        gap: 0;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: scaleY(0);
        transform-origin: top;
        transition: max-height 0.3s ease, opacity 0.3s ease, transform 0.3s ease, margin 0.3s ease, padding 0.3s ease;
        margin-bottom: 0;
        padding: 0;
        background: transparent;
      }
      
      .vocab-button-group-upper.visible {
        max-height: 200px;
        opacity: 1;
        transform: scaleY(1);
        margin-bottom: 0;
        padding: 0;
      }

      /* Lower Button Group (no additional styling) */
      .vocab-button-group-lower {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 0;
        transition: gap 0.3s ease;
        overflow: visible;
        background: transparent;
      }

      /* Drag Handle Styles - Semi-circular (bottom half rounded) */
      .vocab-drag-handle {
        display: none !important;
        justify-content: center;
        align-items: center;
        padding: 6px 6px 8px 6px;
        cursor: grab;
        user-select: none;
        border-radius: 0 0 100px 100px;
        background: white;
        width: 46px;
        margin-top: 0;
        box-shadow: none;
        border: none;
      }

      .vocab-drag-handle:hover {
        background: white;
      }

      .vocab-drag-handle:active {
        cursor: grabbing;
        background: white;
      }

      .vocab-drag-handle svg {
        pointer-events: none;
        display: block;
      }

      /* Base Button Styles - Icon Only */
      .vocab-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        padding: 12px;
        border-radius: 50%;
        font-size: 11.5px;
        font-weight: 500;
        border: none;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        outline: none;
        width: 46px;
        height: 46px;
        max-height: 100px;
        overflow: hidden;
        opacity: 1;
        text-decoration: none;
        margin: 6px;
        flex-shrink: 0;
      }
      
      /* Disable transitions during animations to prevent conflicts */
      .vocab-btn.showing,
      .vocab-btn.hiding {
        transition: none !important;
      }
      
      .vocab-btn.hidden {
        display: none !important;
      }
      
      /* Animation classes for smooth transitions */
      .vocab-btn.hiding {
        animation: buttonSlideOutRight 0.35s cubic-bezier(0.6, 0, 0.4, 1) forwards;
        pointer-events: none !important;
      }

      @keyframes buttonSlideOutRight {
        0% {
          opacity: 1;
          transform: translateX(0) scale(1);
          max-height: 100px;
          margin-top: 0;
          margin-bottom: 0;
        }
        100% {
          opacity: 0;
          transform: translateX(-120px) scale(0.8);
          max-height: 0;
          margin-top: 0;
          margin-bottom: 0;
          padding-top: 0;
          padding-bottom: 0;
        }
      }
      
      .vocab-btn.showing {
        animation: buttonSlideInRight 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }

      @keyframes buttonSlideInRight {
        0% {
          opacity: 0;
          transform: translateX(-120px) scale(0.8);
          max-height: 0;
          margin-top: 0;
          margin-bottom: 0;
          padding: 0;
        }
        60% {
          opacity: 1;
        }
        100% {
          opacity: 1;
          transform: translateX(0) scale(1);
          max-height: 100px;
          margin-top: 0;
          margin-bottom: 0;
          padding: 12px;
        }
      }

      .vocab-btn:active:not(.hidden) {
        transform: scale(0.95) !important;
      }

      /* Button Icon */
      .vocab-btn-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        height: 22px;
      }
      
      .vocab-btn-icon svg {
        width: 22px;
        height: 22px;
      }

      .vocab-btn-text {
        display: none !important;
      }

      /* Green Outline Button - Remove Meanings */
      .vocab-btn-outline-green {
        background: #d1fae5 !important;
        border: none !important;
        color: #16a34a;
      }

      .vocab-btn-outline-green:hover {
        background: #a7f3d0 !important;
        color: #15803d;
        text-decoration: none;
      }

      /* Purple Outline Button */
      .vocab-btn-outline-purple {
        background: white;
        border-color: #9527F5;
        color: #9527F5;
      }

      .vocab-btn-outline-purple:hover {
        background: #f0e6ff;
        border-color: #7a1fd9;
        color: #7a1fd9;
        text-decoration: none;
      }

      /* Solid Purple Button */
      .vocab-btn-solid-purple {
        background: #9527F5;
        border-color: #9527F5;
        color: white;
      }

      .vocab-btn-solid-purple:hover:not(.disabled) {
        background: #7a1fd9;
        border-color: #7a1fd9;
        text-decoration: none;
      }

      
      /* Ask Anything Button - Light Purple BG with Purple Wireframe Icon */
      #ask {
        background: #ede5ff !important;
        border: none !important;
        padding: 8px 12px !important;
      }

      #ask:hover:not(.disabled) {
        background: #ddc8ff !important;
      }

      /* Magic Meaning Button - VIBGYOROYGBIV Flowing Gradient when enabled */
      /* Magic meaning button - solid purple when enabled with breathing animation */
      #magic-meaning:not(.disabled) {
        background: #9527F5 !important;
        border-color: #9527F5 !important;
        color: white !important;
        animation: magicMeaningBreathing 2s ease-in-out infinite !important;
      }
      
      #magic-meaning:hover:not(.disabled) {
        background: #7a1fd9 !important;
        border-color: #7a1fd9 !important;
      }

      @keyframes magicMeaningBreathing {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 2px 8px rgba(149, 39, 245, 0.3);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 4px 16px rgba(149, 39, 245, 0.5), 0 0 20px rgba(149, 39, 245, 0.3);
        }
      }

      /* Disabled Button State */
      .vocab-btn.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .vocab-btn-solid-purple.disabled {
        background: #c5aee3;
        border-color: #c5aee3;
        opacity: 1;
      }

      .vocab-btn-solid-purple.disabled:hover {
        background: #c5aee3;
        border-color: #c5aee3;
      }

      .vocab-btn-solid-purple.disabled .vocab-btn-icon svg {
        opacity: 0.7;
      }

      .vocab-btn-solid-purple.disabled .vocab-btn-text {
        opacity: 0.85;
      }

      /* Allow hover events on disabled buttons for tooltips */
      .vocab-btn.disabled {
        pointer-events: auto; /* Allow hover events on the button itself */
      }
      
      .vocab-btn.disabled * {
        pointer-events: none; /* But disable pointer events on child elements */
      }
      
      /* Allow tooltips to be visible on disabled buttons */
      .vocab-btn.disabled .vocab-btn-tooltip {
        pointer-events: auto;
      }

      /* Tooltip Styles */
      .vocab-btn-tooltip {
        position: fixed !important;
        background: white !important;
        color: #b29cfb !important;
        padding: 10px 20px !important;
        border-radius: 20px !important;
        font-size: 13px !important;
        font-weight: 500 !important;
        white-space: nowrap !important;
        text-align: center !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
        box-shadow: 0 0 20px rgba(178, 156, 251, 0.3), 0 4px 12px rgba(178, 156, 251, 0.2) !important;
        z-index: 9999999 !important;
        pointer-events: none !important;
        opacity: 0 !important;
        transform: translateY(5px) scale(0.95) !important;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                   transform 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        visibility: visible !important;
        width: auto !important;
        height: auto !important;
        min-height: 40px !important;
      }

      .vocab-btn-tooltip.visible {
        opacity: 1 !important;
        transform: translateY(0) scale(1) !important;
      }

      /* Tooltip arrow */
      .vocab-btn-tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 20px;
        border: 6px solid transparent;
        border-top-color: white;
        filter: drop-shadow(0 2px 3px rgba(167, 139, 250, 0.2));
      }

      /* Button container needs relative positioning for tooltip */
      .vocab-btn {
        position: relative;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .vocab-helper-panel {
          left: 0;
        }

        .vocab-button-group-main {
          display: none !important;
          padding: 4px;
        }

        .vocab-btn {
          width: 40px;
          height: 40px;
          padding: 10px;
        }

        .vocab-btn-icon {
          width: 18px;
          height: 18px;
        }
        
        .vocab-btn-icon svg {
          width: 18px;
          height: 18px;
        }
      }


      /* Topics Modal Styles */
      .vocab-topics-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000000;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .vocab-topics-modal-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .vocab-topics-modal {
        background: white;
        border-radius: 20px;
        box-shadow: 0 25px 50px rgba(162, 78, 255, 0.25), 0 0 0 1px rgba(162, 78, 255, 0.1);
        padding: 20px;
        max-width: 700px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        transform: scale(0.9) translateY(20px);
        opacity: 0;
        visibility: hidden;
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        position: relative;
      }

      .vocab-topics-content-container {
        background: #F8F4FF;
        border-radius: 16px;
        padding: 20px;
        margin-top: 20px;
        max-height: calc(80vh - 120px);
        overflow-y: auto;
      }

      .vocab-topics-modal.visible {
        transform: scale(1) translateY(0);
        opacity: 1;
        visibility: visible;
      }

      .vocab-topics-modal-header {
        position: relative;
        margin: 20px 0 30px 0;
        text-align: center;
      }

      .vocab-topics-modal-title {
        font-size: 28px;
        font-weight: 400;
        color: #9B6EDA;
        margin: 0;
        text-align: center;
      }

      .vocab-topics-modal-close {
        position: absolute;
        top: 4px;
        right: 4px;
        background: none;
        border: none;
        color: #9B6EDA;
        font-size: 32px;
        font-weight: 200;
        cursor: pointer;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s ease, transform 0.2s ease;
        border-radius: 50%;
        padding: 0;
        z-index: 10;
      }

      .vocab-topics-modal-close:hover {
        color: #7A5BC7;
        transform: scale(1.2);
      }

      .vocab-topics-modal-close svg {
        width: 24px;
        height: 24px;
        stroke-width: 1.5;
      }


      /* First Container - Input */
      .vocab-topics-first-container {
        margin-bottom: 25px;
      }

      .vocab-topics-input-section {
        width: 70%;
        margin: 0 auto;
      }

      .vocab-topics-input-container {
        position: relative;
      }

      .vocab-topics-generate-btn {
        background: #A24EFF;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 15px;
        font-size: 20px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.2s ease;
        font-family: inherit;
        white-space: nowrap;
        min-width: 150px;
        margin: 15px auto 0;
        display: block;
      }

      .vocab-topics-generate-btn:hover {
        background: #7A5BC7;
        transform: scale(1.05);
      }

      .vocab-topics-generate-btn:active {
        background: #7A5BC7;
      }

      /* Second Container - Topic Tags + Controls */
      .vocab-topics-second-container {
        display: flex;
        gap: 20px;
        align-items: stretch;
      }

      .vocab-topics-tags-section {
        flex: 2;
      }

      .vocab-topics-controls-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 35px;
        justify-content: center;
      }

      .vocab-topics-input {
        width: 100%;
        padding: 8px 45px 8px 16px;
        border: 2px solid #E6D6FF;
        border-radius: 25px;
        font-size: 16px;
        background: white;
        color: #333;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        box-sizing: border-box;
        font-family: inherit;
        text-align: center;
      }

      .vocab-topics-input:focus {
        outline: none;
        border-color: #A24EFF;
        box-shadow: 0 0 0 3px rgba(162, 78, 255, 0.1);
      }

      .vocab-topics-input::placeholder {
        color: #B19CD9;
        font-style: italic;
        font-weight: 300;
      }

      .vocab-topics-search-icon {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #A24EFF;
        cursor: pointer;
        transition: background-color 0.2s ease, opacity 0.2s ease;
        background: #A24EFF;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .vocab-topics-search-icon:hover:not(.disabled) {
        background: #8B3AE8;
      }

      .vocab-topics-search-icon.disabled {
        background: #c5aee3;
        cursor: pointer;
        opacity: 0.6;
      }

      .vocab-topics-tags-container {
        margin-bottom: 15px;
        height: 200px;
        border: 2px solid #E6D6FF;
        border-radius: 16px;
        padding: 12px;
        background: white;
        flex: 2;
        overflow-y: auto;
      }


      .vocab-topics-second-container {
        transition: opacity 0.3s ease, transform 0.3s ease;
        opacity: 1;
        transform: translateY(0);
      }

      .vocab-topics-second-container.hidden {
        display: none;
        opacity: 0;
        transform: translateY(-10px);
        pointer-events: none;
      }

      .vocab-topics-generate-btn.hidden {
        display: none;
        opacity: 0;
        transform: translateY(-10px);
        pointer-events: none;
      }

      .vocab-topics-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 36px;
      }

      .vocab-topics-tag {
        background: #E6D6FF;
        color: #A24EFF;
        padding: 2px 6px 2px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 3px;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .vocab-topics-tag-remove {
        background: none;
        border: none;
        color: #A24EFF;
        cursor: pointer;
        font-size: 18px;
        font-weight: 400;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s ease, transform 0.2s ease;
      }

      .vocab-topics-tag-remove:hover {
        background-color: rgba(162, 78, 255, 0.1);
      }

      .vocab-topics-control-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
        justify-content: center;
      }

      .vocab-topics-word-count-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
        justify-content: center;
        align-items: center;
      }

      .vocab-topics-difficulty-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
        justify-content: center;
        align-items: center;
      }

      .vocab-topics-control-label {
        font-size: 20px;
        font-weight: 500;
        color: #9B6EDA;
        margin: 0;
        font-family: inherit;
      }

      .vocab-topics-word-count-buttons {
        display: flex;
        background: white;
        border: 1px solid #E6D6FF;
        border-radius: 12px;
        padding: 2px;
        position: relative;
        width: fit-content;
        align-items: center;
      }

      .vocab-topics-word-count-slider {
        position: absolute;
        top: 2px;
        left: 2px;
        height: calc(100% - 4px);
        background: #9B6EDA;
        border-radius: 10px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1;
      }

      .vocab-topics-word-count-btn {
        padding: 8px 20px;
        border: none;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 500;
        color: #9B6EDA;
        cursor: pointer;
        background: white;
        font-family: inherit;
        position: relative;
        z-index: 2;
        min-width: 70px;
        text-align: center;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease, transform 0.2s ease;
      }

      .vocab-topics-word-count-btn:hover {
        background-color: rgba(155, 110, 218, 0.1);
      }

      .vocab-topics-word-count-btn:active {
        transform: scale(0.95);
      }

      .vocab-topics-word-count-btn.selected {
        color: white;
        background: transparent;
      }

      .vocab-topics-difficulty-buttons {
        display: flex;
        background: white;
        border: 1px solid #E6D6FF;
        border-radius: 12px;
        padding: 2px;
        position: relative;
        width: fit-content;
        align-items: center;
      }

      .vocab-topics-difficulty-slider {
        position: absolute;
        top: 2px;
        left: 2px;
        height: calc(100% - 4px);
        background: #9B6EDA;
        border-radius: 10px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1;
      }

      .vocab-topics-difficulty-btn {
        padding: 8px 20px;
        border: none;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        background: white;
        font-family: inherit;
        position: relative;
        z-index: 2;
        min-width: 70px;
        text-align: center;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease, transform 0.2s ease;
      }

      .vocab-topics-difficulty-btn:hover {
        background-color: rgba(155, 110, 218, 0.1);
      }

      .vocab-topics-difficulty-btn:active {
        transform: scale(0.95);
      }

      .vocab-topics-difficulty-btn.easy {
        color: #36D86B;
      }

      .vocab-topics-difficulty-btn.medium {
        color: #F9D43F;
      }

      .vocab-topics-difficulty-btn.hard {
        color: #FF4D4D;
      }

      .vocab-topics-difficulty-btn.selected {
        color: white;
        background: transparent;
      }

      .vocab-topics-difficulty-btn.easy.selected ~ .vocab-topics-difficulty-slider {
        background: #36D86B;
      }

      .vocab-topics-difficulty-btn.medium.selected ~ .vocab-topics-difficulty-slider {
        background: #F9D43F;
      }

      .vocab-topics-difficulty-btn.hard.selected ~ .vocab-topics-difficulty-slider {
        background: #FF4D4D;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .vocab-topics-modal {
          padding: 30px;
          margin: 20px;
          width: calc(100% - 40px);
          max-width: 650px;
        }

        .vocab-topics-modal-title {
          font-size: 24px;
        }

        .vocab-topics-first-container {
          margin-bottom: 20px;
        }

        .vocab-topics-input-section {
          width: 80%;
        }

        .vocab-topics-second-container {
          flex-direction: column;
          gap: 20px;
        }

        .vocab-topics-tags-container {
          height: 150px;
          margin-bottom: 15px;
        }

        .vocab-topics-input {
          font-size: 16px;
          padding: 14px 45px 14px 14px;
        }

        .vocab-topics-difficulty-buttons {
          flex-direction: column;
        }

        .vocab-topics-difficulty-btn {
          flex: none;
        }

        .vocab-topics-word-count-buttons {
          width: 100%;
        }

        .vocab-topics-difficulty-buttons {
          width: 100%;
        }
      }

      @media (max-width: 480px) {
        .vocab-topics-modal {
          padding: 25px;
          margin: 15px;
          width: calc(100% - 30px);
          max-width: 600px;
        }

        .vocab-topics-modal-title {
          font-size: 22px;
        }

        .vocab-topics-generate-btn {
          padding: 14px 24px;
          font-size: 16px;
          min-width: auto;
          width: 100%;
          margin: 10px auto 0;
        }

        .vocab-topics-input-section {
          width: 85%;
        }

        .vocab-topics-tags-container {
          height: 120px;
          margin-bottom: 10px;
        }
      }

      /* Image Upload Modal Styles */
      .vocab-image-upload-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        padding: 20px;
        box-sizing: border-box;
      }

      .vocab-image-upload-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .vocab-image-upload-overlay.drag-over {
        background: rgba(149, 39, 245, 0.1);
      }

      .vocab-image-upload-modal {
        background: white;
        border-radius: 40px;
        padding: 0;
        width: 90%;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 25px 50px rgba(149, 39, 245, 0.25), 0 0 0 1px rgba(149, 39, 245, 0.1);
        transform: scale(0.9) translateY(20px);
        opacity: 0;
        visibility: hidden;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, visibility 0.3s ease;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .vocab-image-upload-modal.visible {
        transform: scale(1) translateY(0);
        opacity: 1;
        visibility: visible;
      }

      @keyframes modalSlideIn {
        0% {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .vocab-image-upload-header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px 24px 15px 24px;
        position: relative;
      }

      .vocab-image-upload-title {
        font-size: 24px;
        font-weight: 500;
        color: #9B6EDA;
        margin: 0;
        padding: 0;
        line-height: 1.2;
      }

      .vocab-image-upload-close {
        position: absolute;
        right: 20px;
        top: 20px;
        background: none;
        border: none;
        color: #A24EFF;
        cursor: pointer;
        padding: 8px;
        border-radius: 8px;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .vocab-image-upload-close:hover {
        transform: scale(1.2);
      }

      .vocab-image-upload-content {
        padding: 0 24px 24px 24px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }

      .vocab-image-upload-content-container {
        background: #FCF8FF;
        border: 2px dashed rgba(162, 78, 255, 0.4);
        border-radius: 30px;
        padding: 30px 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
        width: calc(100% - 80px);
        margin: 10px 40px 5px 40px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .vocab-image-upload-content-container:hover {
        border-color: rgba(162, 78, 255, 0.6);
        transform: scale(1.02);
      }

      .vocab-image-upload-icon {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100px;
        height: 100px;
        background: transparent;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .vocab-image-upload-icon:hover {
        background: transparent;
        transform: scale(1.05);
      }

      .vocab-image-upload-plus {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        font-weight: 700;
        color: #9527F5;
        pointer-events: none;
      }

      .vocab-image-upload-instructions {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-width: 400px;
      }

      .vocab-image-upload-main-text {
        font-size: 18px;
        font-weight: 600;
        color: #666;
        margin: 0;
        line-height: 1.4;
      }

      .vocab-image-upload-format-text {
        font-size: 16px;
        font-weight: 400;
        color: #888;
        margin: 0;
        line-height: 1.4;
      }

      .vocab-image-upload-secondary-text {
        font-size: 14px;
        color: #666;
        margin: 0;
        line-height: 1.5;
      }

      .vocab-image-upload-size-text {
        font-size: 13px;
        color: #999;
        margin: 0;
        font-weight: 500;
      }

      .vocab-image-upload-browse-btn {
        background: #A24EFF;
        color: white;
        border: none;
        border-radius: 15px;
        padding: 12px 24px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 150px;
        margin: 15px auto 0;
        display: block;
      }

      .vocab-image-upload-browse-btn:hover {
        background: #7A5BC7;
        transform: scale(1.05);
      }

      .vocab-image-upload-browse-btn:active {
        background: #7A5BC7;
        transform: scale(0.95);
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .vocab-image-upload-modal {
          width: 95%;
          margin: 20px;
        }

        .vocab-image-upload-title {
          font-size: 20px;
        }

        .vocab-image-upload-content {
          padding: 0 20px 20px 20px;
          gap: 16px;
        }

        .vocab-image-upload-content-container {
          padding: 24px 20px;
          gap: 20px;
          width: calc(100% - 60px);
          margin: 30px 30px 5px 30px;
        }

        .vocab-image-upload-icon {
          width: 80px;
          height: 80px;
        }

        .vocab-image-upload-plus {
          font-size: 20px;
        }

        .vocab-image-upload-main-text {
          font-size: 16px;
        }

        .vocab-image-upload-secondary-text {
          font-size: 13px;
        }

        .vocab-image-upload-browse-btn {
          padding: 12px 24px;
          font-size: 15px;
        }
      }

      @media (max-width: 480px) {
        .vocab-image-upload-overlay {
          padding: 10px;
        }

        .vocab-image-upload-modal {
          width: 98%;
          margin: 10px;
        }

        .vocab-image-upload-header {
          padding: 20px 20px 12px 20px;
        }

        .vocab-image-upload-title {
          font-size: 18px;
        }

        .vocab-image-upload-content {
          padding: 0 16px 16px 16px;
          gap: 14px;
        }

        .vocab-image-upload-content-container {
          padding: 20px 16px;
          gap: 18px;
          width: calc(100% - 40px);
          margin: 20px 20px 5px 20px;
        }

        .vocab-image-upload-icon {
          width: 70px;
          height: 70px;
        }

        .vocab-image-upload-plus {
          font-size: 18px;
        }

        .vocab-image-upload-main-text {
          font-size: 15px;
        }

        .vocab-image-upload-secondary-text {
          font-size: 12px;
        }

        .vocab-image-upload-size-text {
          font-size: 11px;
        }

        .vocab-image-upload-browse-btn {
          padding: 10px 20px;
          font-size: 14px;
          min-width: 100px;
        }
      }

      /* PDF Upload Modal Styles */
      .vocab-pdf-upload-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        padding: 20px;
        box-sizing: border-box;
      }

      .vocab-pdf-upload-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .vocab-pdf-upload-overlay.drag-over {
        background: rgba(149, 39, 245, 0.1);
      }

      .vocab-pdf-upload-modal {
        background: white;
        border-radius: 40px;
        padding: 0;
        width: 90%;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 25px 50px rgba(149, 39, 245, 0.25), 0 0 0 1px rgba(149, 39, 245, 0.1);
        transform: scale(0.9) translateY(20px);
        opacity: 0;
        visibility: hidden;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, visibility 0.3s ease;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .vocab-pdf-upload-modal.visible {
        transform: scale(1) translateY(0);
        opacity: 1;
        visibility: visible;
      }

      .vocab-pdf-upload-header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px 24px 15px 24px;
        position: relative;
      }

      .vocab-pdf-upload-title {
        font-size: 24px;
        font-weight: 500;
        color: #9B6EDA;
        margin: 0;
        padding: 0;
        text-align: center;
      }

      .vocab-pdf-upload-close {
        position: absolute;
        right: 20px;
        top: 20px;
        background: none;
        border: none;
        color: #A24EFF;
        cursor: pointer;
        padding: 8px;
        border-radius: 8px;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .vocab-pdf-upload-close:hover {
        transform: scale(1.2);
      }

      .vocab-pdf-upload-close svg {
        width: 24px;
        height: 24px;
        stroke-width: 1.5;
      }

      .vocab-pdf-upload-content {
        padding: 0 24px 24px 24px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }

      .vocab-pdf-upload-content-container {
        background: #FCF8FF;
        border: 2px dashed rgba(162, 78, 255, 0.4);
        border-radius: 30px;
        padding: 30px 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
        width: calc(100% - 80px);
        margin: 10px 40px 5px 40px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .vocab-pdf-upload-content-container:hover {
        border-color: rgba(162, 78, 255, 0.6);
        transform: scale(1.02);
      }

      .vocab-pdf-upload-icon {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 120px;
        height: 120px;
        background: transparent;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .vocab-pdf-upload-icon:hover {
        background: transparent;
        transform: scale(1.05);
      }

      .vocab-pdf-upload-plus {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        color: #9527F5;
        font-weight: bold;
        pointer-events: none;
      }

      .vocab-pdf-upload-instructions {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
      }

      .vocab-pdf-upload-main-text {
        font-size: 18px;
        color: #333;
        margin: 0;
        font-weight: 500;
      }

      .vocab-pdf-upload-secondary-text {
        font-size: 14px;
        color: #666;
        margin: 0;
        line-height: 1.5;
      }

      .vocab-pdf-upload-size-text {
        font-size: 13px;
        color: #999;
        margin: 0;
        font-weight: 500;
      }

      .vocab-pdf-upload-browse-btn {
        background: #A24EFF;
        color: white;
        border: none;
        border-radius: 15px;
        padding: 12px 24px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 150px;
        margin: 15px auto 0;
        display: block;
      }

      .vocab-pdf-upload-browse-btn:hover {
        background: #7A5BC7;
        transform: scale(1.05);
      }

      .vocab-pdf-upload-browse-btn:active {
        background: #7A5BC7;
        transform: scale(0.95);
      }

      /* Responsive styles for PDF upload modal */
      @media (max-width: 768px) {
        .vocab-pdf-upload-modal {
          width: 95%;
          margin: 20px;
        }

        .vocab-pdf-upload-title {
          font-size: 20px;
        }

        .vocab-pdf-upload-content {
          padding: 0 20px 20px 20px;
          gap: 16px;
        }

        .vocab-pdf-upload-content-container {
          padding: 24px 20px;
          gap: 20px;
          width: calc(100% - 60px);
          margin: 30px 30px 5px 30px;
        }

        .vocab-pdf-upload-icon {
          width: 100px;
          height: 100px;
        }

        .vocab-pdf-upload-plus {
          font-size: 20px;
        }

        .vocab-pdf-upload-main-text {
          font-size: 16px;
        }

        .vocab-pdf-upload-secondary-text {
          font-size: 13px;
        }

        .vocab-pdf-upload-size-text {
          font-size: 11px;
        }

        .vocab-pdf-upload-browse-btn {
          padding: 12px 24px;
          font-size: 15px;
        }
      }

      @media (max-width: 480px) {
        .vocab-pdf-upload-modal {
          width: 98%;
          margin: 10px;
        }

        .vocab-pdf-upload-header {
          padding: 20px 20px 12px 20px;
        }

        .vocab-pdf-upload-title {
          font-size: 18px;
        }

        .vocab-pdf-upload-content {
          padding: 0 16px 16px 16px;
          gap: 14px;
        }

        .vocab-pdf-upload-content-container {
          padding: 20px 16px;
          gap: 18px;
          width: calc(100% - 40px);
          margin: 20px 20px 5px 20px;
        }

        .vocab-pdf-upload-icon {
          width: 90px;
          height: 90px;
        }

        .vocab-pdf-upload-plus {
          font-size: 18px;
        }

        .vocab-pdf-upload-main-text {
          font-size: 15px;
        }

        .vocab-pdf-upload-secondary-text {
          font-size: 12px;
        }

        .vocab-pdf-upload-size-text {
          font-size: 11px;
        }

        .vocab-pdf-upload-browse-btn {
          padding: 10px 20px;
          font-size: 14px;
          min-width: 100px;
        }
      }

      /* Text Input Modal Styles */
      .vocab-text-input-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000001;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 20px;
        box-sizing: border-box;
      }

      .vocab-text-input-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .vocab-text-input-modal {
        background: white;
        border-radius: 20px;
        padding: 0;
        width: 90%;
        max-width: 800px;
        max-height: 80vh;
        transform: scale(0.9) translateY(20px);
        opacity: 0;
        visibility: hidden;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, visibility 0.3s ease;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .vocab-text-input-modal.visible {
        transform: scale(1) translateY(0);
        opacity: 1;
        visibility: visible;
      }

      .vocab-text-input-header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 30px 40px 20px 40px;
        position: relative;
        border-bottom: 1px solid #f0f0f0;
      }

      .vocab-text-input-title {
        font-size: 28px;
        font-weight: 400;
        color: #9B6EDA;
        margin: 0;
        text-align: center;
      }

      .vocab-text-input-close {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #A24EFF;
        transition: all 0.2s ease;
      }

      .vocab-text-input-close:hover {
        background: #f5f5f5;
        color: #7A5BC7;
        transform: translateY(-50%) scale(1.2);
      }

      .vocab-text-input-close svg {
        width: 20px;
        height: 20px;
      }

      .vocab-text-input-search {
        display: flex;
        justify-content: center;
        padding: 20px 40px;
        transition: opacity 0.3s ease, max-height 0.3s ease;
      }

      .vocab-text-input-search.hidden {
        display: none;
      }

      .vocab-text-input-search-input {
        width: 400px;
        padding: 8px 20px;
        border: 1px solid #D1B3FF;
        border-radius: 25px;
        font-size: 16px;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        outline: none;
        transition: border-color 0.2s ease;
        box-sizing: border-box;
        text-align: center;
      }

      .vocab-text-input-search-input:focus {
        border-color: #A24EFF;
      }

      .vocab-text-input-content {
        padding: 20px 40px 10px 40px;
        flex: 1;
        display: flex;
        flex-direction: column;
        transition: padding 0.3s ease;
      }

      .vocab-text-input-content.empty {
        padding-bottom: 40px;
      }

      .vocab-text-input-textarea {
        width: 100%;
        min-height: 200px;
        max-height: 400px;
        padding: 20px;
        border: 1px solid #D1B3FF;
        border-radius: 20px;
        font-size: 16px;
        font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        line-height: 1.5;
        resize: none;
        outline: none;
        transition: border-color 0.2s ease;
        box-sizing: border-box;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .vocab-text-input-textarea:focus {
        border-color: #A24EFF;
      }

      .vocab-text-input-textarea::placeholder {
        color: #999;
      }

      .vocab-text-input-textarea:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }

      .vocab-text-input-textarea .vocab-search-highlight {
        background: linear-gradient(120deg, #FFE066 0%, #FFD700 100%);
        padding: 2px 4px;
        border-radius: 4px;
        font-weight: 600;
        box-shadow: 0 2px 4px rgba(255, 224, 102, 0.3);
      }

      /* Custom scrollbar for textarea */
      .vocab-text-input-textarea::-webkit-scrollbar {
        width: 8px;
      }

      .vocab-text-input-textarea::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
      }

      .vocab-text-input-textarea::-webkit-scrollbar-thumb {
        background: #D1B3FF;
        border-radius: 4px;
      }

      .vocab-text-input-textarea::-webkit-scrollbar-thumb:hover {
        background: #A24EFF;
      }

      .vocab-text-input-textarea-container {
        position: relative;
        width: 100%;
      }

      .vocab-text-input-proceed-btn {
        background: #A24EFF;
        color: white;
        border: none;
        border-radius: 20px;
        padding: 16px 32px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
        align-self: center;
        margin: 10px 0 20px 0;
        min-width: 120px;
      }

      .vocab-text-input-proceed-btn.hidden {
        display: none;
      }

      .vocab-text-input-proceed-btn:hover {
        background: #7A5BC7;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(162, 78, 255, 0.3);
      }

      .vocab-text-input-proceed-btn:active {
        transform: translateY(0);
      }

      /* Responsive Design for Text Input Modal */
      @media (max-width: 768px) {
        .vocab-text-input-modal {
          width: 95%;
          margin: 20px;
        }

        .vocab-text-input-title {
          font-size: 20px;
        }

        .vocab-text-input-header {
          padding: 20px 30px 15px 30px;
        }

        .vocab-text-input-search {
          padding: 15px 30px;
        }

        .vocab-text-input-search-input {
          width: 350px;
          padding: 6px 16px;
          font-size: 15px;
        }

        .vocab-text-input-content {
          padding: 15px 30px 5px 30px;
        }

        .vocab-text-input-textarea {
          min-height: 150px;
          max-height: 300px;
          font-size: 15px;
        }

        .vocab-text-input-proceed-btn {
          padding: 14px 28px;
          font-size: 15px;
          margin: 10px 0 20px 0;
        }
      }

      @media (max-width: 480px) {
        .vocab-text-input-overlay {
          padding: 10px;
        }

        .vocab-text-input-modal {
          width: 98%;
          margin: 10px;
        }

        .vocab-text-input-header {
          padding: 15px 20px 10px 20px;
        }

        .vocab-text-input-title {
          font-size: 18px;
        }

        .vocab-text-input-search {
          padding: 10px 20px;
        }

        .vocab-text-input-search-input {
          width: 280px;
          padding: 6px 14px;
          font-size: 14px;
        }

        .vocab-text-input-content {
          padding: 10px 20px 5px 20px;
        }

        .vocab-text-input-textarea {
          min-height: 120px;
          max-height: 250px;
          font-size: 14px;
        }

        .vocab-text-input-proceed-btn {
          padding: 12px 24px;
          font-size: 14px;
          margin: 10px 0 15px 0;
        }
      }

      /* Reference Marker Styles */
      .vocab-reference-marker {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        background-color: #9527F5;
        border-radius: 50%;
        color: white;
        font-size: 12px;
        font-weight: bold;
        cursor: pointer;
        margin: 0 2px;
        vertical-align: middle;
        transition: all 0.2s ease;
        user-select: none;
      }

      .vocab-reference-marker:hover {
        background-color: #7a1fd9;
        transform: scale(1.1);
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4);
      }

      .vocab-reference-marker:active {
        transform: scale(0.95);
      }

      /* Reference Button Styles (all buttons are circular) */
      .vocab-ref-button,
      .vocab-ref-button-circular {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        background-color: #9527F5;
        border: none;
        border-radius: 50%;
        color: white;
        font-size: 10px;
        font-weight: bold;
        cursor: pointer;
        margin: 0 2px;
        vertical-align: middle;
        transition: all 0.2s ease;
        user-select: none;
        font-family: inherit;
        line-height: 1;
        padding: 0;
      }

      .vocab-ref-button-circular:hover {
        background-color: #7a1fd9;
        transform: scale(1.1);
        box-shadow: 0 2px 8px rgba(149, 39, 245, 0.4);
      }

      .vocab-ref-button-circular:active {
        transform: scale(0.95);
        background-color: #6a1ac7;
      }

      .vocab-ref-button-circular:focus {
        outline: 2px solid rgba(149, 39, 245, 0.5);
        outline-offset: 2px;
      }

      /* Reference Highlight Styles */
      /* Only modify background and visual effects - preserve all text styling */
      .vocab-reference-highlight {
        background-color: rgba(144, 238, 144, 0.3) !important;
        border: 1px solid #4ade80 !important;
        transition: background-color 0.4s ease-in-out, border-color 0.4s ease-in-out, padding 0.3s ease-in-out;
        padding: 4px 8px;
        border-radius: 15px;
        animation: vocab-highlight-fade-in 0.4s ease-in-out;
        box-sizing: border-box !important;
        /* DO NOT set any font/text properties - let them remain as computed */
        /* The element's existing computed styles will be preserved automatically */
      }
      
      /* Ensure nested elements keep their original styling */
      /* Bold text should remain bold */
      .vocab-reference-highlight strong,
      .vocab-reference-highlight b {
        font-weight: bold !important;
      }
      
      /* Italic text should remain italic */
      .vocab-reference-highlight em,
      .vocab-reference-highlight i {
        font-style: italic !important;
      }
      
      /* Underlined text should remain underlined */
      .vocab-reference-highlight u {
        text-decoration: underline !important;
      }
      
      /* Preserve any inline styles completely - they have highest specificity */
      /* No CSS rules here - inline styles will naturally take precedence */
      
      /* Smooth fade-in animation for highlight */
      @keyframes vocab-highlight-fade-in {
        from {
          background-color: rgba(144, 238, 144, 0);
          border-color: rgba(74, 222, 128, 0);
        }
        to {
          background-color: rgba(144, 238, 144, 0.3);
          border-color: #4ade80;
        }
      }
      
      /* Smooth fade-out when highlight is removed */
      .vocab-reference-highlight-removing {
        animation: vocab-highlight-fade-out 0.4s ease-in-out forwards;
      }
      
      @keyframes vocab-highlight-fade-out {
        from {
          background-color: rgba(144, 238, 144, 0.3);
          border-color: #4ade80;
        }
        to {
          background-color: rgba(144, 238, 144, 0);
          border-color: rgba(74, 222, 128, 0);
        }
      }

      /* ===================================
         Processing Spinner Animation
         =================================== */
      .vocab-processing-spinner {
        animation: vocab-spin 1s linear infinite;
      }

      @keyframes vocab-spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* ===================================
         Magic Meaning Button States
         =================================== */
      .vocab-btn.processing {
        pointer-events: none;
        opacity: 1;
      }

      .vocab-btn.success {
        background: #22c55e !important;
        border-color: #22c55e !important;
      }

      .vocab-btn.success:hover {
        background: #16a34a !important;
        border-color: #16a34a !important;
      }

      /* Magic Meaning Button - Ready/Enabled State Animation */
      #magic-meaning:not(.disabled):not(.processing):not(.success) {
        position: relative;
        overflow: hidden;
        isolation: isolate;
      }

      /* Attention-grabbing animation when button becomes enabled */


    `;

    document.head.appendChild(style);
  },

  /**
   * Attach event listeners to buttons
   */
  attachEventListeners() {
    const buttons = {
      magicMeaning: document.getElementById('magic-meaning'),
      ask: document.getElementById('ask')
    };

    // Magic meaning button
    buttons.magicMeaning?.addEventListener('click', (e) => {
      if (buttons.magicMeaning.classList.contains('disabled')) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      console.log('Magic meaning clicked');
      this.handleMagicMeaning();
    });

    // Ask button
    buttons.ask?.addEventListener('click', (e) => {
      if (buttons.ask.classList.contains('disabled')) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      console.log('Ask clicked');
      this.handleAsk();
    });

    // Add tooltip event listeners
    
    if (buttons.magicMeaning) {
      console.log('[ButtonPanel] Attaching tooltip to Magic meaning button');
      this.attachTooltipListeners(buttons.magicMeaning, 'magic-meaning');
    } else {
      console.warn('[ButtonPanel] Magic meaning button not found');
    }
    
    if (buttons.ask) {
      console.log('[ButtonPanel] Attaching tooltip to Ask button');
      this.attachTooltipListeners(buttons.ask, 'ask');
    } else {
      console.warn('[ButtonPanel] Ask button not found');
    }
  },

  /**
   * Attach tooltip event listeners to a button
   * @param {HTMLElement} button - Button element
   * @param {string} buttonType - Type of button ('magic-meaning' or 'ask')
   */
  attachTooltipListeners(button, buttonType) {
    if (!button) {
      console.log(`[ButtonPanel] attachTooltipListeners: No button provided for ${buttonType}`);
      return;
    }

    console.log(`[ButtonPanel] attachTooltipListeners: Setting up tooltip for ${buttonType} button`, button);

    let tooltip = null;

    button.addEventListener('mouseenter', () => {
      console.log(`[ButtonPanel] Mouse enter on ${buttonType} button`);
      console.log(`[ButtonPanel] Button element:`, button);
      console.log(`[ButtonPanel] Button classes:`, button.className);
      
      // Clean up any existing tooltips first
      this.removeAllTooltips();
      
      const isDisabled = button.classList.contains('disabled');
      console.log(`[ButtonPanel] Is disabled: ${isDisabled}`);
      
      let message = '';

      // Determine tooltip message based on button type and state
      if (buttonType === 'magic-meaning') {
        message = isDisabled 
          ? 'Select words or passages first' 
          : 'Get contextual explanations';
        console.log(`[ButtonPanel] Magic-meaning button message: "${message}"`);
      } else if (buttonType === 'ask') {
        if (isDisabled) {
          // Check specific conditions for Ask button
          const textCount = TextSelector.selectedTexts.size;
          if (textCount === 0) {
            message = 'Select a text first';
          } else if (textCount > 1) {
            message = 'Select only one text';
          } else {
            message = 'Select a text first'; // Fallback
          }
        } else {
          message = 'Ask anything about the selected content';
        }
        console.log(`[ButtonPanel] Ask button message: "${message}" (textCount: ${TextSelector.selectedTexts.size})`);
      } else if (buttonType === 'pdf-upload') {
        // Check if PDF content exists
        const hasContent = this.topicsModal && this.topicsModal.customContentModal && 
                          this.topicsModal.customContentModal.pdfContents && 
                          this.topicsModal.customContentModal.pdfContents.length > 0;
        message = hasContent ? 'View PDF content' : 'Upload PDF containing text';
        console.log(`[ButtonPanel] PDF-upload button message: "${message}" (hasContent: ${hasContent})`);
      } else if (buttonType === 'image-upload') {
        // Check if image content exists
        const hasContent = this.topicsModal && this.topicsModal.customContentModal && 
                          this.topicsModal.customContentModal.imageContents && 
                          this.topicsModal.customContentModal.imageContents.length > 0;
        message = hasContent ? 'View image content' : 'Upload image containing text';
        console.log(`[ButtonPanel] Image-upload button message: "${message}" (hasContent: ${hasContent})`);
      } else if (buttonType === 'topics-input') {
        // Check if topics content exists
        const hasContent = this.topicsModal && this.topicsModal.customContentModal && 
                          this.topicsModal.customContentModal.topicContents && 
                          this.topicsModal.customContentModal.topicContents.length > 0;
        message = hasContent ? 'View keyword content' : 'Keywords or topics which you want to study on';
        console.log(`[ButtonPanel] Topics-input button message: "${message}" (hasContent: ${hasContent})`);
      } else if (buttonType === 'text-input') {
        // Check if text content exists
        const hasContent = this.topicsModal && this.topicsModal.customContentModal && 
                          this.topicsModal.customContentModal.textContents && 
                          this.topicsModal.customContentModal.textContents.length > 0;
        message = hasContent ? 'View text content' : 'Copy content from elsewhere and paste here';
        console.log(`[ButtonPanel] Text-input button message: "${message}" (hasContent: ${hasContent})`);
      }

      console.log(`[ButtonPanel] Final tooltip message: "${message}" (disabled: ${isDisabled})`);

      // Create and show tooltip
      console.log(`[ButtonPanel] Creating tooltip element...`);
      tooltip = this.createTooltip(message);
      console.log(`[ButtonPanel] Tooltip created:`, tooltip);
      
      console.log(`[ButtonPanel] Appending tooltip to document.body...`);
      document.body.appendChild(tooltip);
      console.log(`[ButtonPanel] Tooltip appended to body`);
      
      // Position tooltip relative to button (top-right since panel is on left)
      const buttonRect = button.getBoundingClientRect();
      tooltip.style.position = 'fixed';
      tooltip.style.top = (buttonRect.top - 50) + 'px';
      // Position tooltip to the right of the button
      tooltip.style.left = (buttonRect.right + 10) + 'px';
      tooltip.style.zIndex = '9999999';
      console.log(`[ButtonPanel] Tooltip positioned at:`, tooltip.style.top, tooltip.style.left);
      console.log(`[ButtonPanel] Button rect:`, buttonRect);
      
      // Trigger animation
      console.log(`[ButtonPanel] Setting timeout to show tooltip...`);
      setTimeout(() => {
        console.log(`[ButtonPanel] Adding 'visible' class to tooltip...`);
        tooltip.classList.add('visible');
        console.log(`[ButtonPanel] Tooltip classes after adding visible:`, tooltip.className);
        const computedStyle = window.getComputedStyle(tooltip);
        console.log(`[ButtonPanel] Tooltip computed style - display:`, computedStyle.display);
        console.log(`[ButtonPanel] Tooltip computed style - visibility:`, computedStyle.visibility);
        console.log(`[ButtonPanel] Tooltip computed style - opacity:`, computedStyle.opacity);
        console.log(`[ButtonPanel] Tooltip computed style - position:`, computedStyle.position);
        console.log(`[ButtonPanel] Tooltip computed style - z-index:`, computedStyle.zIndex);
        console.log(`[ButtonPanel] Tooltip computed style - top:`, computedStyle.top);
        console.log(`[ButtonPanel] Tooltip computed style - right:`, computedStyle.right);
        console.log(`[ButtonPanel] Tooltip computed style - bottom:`, computedStyle.bottom);
        console.log(`[ButtonPanel] Tooltip computed style - pointer-events:`, computedStyle.pointerEvents);
        console.log(`[ButtonPanel] Tooltip getBoundingClientRect:`, tooltip.getBoundingClientRect());
        console.log(`[ButtonPanel] Button getBoundingClientRect:`, button.getBoundingClientRect());
      }, 10);
    });

    button.addEventListener('mouseleave', () => {
      console.log(`[ButtonPanel] Mouse leave on ${buttonType} button`);
      if (tooltip) {
        console.log(`[ButtonPanel] Hiding tooltip...`);
        tooltip.classList.remove('visible');
        setTimeout(() => {
          console.log(`[ButtonPanel] Tooltip removed from DOM`);
          tooltip.remove();
          tooltip = null;
        }, 200);
      } else {
        console.log(`[ButtonPanel] No tooltip to remove`);
      }
    });

    button.addEventListener('click', () => {
      console.log(`[ButtonPanel] Click on ${buttonType} button - hiding tooltip`);
      if (tooltip) {
        console.log(`[ButtonPanel] Hiding tooltip on click...`);
        tooltip.classList.remove('visible');
        setTimeout(() => {
          console.log(`[ButtonPanel] Tooltip removed from DOM on click`);
          tooltip.remove();
          tooltip = null;
        }, 200);
      }
    });
  },

  /**
   * Create a tooltip element
   * @param {string} message - Tooltip message
   * @returns {HTMLElement} Tooltip element
   */
  createTooltip(message) {
    console.log(`[ButtonPanel] createTooltip: Creating tooltip with message: "${message}"`);
    const tooltip = document.createElement('div');
    tooltip.className = 'vocab-btn-tooltip';
    tooltip.textContent = message;
    console.log(`[ButtonPanel] createTooltip: Tooltip element created:`, tooltip);
    console.log(`[ButtonPanel] createTooltip: Tooltip classes:`, tooltip.className);
    console.log(`[ButtonPanel] createTooltip: Tooltip text content:`, tooltip.textContent);
    return tooltip;
  },


  /**
   * Get the current content context (main page or specific custom content tab)
   * @returns {Object} Context object with type, contentType, tabId, and textKeyPrefix
   */
  getCurrentContentContext() {
    // Check if custom content modal is open and has active tab
    if (this.topicsModal && 
        this.topicsModal.customContentModal && 
        this.topicsModal.customContentModal.activeTabId) {
      
      const activeTabId = this.topicsModal.customContentModal.activeTabId;
      const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(activeTabId));
      
      if (activeContent) {
        return {
          type: 'custom-content',
          contentType: activeContent.contentType,
          tabId: activeTabId,
          textKeyPrefix: `${activeContent.contentType}-${activeTabId}`,
          activeContent: activeContent
        };
      }
    }
    
    // Default to main page context
    return {
      type: 'main-page',
      contentType: 'main',
      tabId: null,
      textKeyPrefix: 'main',
      activeContent: null
    };
  },

  /**
   * Check if a textKey belongs to the current context
   * @param {string} textKey - The textKey to check
   * @param {Object} context - The current context (optional, will be detected if not provided)
   * @returns {boolean} True if the textKey belongs to current context
   */
  isTextKeyInCurrentContext(textKey, context = null) {
    if (!context) {
      context = this.getCurrentContentContext();
    }
    
    if (context.type === 'main-page') {
      // For main page, textKey should NOT have content type prefix
      // Main page textKeys are typically just the normalized text
      return !textKey.includes('-') || !['pdf', 'image', 'topic', 'text'].some(type => textKey.startsWith(type + '-'));
    } else {
      // For custom content, textKey should start with the context prefix
      // Format: ${contentType}-${tabId}-${normalizedText}
      return textKey.startsWith(context.textKeyPrefix + '-');
    }
  },

  /**
   * Check if a word belongs to the current context
   * @param {string} word - The word to check
   * @param {Object} context - The current context (optional, will be detected if not provided)
   * @returns {boolean} True if the word belongs to current context
   */
  isWordInCurrentContext(word, context = null) {
    if (!context) {
      context = this.getCurrentContentContext();
    }
    
    // Check if the word has highlights in the current context
    const wordData = WordSelector.explainedWords.get(word);
    if (!wordData || !wordData.highlights) {
      return false;
    }
    
    // For main page context, check if any highlight is in the main document
    if (context.type === 'main-page') {
      return Array.from(wordData.highlights).some(highlight => {
        // Check if highlight is in the main document (not in custom content modal)
        return highlight.closest('.vocab-custom-content-modal') === null;
      });
    } else {
      // For custom content context, check if any highlight is in the current tab's content
      const activeContentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
      return Array.from(wordData.highlights).some(highlight => {
        return activeContentElement && activeContentElement.contains(highlight);
      });
    }
  },


  /**
   * Remove specific asked text from analysis data structure for current tab
   * @param {string} textKey - The text key to remove
   */
  removeAskedTextFromAnalysisData(textKey) {
    console.log('[ButtonPanel] Removing asked text from analysis data:', textKey);
    
    // Check if custom content modal is open and has active tab
    if (!this.topicsModal || !this.topicsModal.customContentModal || !this.topicsModal.customContentModal.activeTabId) {
      console.log('[ButtonPanel] No active tab in custom content modal');
      return;
    }
    
    const activeTabId = this.topicsModal.customContentModal.activeTabId;
    const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(activeTabId));
    
    if (!activeContent || !activeContent.analysis) {
      console.log('[ButtonPanel] No analysis data found for tab:', activeTabId);
      return;
    }
    
    // Remove from chats array if present
    if (activeContent.analysis.chats && activeContent.analysis.chats.length > 0) {
      const initialLength = activeContent.analysis.chats.length;
      activeContent.analysis.chats = activeContent.analysis.chats.filter(chatData => 
        chatData.textKey !== textKey
      );
      
      const removedCount = initialLength - activeContent.analysis.chats.length;
      if (removedCount > 0) {
        console.log('[ButtonPanel] Removed', removedCount, 'chat(s) for textKey:', textKey, 'from analysis data');
        
        // Also remove from ChatDialog's chatHistories
        if (typeof ChatDialog !== 'undefined' && ChatDialog.chatHistories && ChatDialog.chatHistories.has(textKey)) {
          ChatDialog.chatHistories.delete(textKey);
          console.log('[ButtonPanel] Removed chat history from ChatDialog for textKey:', textKey);
        }
      }
    }
  },

  /**
   * Remove specific simplified text from analysis data structure for current tab
   * @param {string} textKey - The text key to remove
   */
  removeSimplifiedTextFromAnalysisData(textKey) {
    console.log('[ButtonPanel] Removing simplified text from analysis data:', textKey);
    
    // Check if custom content modal is open and has active tab
    if (!this.topicsModal || !this.topicsModal.customContentModal || !this.topicsModal.customContentModal.activeTabId) {
      console.log('[ButtonPanel] No active tab in custom content modal');
      return;
    }
    
    const activeTabId = this.topicsModal.customContentModal.activeTabId;
    const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(activeTabId));
    
    if (!activeContent || !activeContent.analysis || !activeContent.analysis.simplifiedMeanings) {
      console.log('[ButtonPanel] No simplified meanings found in analysis data for tab:', activeTabId);
      return;
    }
    
    // Find and remove the specific text from simplifiedMeanings array
    const initialLength = activeContent.analysis.simplifiedMeanings.length;
    activeContent.analysis.simplifiedMeanings = activeContent.analysis.simplifiedMeanings.filter(textData => 
      textData.textKey !== textKey
    );
    
    const removedCount = initialLength - activeContent.analysis.simplifiedMeanings.length;
    if (removedCount > 0) {
      console.log('[ButtonPanel] Removed', removedCount, 'simplified text(s) for textKey:', textKey, 'from analysis data');
    } else {
      console.log('[ButtonPanel] No simplified text found for textKey:', textKey, 'in analysis data');
    }
    
    // Also remove any associated chat history
    if (activeContent.analysis.chats && activeContent.analysis.chats.length > 0) {
      const initialChatLength = activeContent.analysis.chats.length;
      activeContent.analysis.chats = activeContent.analysis.chats.filter(chatData => 
        chatData.textKey !== textKey
      );
      
      const removedChatCount = initialChatLength - activeContent.analysis.chats.length;
      if (removedChatCount > 0) {
        console.log('[ButtonPanel] Also removed', removedChatCount, 'associated chat(s) for textKey:', textKey);
        
        // Also remove from ChatDialog's chatHistories
        if (typeof ChatDialog !== 'undefined' && ChatDialog.chatHistories && ChatDialog.chatHistories.has(textKey)) {
          ChatDialog.chatHistories.delete(textKey);
          console.log('[ButtonPanel] Removed chat history from ChatDialog for textKey:', textKey);
        }
      }
    }
  },

  /**
   * Remove specific word from analysis data structure for current tab
   * @param {string} normalizedWord - The normalized word to remove
   */
  removeWordFromAnalysisData(normalizedWord) {
    console.log('[ButtonPanel] Removing word from analysis data:', normalizedWord);
    
    // Check if custom content modal is open and has active tab
    if (!this.topicsModal || !this.topicsModal.customContentModal || !this.topicsModal.customContentModal.activeTabId) {
      console.log('[ButtonPanel] No active tab in custom content modal');
      return;
    }
    
    const activeTabId = this.topicsModal.customContentModal.activeTabId;
    const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(activeTabId));
    
    if (!activeContent || !activeContent.analysis || !activeContent.analysis.wordMeanings) {
      console.log('[ButtonPanel] No word meanings found in analysis data for tab:', activeTabId);
      return;
    }
    
    // Find and remove the specific word from wordMeanings array
    const initialLength = activeContent.analysis.wordMeanings.length;
    activeContent.analysis.wordMeanings = activeContent.analysis.wordMeanings.filter(wordData => 
      wordData.normalizedWord !== normalizedWord
    );
    
    const removedCount = initialLength - activeContent.analysis.wordMeanings.length;
    if (removedCount > 0) {
      console.log('[ButtonPanel] Removed', removedCount, 'word meaning(s) for word:', normalizedWord, 'from analysis data');
    } else {
      console.log('[ButtonPanel] No word meaning found for word:', normalizedWord, 'in analysis data');
    }
  },


  /**
   * Extract context for selected text: 3 sentences before + selected text + 3 sentences after
   * @param {string} pageText - Full page text content
   * @param {number} textStartIndex - Start index of selected text in pageText
   * @param {number} textLength - Length of selected text
   * @param {string} selectedText - The selected text itself
   * @returns {string} Context string with 3 sentences before + selected text + 3 sentences after
   */
  extractContextForText(pageText, textStartIndex, textLength, selectedText) {
    if (!pageText || textStartIndex < 0 || textLength <= 0) {
      console.warn('[ButtonPanel] Invalid parameters for context extraction');
      return selectedText; // Fallback to just the selected text
    }
    
    // Get the text before the selected text
    const textBefore = pageText.substring(0, textStartIndex);
    // Get the text after the selected text
    const textAfter = pageText.substring(textStartIndex + textLength);
    
    // Helper function to split text into sentences
    // Split on sentence-ending punctuation (. ! ?) followed by whitespace or end of string
    const splitIntoSentences = (text) => {
      if (!text || text.trim().length === 0) return [];
      
      // Split on sentence-ending punctuation followed by whitespace or end of string
      // This regex matches: . ! or ? followed by whitespace or end of string
      const sentenceRegex = /[.!?]+(?:\s+|$)/g;
      const sentences = [];
      let lastIndex = 0;
      let match;
      
      while ((match = sentenceRegex.exec(text)) !== null) {
        const sentenceEnd = match.index + match[0].length;
        const sentence = text.substring(lastIndex, sentenceEnd).trim();
        if (sentence.length > 0) {
          sentences.push(sentence);
        }
        lastIndex = sentenceEnd;
      }
      
      // Add remaining text as last sentence if any
      if (lastIndex < text.length) {
        const remaining = text.substring(lastIndex).trim();
        if (remaining.length > 0) {
          sentences.push(remaining);
        }
      }
      
      return sentences;
    };
    
    // Helper function to extract last N sentences from a string
    const getLastNSentences = (text, n) => {
      if (!text || n <= 0) return '';
      const sentences = splitIntoSentences(text);
      const startIndex = Math.max(0, sentences.length - n);
      return sentences.slice(startIndex).join(' ');
    };
    
    // Helper function to extract first N sentences from a string
    const getFirstNSentences = (text, n) => {
      if (!text || n <= 0) return '';
      const sentences = splitIntoSentences(text);
      return sentences.slice(0, n).join(' ');
    };
    
    // Extract 3 sentences before (or as many as available)
    const sentencesBefore = getLastNSentences(textBefore, 3);
    
    // Extract 3 sentences after (or as many as available)
    const sentencesAfter = getFirstNSentences(textAfter, 3);
    
    // Construct context: sentences before + selected text + sentences after
    const contextParts = [sentencesBefore, selectedText, sentencesAfter].filter(part => part.trim().length > 0);
    const context = contextParts.join(' ').trim();
    
    console.log('[ButtonPanel] Extracted context:', {
      sentencesBeforeCount: splitIntoSentences(sentencesBefore).length,
      selectedTextLength: selectedText.length,
      sentencesAfterCount: splitIntoSentences(sentencesAfter).length,
      totalContextLength: context.length
    });
    
    return context;
  },

  /**
   * Handler for Magic meaning button for a specific text
   * @param {string} textKey - The specific text key to process
   */
  async handleMagicMeaningForText(textKey) {
    // Check if extension is globally enabled
    const isEnabled = await this.checkExtensionEnabled();
    if (!isEnabled) {
      console.log('[ButtonPanel] Extension is disabled, ignoring magic meaning click for text');
      return;
    }
    
    console.log('[ButtonPanel] Magic meaning clicked for specific text:', textKey);
    
    // Check if textKey exists in selectedTexts
    if (!TextSelector.selectedTexts.has(textKey)) {
      console.warn('[ButtonPanel] Text key not found in selectedTexts:', textKey);
      return;
    }
    
    // Get position data for this specific text
    const positionData = TextSelector.textPositions.get(textKey);
    if (!positionData) {
      console.warn('[ButtonPanel] No position data found for textKey:', textKey);
      return;
    }
    
    // Get the highlight element - retry if not found immediately (might be a timing issue)
    let highlight = TextSelector.textToHighlights.get(textKey);
    if (!highlight) {
      // Wait a bit and retry (highlight might still be getting added to the map)
      await new Promise(resolve => setTimeout(resolve, 50));
      highlight = TextSelector.textToHighlights.get(textKey);
      
      if (!highlight) {
        console.warn('[ButtonPanel] No highlight found for textKey after retry:', textKey);
        console.warn('[ButtonPanel] Available textKeys in textToHighlights:', Array.from(TextSelector.textToHighlights.keys()));
        
        // Clean up spinner if it exists
        const spinnerOnBody = window.safeQueryByDataTextKey('.vocab-magic-meaning-spinner-container', textKey);
        if (spinnerOnBody) {
          // Restore magic-meaning button from loading state
          TextSelector.restoreMagicMeaningButton(textKey);
          console.log('[ButtonPanel] Restored button due to missing highlight');
        }
        
        return;
      }
    }
    
    // Initialize API completion tracking for single text
    this.apiCompletionState.simplifyCompleted = false;
    this.apiCompletionState.wordsExplanationCompleted = true; // No words to process
    this.apiCompletionState.shouldTrack = true;
    
    // Set button to processing state
    this.setMagicMeaningProcessing();
    
    console.log('[ButtonPanel] Processing single text segment for:', textKey);
    
    // Get full page text to extract context
    let pageText = '';
    if (pageTextContent) {
      try {
        const contentData = JSON.parse(pageTextContent);
        pageText = contentData.text || '';
      } catch (e) {
        console.warn('[ButtonPanel] Error parsing pageTextContent, using fallback');
        pageText = document.body.innerText || document.body.textContent || '';
      }
    } else {
      pageText = document.body.innerText || document.body.textContent || '';
    }
    
    // Extract context: 50 words before + selected text + 50 words after
    const context = this.extractContextForText(pageText, positionData.textStartIndex, positionData.textLength, positionData.text);
    
    // Store context for later use in ask API
    // We'll store it in simplifiedData when it's created
    
    // Build API request payload for this single text
    const textSegments = [{
      textStartIndex: positionData.textStartIndex,
      textLength: positionData.textLength,
      text: positionData.text,
      context: context, // Add context parameter
      previousSimplifiedTexts: []
    }];
    
    // Remove text from selectedTexts container as API call starts
    TextSelector.selectedTexts.delete(textKey);
    
    // Update button states after removing from selectedTexts
    this.updateButtonStatesFromSelections();
    
    // Remove any existing buttons (remove button and magic-meaning button)
    const existingRemoveBtn = highlight.querySelector('.vocab-text-remove-btn');
    if (existingRemoveBtn) {
      existingRemoveBtn.remove();
    }
    
    // Keep the magic meaning button visible - don't remove it
    // The button is already in loading state (spinner) from the click handler
    const existingMagicBtn = highlight.querySelector('.vocab-text-magic-meaning-btn');
    if (existingMagicBtn) {
      // Ensure button is in loading state if not already
      if (!existingMagicBtn.classList.contains('magic-meaning-loading')) {
        existingMagicBtn.classList.add('magic-meaning-loading');
        existingMagicBtn.classList.remove('magic-meaning-breathing');
        existingMagicBtn.innerHTML = TextSelector.createSpinnerIcon();
        existingMagicBtn.disabled = true;
      }
    }
    
    // Keep icons wrapper - don't remove it even if empty (button should stay visible)
    // Remove icons wrapper if empty
    // const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
    // if (iconsWrapper && iconsWrapper.children.length === 0) {
    //   iconsWrapper.remove();
    // }
    
    // Add loading animation class (already added in click handler, but ensure it's there)
    highlight.classList.add('vocab-text-loading');
    
    // NOTE: We no longer create a spinner at the book icon location
    // The spinner is now positioned at the button's original position (on document.body)
    // This was created in the button click handler (createMagicMeaningButton)
    // So we skip creating vocab-text-book-spinner-wrapper here
    
    // Track if dialog has been opened for this text
    let dialogOpened = false;
    let bookIconCreated = false;
    
    // Store context in a variable accessible to the callback
    const extractedContext = context;
    
    // Call ApiService with SSE for this single text
    ApiService.simplify(
      textSegments,
      // onEvent callback - called for each SSE event
      (eventData) => {
        console.log('[ButtonPanel] Received simplified text event:', eventData);
        
        // Verify this event matches our textKey
        if (positionData.textStartIndex === eventData.textStartIndex &&
            positionData.textLength === eventData.textLength) {
          
          // CRITICAL: Handle complete event FIRST (before chunk events)
          // The complete event has type === 'complete' and includes simplifiedText and possibleQuestions
          if (eventData.type === 'complete') {
            console.log('[ButtonPanel] ===== COMPLETE EVENT HANDLER TRIGGERED (single text) =====');
            console.log('[ButtonPanel] Complete event - simplifiedText:', eventData.simplifiedText, 'shouldAllowSimplifyMore:', eventData.shouldAllowSimplifyMore);
            console.log('[ButtonPanel] Complete event - possibleQuestions received:', eventData.possibleQuestions);
            
            // Remove loading animation
            highlight.classList.remove('vocab-text-loading');
            
            // Ensure possibleQuestions is an array and store directly in ChatDialog property
            ChatDialog.simplifiedPossibleQuestions = Array.isArray(eventData.possibleQuestions) 
              ? eventData.possibleQuestions 
              : (eventData.possibleQuestions ? [eventData.possibleQuestions] : []);
            
            console.log('[ButtonPanel] Stored simplifiedPossibleQuestions:', ChatDialog.simplifiedPossibleQuestions);
            console.log('[ButtonPanel] Stored simplifiedPossibleQuestions length:', ChatDialog.simplifiedPossibleQuestions.length);
            
            // Get existing data to preserve explanationQuestions structure
            const existingData = TextSelector.simplifiedTexts.get(textKey) || {};
            
            // Initialize explanationQuestions array if it doesn't exist
            let explanationQuestions = existingData.explanationQuestions || [];
            if (!Array.isArray(explanationQuestions)) {
              explanationQuestions = [];
            }
            
            // Store possibleQuestions for this specific explanation version
            const questionsForThisExplanation = Array.isArray(ChatDialog.simplifiedPossibleQuestions) 
              ? ChatDialog.simplifiedPossibleQuestions 
              : (ChatDialog.simplifiedPossibleQuestions ? [ChatDialog.simplifiedPossibleQuestions] : []);
            
            // This is the first explanation, so it should be at index 0
            const explanationIndex = 0;
            if (explanationIndex >= explanationQuestions.length) {
              explanationQuestions.push(questionsForThisExplanation);
            } else {
              explanationQuestions[explanationIndex] = questionsForThisExplanation;
            }
            
            console.log('[ButtonPanel] Storing questions for explanation index:', explanationIndex);
            console.log('[ButtonPanel] explanationQuestions array length:', explanationQuestions.length);
            console.log('[ButtonPanel] Questions for this explanation:', questionsForThisExplanation);
            
            // Get existing streaming data to preserve accumulated text
            const existingSimplifiedData = TextSelector.simplifiedTexts.get(textKey) || {};
            
            // IMPORTANT: Prioritize eventData.simplifiedText from API complete event
            const preservedSimplifiedText = eventData.simplifiedText || existingSimplifiedData.accumulatedSimplifiedText || existingSimplifiedData.simplifiedText || '';
            const preservedText = eventData.text || existingSimplifiedData.text || positionData.text || '';
            const preservedTextStartIndex = eventData.textStartIndex !== undefined ? eventData.textStartIndex : (existingSimplifiedData.textStartIndex !== undefined ? existingSimplifiedData.textStartIndex : positionData.textStartIndex);
            const preservedTextLength = eventData.textLength !== undefined ? eventData.textLength : (existingSimplifiedData.textLength !== undefined ? existingSimplifiedData.textLength : positionData.textLength);
            
            // Final simplified data
            const simplifiedData = {
              text: preservedText,
              simplifiedText: preservedSimplifiedText,
              textStartIndex: preservedTextStartIndex,
              textLength: preservedTextLength,
              previousSimplifiedTexts: eventData.previousSimplifiedTexts || existingSimplifiedData.previousSimplifiedTexts || [],
              shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore !== undefined ? eventData.shouldAllowSimplifyMore : (existingSimplifiedData.shouldAllowSimplifyMore || false),
              explanationQuestions: explanationQuestions,
              possibleQuestions: ChatDialog.simplifiedPossibleQuestions,
              context: extractedContext || existingSimplifiedData.context,
              highlight: highlight
            };
            
            console.log('[ButtonPanel] Updated simplifiedData.possibleQuestions:', simplifiedData.possibleQuestions);
            console.log('[ButtonPanel] Updated simplifiedData.possibleQuestions length:', simplifiedData.possibleQuestions.length);
            console.log('[ButtonPanel] Updated simplifiedData.explanationQuestions length:', simplifiedData.explanationQuestions.length);
            
            // CRITICAL: Always update ChatDialog.simplifiedData with complete data FIRST
            ChatDialog.simplifiedData = {
              text: simplifiedData.text,
              simplifiedText: simplifiedData.simplifiedText,
              textStartIndex: simplifiedData.textStartIndex,
              textLength: simplifiedData.textLength,
              previousSimplifiedTexts: simplifiedData.previousSimplifiedTexts,
              shouldAllowSimplifyMore: simplifiedData.shouldAllowSimplifyMore,
              explanationQuestions: simplifiedData.explanationQuestions,
              possibleQuestions: simplifiedData.possibleQuestions,
              context: simplifiedData.context,
              highlight: simplifiedData.highlight
            };
            
            console.log('[ButtonPanel] ===== COMPLETE EVENT PROCESSED (single text) =====');
            console.log('[ButtonPanel] Updated ChatDialog.simplifiedData with:', {
              simplifiedTextLength: ChatDialog.simplifiedData.simplifiedText?.length || 0,
              possibleQuestionsLength: ChatDialog.simplifiedData.possibleQuestions?.length || 0,
              explanationQuestionsLength: ChatDialog.simplifiedData.explanationQuestions?.length || 0,
              explanationQuestions0Length: ChatDialog.simplifiedData.explanationQuestions?.[0]?.length || 0
            });
            
            // Store data BEFORE rendering to ensure it's available during rendering
            console.log('[ButtonPanel] Storing simplified data BEFORE rendering with questions');
            TextSelector.simplifiedTexts.set(textKey, ChatDialog.simplifiedData);
            TextSelector.simplifiedTexts.set(`${textKey}-selected`, ChatDialog.simplifiedData);
            TextSelector.simplifiedTexts.set(`${textKey}-generic`, ChatDialog.simplifiedData);
            console.log('[ButtonPanel] Stored data BEFORE rendering - explanationQuestions[0] length:', ChatDialog.simplifiedData.explanationQuestions?.[0]?.length || 0);
            
            // Update UI - re-render all explanations with final text and questions
            requestAnimationFrame(() => {
              const container = ChatDialog.dialogContainer?.querySelector('#vocab-chat-simplified-container');
              if (container) {
                console.log('[ButtonPanel] About to call renderSimplifiedExplanations (complete event) - ChatDialog.simplifiedData.explanationQuestions:', ChatDialog.simplifiedData.explanationQuestions);
                console.log('[ButtonPanel] About to call renderSimplifiedExplanations (complete event) - ChatDialog.simplifiedData.explanationQuestions[0]:', ChatDialog.simplifiedData.explanationQuestions?.[0]);
                ChatDialog.renderSimplifiedExplanations(container);
                
                // CRITICAL: Store data AFTER rendering to ensure questions are persisted in memory
                // This ensures the rendered data matches what's stored
                console.log('[ButtonPanel] Storing simplified data AFTER rendering with questions');
                console.log('[ButtonPanel] Storing - ChatDialog.simplifiedData.explanationQuestions:', ChatDialog.simplifiedData.explanationQuestions);
                console.log('[ButtonPanel] Storing - ChatDialog.simplifiedData.explanationQuestions[0]:', ChatDialog.simplifiedData.explanationQuestions?.[0]);
                console.log('[ButtonPanel] Storing - ChatDialog.simplifiedData.explanationQuestions[0] length:', ChatDialog.simplifiedData.explanationQuestions?.[0]?.length || 0);
                
                // Store final simplified text data with all key variations AFTER rendering
                TextSelector.simplifiedTexts.set(textKey, ChatDialog.simplifiedData);
                TextSelector.simplifiedTexts.set(`${textKey}-selected`, ChatDialog.simplifiedData);
                TextSelector.simplifiedTexts.set(`${textKey}-generic`, ChatDialog.simplifiedData);
                
                // Verify the data was stored correctly
                const storedData = TextSelector.simplifiedTexts.get(textKey);
                console.log('[ButtonPanel] Verification AFTER storage - stored data.explanationQuestions:', storedData?.explanationQuestions);
                console.log('[ButtonPanel] Verification AFTER storage - stored data.explanationQuestions[0]:', storedData?.explanationQuestions?.[0]);
                console.log('[ButtonPanel] Verification AFTER storage - stored data.explanationQuestions[0] length:', storedData?.explanationQuestions?.[0]?.length || 0);
                console.log('[ButtonPanel] Verification AFTER storage - stored data.possibleQuestions:', storedData?.possibleQuestions);
                console.log('[ButtonPanel] Verification AFTER storage - stored data.possibleQuestions length:', storedData?.possibleQuestions?.length || 0);
                
                // Store simplified text in analysis data for persistence
                if (this.topicsModal && this.topicsModal.customContentModal && this.topicsModal.customContentModal.activeTabId) {
                  const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(this.topicsModal.customContentModal.activeTabId));
                  if (activeContent && activeContent.analysis) {
                    const simplifiedTextData = {
                      textKey: textKey,
                      textStartIndex: eventData.textStartIndex,
                      textLength: eventData.textLength,
                      originalText: eventData.text,
                      simplifiedText: eventData.simplifiedText,
                      previousSimplifiedTexts: eventData.previousSimplifiedTexts || [],
                      shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore || false,
                      explanationQuestions: ChatDialog.simplifiedData.explanationQuestions, // Store questions
                      possibleQuestions: ChatDialog.simplifiedData.possibleQuestions, // Store questions
                      timestamp: new Date().toISOString()
                    };
                    
                    const existingTextIndex = activeContent.analysis.simplifiedMeanings.findIndex(s => 
                      s.textKey === textKey
                    );
                    
                    if (existingTextIndex !== -1) {
                      activeContent.analysis.simplifiedMeanings[existingTextIndex] = simplifiedTextData;
                      console.log(`[ButtonPanel] Updated existing simplified text for textKey "${textKey}" in analysis data with questions`);
                    } else {
                      activeContent.analysis.simplifiedMeanings.push(simplifiedTextData);
                      console.log(`[ButtonPanel] Added new simplified text for textKey "${textKey}" to analysis data with questions`);
                    }
                  }
                }
              } else {
                console.log('[ButtonPanel] Container not found for rendering questions, will retry');
                setTimeout(() => {
                  const retryContainer = ChatDialog.dialogContainer?.querySelector('#vocab-chat-simplified-container');
                  if (retryContainer) {
                    console.log('[ButtonPanel] Retry - calling renderSimplifiedExplanations');
                    ChatDialog.renderSimplifiedExplanations(retryContainer);
                    
                    // Store data after retry rendering as well
                    TextSelector.simplifiedTexts.set(textKey, ChatDialog.simplifiedData);
                    TextSelector.simplifiedTexts.set(`${textKey}-selected`, ChatDialog.simplifiedData);
                    TextSelector.simplifiedTexts.set(`${textKey}-generic`, ChatDialog.simplifiedData);
                    
                    console.log('[ButtonPanel] Stored data after retry rendering');
                  }
                }, 100);
              }
            });
            
            // Return early to prevent chunk handler from running
            return;
          }
          
          // Handle chunk events (streaming) - only if not a complete event
          if (eventData.chunk !== undefined) {
            console.log('[ButtonPanel] Chunk event - chunk:', eventData.chunk, 'accumulatedSimplifiedText:', eventData.accumulatedSimplifiedText);
            
            // Remove loading animation on first chunk
          highlight.classList.remove('vocab-text-loading');
          
            // Create book icon and green cross button on first chunk (only once)
            if (!bookIconCreated) {
              bookIconCreated = true;
              
              // Remove purple spinner at book icon location
              const bookSpinnerWrapper = highlight.querySelector('.vocab-text-book-spinner-wrapper');
              if (bookSpinnerWrapper) {
                bookSpinnerWrapper.remove();
              }
              
              // REMOVE magic-meaning button now that API call is complete and green book will appear
              // Remove from buttonWrapper (floating button on body) if it exists
              const buttonWrapper = TextSelector.buttonWrappers?.get(textKey);
              if (buttonWrapper) {
                // Clean up fixed scroll handler if it exists
                if (buttonWrapper._fixedScrollHandler) {
                  window.removeEventListener('scroll', buttonWrapper._fixedScrollHandler);
                  buttonWrapper._fixedScrollHandler = null;
                  buttonWrapper._fixedPosition = null;
                }
                
                // Clean up event listeners if they exist
                if (buttonWrapper._cleanupHandlers) {
                  window.removeEventListener('scroll', buttonWrapper._cleanupHandlers.scroll);
                  window.removeEventListener('resize', buttonWrapper._cleanupHandlers.resize);
                  document.removeEventListener('mouseup', buttonWrapper._cleanupHandlers.cleanup);
                  document.removeEventListener('mousedown', buttonWrapper._cleanupHandlers.cleanup);
                  document.removeEventListener('selectionchange', buttonWrapper._cleanupHandlers.cleanup);
                  document.removeEventListener('touchend', buttonWrapper._cleanupHandlers.cleanup);
                }
                if (buttonWrapper.parentNode) {
                  buttonWrapper.remove();
                }
                TextSelector.buttonWrappers?.delete(textKey);
              }
              
              // Remove magic button from highlight's iconsWrapper
              const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
              if (iconsWrapper) {
                const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
                if (magicBtn) {
                  magicBtn.remove();
                }
                // If iconsWrapper is now empty, we'll reuse it for the book icon below
              }
            }
            
            // Change underline to light green - remove inline styles that hide underline
            highlight.style.removeProperty('text-decoration');
            highlight.style.removeProperty('text-decoration-line');
            highlight.classList.add('vocab-text-simplified');
            
            // Remove any existing cross buttons
            const existingPurpleCross = highlight.querySelector('.vocab-text-remove-btn');
            if (existingPurpleCross) {
              existingPurpleCross.remove();
            }
            const existingGreenCross = highlight.querySelector('.vocab-text-remove-green-btn');
            if (existingGreenCross) {
              existingGreenCross.remove();
            }
                
            // Reuse or create icons wrapper for book icon (book icon positioned at top-left)
            let newIconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
            if (!newIconsWrapper) {
              newIconsWrapper = document.createElement('div');
              newIconsWrapper.className = 'vocab-text-icons-wrapper vocab-text-icons-wrapper-book';
              newIconsWrapper.setAttribute('data-text-key', textKey);
              highlight.appendChild(newIconsWrapper);
            } else {
              // Update class to include book wrapper class (magic button already removed above)
              newIconsWrapper.className = 'vocab-text-icons-wrapper vocab-text-icons-wrapper-book';
            }
            
            // Create green cross button and add it to the icons wrapper (near book icon at top-left)
            const greenCrossBtn = document.createElement('button');
            greenCrossBtn.className = 'vocab-text-remove-green-btn';
            greenCrossBtn.setAttribute('aria-label', 'Remove simplified text');
            greenCrossBtn.style.position = 'relative';
            greenCrossBtn.style.width = '18px';
            greenCrossBtn.style.height = '18px';
            greenCrossBtn.style.background = '#FFFFFF';
            greenCrossBtn.style.borderRadius = '50%';
            greenCrossBtn.style.zIndex = '10000003';
            greenCrossBtn.style.boxShadow = '0 2px 4px rgba(34, 197, 94, 0.4)';
            greenCrossBtn.style.display = 'flex';
            greenCrossBtn.style.alignItems = 'center';
            greenCrossBtn.style.justifyContent = 'center';
            greenCrossBtn.style.cursor = 'pointer';
            greenCrossBtn.style.opacity = '1';
            greenCrossBtn.style.border = '1px solid #22c55e';
            greenCrossBtn.style.padding = '0';
            greenCrossBtn.style.boxSizing = 'border-box';
            greenCrossBtn.style.margin = '0';
            greenCrossBtn.innerHTML = `
              <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="width: 10px; height: 10px;">
                <path d="M2 2L10 10M10 2L2 10" stroke="#22c55e" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            `;
            greenCrossBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log('[TextSelector] Green cross button clicked for simplified text:', textKey);
              TextSelector.removeFromSimplifiedTexts(textKey);
            });
            // Add cross button to icons wrapper (before book button so it appears first/on top)
            newIconsWrapper.insertBefore(greenCrossBtn, newIconsWrapper.firstChild);
            
            // Remove any existing book button
            const existingBookBtn = newIconsWrapper.querySelector('.vocab-text-book-btn');
            if (existingBookBtn) {
              existingBookBtn.remove();
            }
            
            // Create and add book button
            const bookBtn = TextSelector.createBookButton(textKey);
            newIconsWrapper.appendChild(bookBtn);
            
            // Position book icon wrapper
            newIconsWrapper.style.setProperty('position', 'absolute', 'important');
            newIconsWrapper.style.setProperty('display', 'flex', 'important');
            newIconsWrapper.style.setProperty('margin', '0', 'important');
            newIconsWrapper.style.setProperty('padding', '0', 'important');
            
            // Force reflow to ensure animation starts immediately
            void newIconsWrapper.offsetHeight;
            void bookBtn.offsetHeight;
            
            const isInModal = highlight.closest('.vocab-custom-content-modal');
            if (isInModal) {
              newIconsWrapper.style.setProperty('left', '-50px', 'important');
              newIconsWrapper.style.setProperty('right', 'auto', 'important');
              newIconsWrapper.style.setProperty('top', '-2px', 'important');
            } else {
              newIconsWrapper.style.setProperty('left', '-45px', 'important');
              newIconsWrapper.style.setProperty('right', 'auto', 'important');
              newIconsWrapper.style.setProperty('top', '0px', 'important');
            }
            
            // Force a reflow
            newIconsWrapper.offsetHeight;
            
            // Store streaming data with accumulated text
            // Initialize explanationQuestions array for streaming (will be populated on complete)
            const existingData = TextSelector.simplifiedTexts.get(textKey) || {};
            const streamingExplanationQuestions = existingData.explanationQuestions || [];
            
            const streamingSimplifiedData = {
              text: eventData.text,
              simplifiedText: eventData.accumulatedSimplifiedText || '', // Use accumulated text for streaming
              textStartIndex: eventData.textStartIndex,
              textLength: eventData.textLength,
              previousSimplifiedTexts: eventData.previousSimplifiedTexts || [],
              shouldAllowSimplifyMore: false, // Will be set on complete
              explanationQuestions: streamingExplanationQuestions, // Preserve existing, will be updated on complete
              possibleQuestions: [], // Will be set on complete
              context: extractedContext, // Store context for ask API (from closure)
              highlight: highlight
            };
            
            // Store in TextSelector for real-time updates
            TextSelector.simplifiedTexts.set(textKey, streamingSimplifiedData);
            
            // Helper function to update UI with streaming data
            const updateUIWithStreamingData = () => {
              // Update the simplified data in the dialog
              ChatDialog.simplifiedData = streamingSimplifiedData;
              
              // Try to find the container - check multiple ways
              let container = null;
              if (ChatDialog.dialogContainer) {
                container = ChatDialog.dialogContainer.querySelector('#vocab-chat-simplified-container');
              }
              if (!container) {
                container = document.getElementById('vocab-chat-simplified-container');
              }
              
              if (container) {
                console.log('[ButtonPanel] Updating UI with streaming data, accumulated text length:', eventData.accumulatedSimplifiedText?.length || 0);
                ChatDialog.renderSimplifiedExplanations(container);
              } else {
                console.log('[ButtonPanel] Container not found yet, will retry on next chunk');
              }
            };
            
            // Open dialog on first chunk (only once)
            if (!dialogOpened) {
              dialogOpened = true;
              console.log('[ButtonPanel] Opening dialog on first chunk for streaming');
              
              // Wait for book icon to be in DOM
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  ChatDialog.open(eventData.text, textKey, 'simplified', streamingSimplifiedData, 'selected');
                  
                  // Update UI immediately after opening
                  setTimeout(() => {
                    updateUIWithStreamingData();
                  }, 50); // Small delay to ensure dialog is fully rendered
                });
              });
            } else {
              // Update existing dialog with streaming text on every chunk
              if (ChatDialog.isOpen && ChatDialog.currentTextKey === textKey) {
                updateUIWithStreamingData();
              } else {
                // Dialog might still be opening, try to update anyway
                updateUIWithStreamingData();
              }
            }
          }
        }
      },
      // onComplete callback
      () => {
        console.log('[ButtonPanel] Single text simplification API call completed for:', textKey);
        
        // Mark simplify as completed
        this.apiCompletionState.simplifyCompleted = true;
        
        // Check if all APIs are completed
        this.checkAPICompletion();
      },
      // onError callback
      (error) => {
        console.error('[ButtonPanel] Error during single text simplification:', error);
        
        // Remove pulsating animation on error
        if (highlight) {
        highlight.classList.remove('vocab-text-loading');
          
          // Remove data-processing-magic-meaning attribute
          highlight.removeAttribute('data-processing-magic-meaning');
        
        // Remove purple spinner at book icon location on error
        const bookSpinnerWrapper = highlight.querySelector('.vocab-text-book-spinner-wrapper');
        if (bookSpinnerWrapper) {
          bookSpinnerWrapper.remove();
          }
        }
        
        // Remove spinner containers on document.body
        const spinnerOnBody = window.safeQueryByDataTextKey('.vocab-magic-meaning-spinner-container', textKey);
        if (spinnerOnBody) {
          spinnerOnBody.remove();
        }
        
        // Remove magic meaning button from buttonWrapper (floating button on body) if it exists
        const buttonWrapper = TextSelector.buttonWrappers?.get(textKey);
        if (buttonWrapper) {
          // Clean up fixed scroll handler if it exists
          if (buttonWrapper._fixedScrollHandler) {
            window.removeEventListener('scroll', buttonWrapper._fixedScrollHandler);
            buttonWrapper._fixedScrollHandler = null;
            buttonWrapper._fixedPosition = null;
          }
          
          // Clean up event listeners if they exist
          if (buttonWrapper._cleanupHandlers) {
            window.removeEventListener('scroll', buttonWrapper._cleanupHandlers.scroll);
            window.removeEventListener('resize', buttonWrapper._cleanupHandlers.resize);
            document.removeEventListener('mouseup', buttonWrapper._cleanupHandlers.cleanup);
            document.removeEventListener('mousedown', buttonWrapper._cleanupHandlers.cleanup);
            document.removeEventListener('selectionchange', buttonWrapper._cleanupHandlers.cleanup);
            document.removeEventListener('touchend', buttonWrapper._cleanupHandlers.cleanup);
          }
          
          // Remove buttonWrapper from DOM
          if (buttonWrapper.parentNode) {
            buttonWrapper.remove();
          }
          
          // Remove from buttonWrappers map
          TextSelector.buttonWrappers?.delete(textKey);
        }
        
        // Remove magic meaning button from highlight's iconsWrapper if it exists
        if (highlight) {
          const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
          if (iconsWrapper) {
            const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
            if (magicBtn) {
              magicBtn.remove();
            }
            // Remove iconsWrapper if it's now empty
            if (iconsWrapper.children.length === 0) {
              iconsWrapper.remove();
            }
          }
          
          // Also check for magic button directly in highlight (fallback)
          const magicBtnDirect = highlight.querySelector('.vocab-text-magic-meaning-btn');
          if (magicBtnDirect) {
            magicBtnDirect.remove();
          }
        }
        
        // Revert span element: remove highlight and restore original text
        if (highlight) {
          TextSelector.removeHighlight(highlight);
        }
        
        // Clean up data structures
        TextSelector.selectedTexts.delete(textKey);
        TextSelector.textToHighlights.delete(textKey);
        
        // Update button states after cleanup
        this.updateButtonStatesFromSelections();
        
        // Extract error message from error object (handle various error formats)
        let errorMessage = 'Error simplifying text. Please try again.';
        if (error) {
          if (error.message) {
            errorMessage = error.message;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.error?.message) {
            errorMessage = error.error.message;
          } else if (error.error?.reason) {
            errorMessage = error.error.reason;
          } else if (typeof error === 'string') {
            errorMessage = error;
          } else if (error.status && error.statusText) {
            errorMessage = `API request failed: ${error.status} ${error.statusText}`;
          }
        }
        
        // Show error notification with actual error message
        TextSelector.showNotification(errorMessage);
        
        // Mark simplify as completed (even on error) to allow button reset
        this.apiCompletionState.simplifyCompleted = true;
        
        // Check if all APIs are completed
        this.checkAPICompletion();
      }
    );
  },

  /**
   * Handler for Magic meaning button
   */
  async handleMagicMeaning() {
    // Check if extension is globally enabled
    const isEnabled = await this.checkExtensionEnabled();
    if (!isEnabled) {
      console.log('[ButtonPanel] Extension is disabled, ignoring magic meaning click');
      return;
    }
    
    console.log('[ButtonPanel] Magic meaning clicked');
    
    // Get all selected texts and words
    const selectedTexts = TextSelector.getSelectedTexts();
    const selectedWords = WordSelector.getSelectedWords();
    
    if (selectedTexts.size === 0 && selectedWords.size === 0) {
      console.warn('[ButtonPanel] No text or words selected');
      return;
    }

    // Initialize API completion tracking
    this.apiCompletionState.simplifyCompleted = selectedTexts.size === 0; // If no texts, mark as completed
    this.apiCompletionState.wordsExplanationCompleted = selectedWords.size === 0; // If no words, mark as completed
    this.apiCompletionState.shouldTrack = true;

    // Set button to processing state
    this.setMagicMeaningProcessing();

    console.log('[ButtonPanel] API tracking initialized:', this.apiCompletionState);
    
    // ========== Process Text Segments (existing functionality) ==========
    if (selectedTexts.size > 0) {
      // Get full page text to extract context
      let pageText = '';
      if (pageTextContent) {
        try {
          const contentData = JSON.parse(pageTextContent);
          pageText = contentData.text || '';
        } catch (e) {
          console.warn('[ButtonPanel] Error parsing pageTextContent, using fallback');
          pageText = document.body.innerText || document.body.textContent || '';
        }
      } else {
        pageText = document.body.innerText || document.body.textContent || '';
      }
      
      // Build API request payload
      const textSegments = [];
      const textKeysToProcess = [];
      const contextMap = new Map(); // Store context for each textKey
      
      for (const textKey of selectedTexts) {
        const positionData = TextSelector.textPositions.get(textKey);
        
        if (positionData) {
          // Extract context: 50 words before + selected text + 50 words after
          const context = this.extractContextForText(pageText, positionData.textStartIndex, positionData.textLength, positionData.text);
          
          // Store context for this textKey
          contextMap.set(textKey, context);
          
          textSegments.push({
            textStartIndex: positionData.textStartIndex,
            textLength: positionData.textLength,
            text: positionData.text,
            context: context, // Add context parameter
            previousSimplifiedTexts: []
          });
          textKeysToProcess.push(textKey);
        }
      }
      
      if (textSegments.length > 0) {
        console.log('[ButtonPanel] Processing', textSegments.length, 'text segments');
        
        // Remove texts from selectedTexts container as API call starts
        for (const textKey of textKeysToProcess) {
          TextSelector.selectedTexts.delete(textKey);
        }
        
        // Update button states after removing from selectedTexts
        this.updateButtonStatesFromSelections();
        
        // Start loading animation on all selected highlights
        for (const textKey of textKeysToProcess) {
          const highlight = TextSelector.textToHighlights.get(textKey);
          if (highlight) {
            // Remove any existing buttons (remove button and magic-meaning button)
            const existingRemoveBtn = highlight.querySelector('.vocab-text-remove-btn');
            if (existingRemoveBtn) {
              existingRemoveBtn.remove();
            }
            
            // Keep the magic meaning button visible - don't remove it
            // The button should stay visible in loading state
            const existingMagicBtn = highlight.querySelector('.vocab-text-magic-meaning-btn');
            if (existingMagicBtn) {
              // Ensure button is in loading state if not already
              if (!existingMagicBtn.classList.contains('magic-meaning-loading')) {
                existingMagicBtn.classList.add('magic-meaning-loading');
                existingMagicBtn.classList.remove('magic-meaning-breathing');
                existingMagicBtn.innerHTML = TextSelector.createSpinnerIcon();
                existingMagicBtn.disabled = true;
              }
            }
            
            // Keep icons wrapper - don't remove it even if empty (button should stay visible)
            // Remove icons wrapper if empty
            // const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
            // if (iconsWrapper && iconsWrapper.children.length === 0) {
            //   iconsWrapper.remove();
            // }
            
            // Add loading animation class
            highlight.classList.add('vocab-text-loading');
          }
        }
        
        // Track which text objects have had their dialog opened
        const dialogOpenedMap = new Map(); // textKey -> boolean
        const bookIconCreatedMap = new Map(); // textKey -> boolean
        
        // Call ApiService with SSE
        ApiService.simplify(
          textSegments,
          // onEvent callback - called for each SSE event
          (eventData) => {
            console.log('[ButtonPanel] Received simplified text event:', eventData);
            
            // Find the corresponding textKey for this event
            // Match by textStartIndex and textLength
            const matchingTextKey = textKeysToProcess.find(textKey => {
              const posData = TextSelector.textPositions.get(textKey);
              return posData && 
                     posData.textStartIndex === eventData.textStartIndex &&
                     posData.textLength === eventData.textLength;
            });
            
            if (matchingTextKey) {
              const highlight = TextSelector.textToHighlights.get(matchingTextKey);
              
              if (highlight) {
                // Handle chunk events (streaming)
                if (eventData.chunk !== undefined) {
                  console.log('[ButtonPanel] Chunk event for', matchingTextKey, '- chunk:', eventData.chunk, 'accumulatedSimplifiedText:', eventData.accumulatedSimplifiedText);
                  
                  // Remove loading animation on first chunk
                highlight.classList.remove('vocab-text-loading');
                  
                  // Create book icon and green cross button on first chunk (only once per text)
                  if (!bookIconCreatedMap.get(matchingTextKey)) {
                    bookIconCreatedMap.set(matchingTextKey, true);
                
                    // REMOVE magic-meaning button now that API call is complete and green book will appear
                    // Remove from buttonWrapper (floating button on body) if it exists
                    const buttonWrapper = TextSelector.buttonWrappers?.get(matchingTextKey);
                    if (buttonWrapper) {
                      // Clean up event listeners if they exist
                      if (buttonWrapper._cleanupHandlers) {
                        window.removeEventListener('scroll', buttonWrapper._cleanupHandlers.scroll);
                        window.removeEventListener('resize', buttonWrapper._cleanupHandlers.resize);
                        document.removeEventListener('mouseup', buttonWrapper._cleanupHandlers.cleanup);
                        document.removeEventListener('mousedown', buttonWrapper._cleanupHandlers.cleanup);
                        document.removeEventListener('selectionchange', buttonWrapper._cleanupHandlers.cleanup);
                        document.removeEventListener('touchend', buttonWrapper._cleanupHandlers.cleanup);
                      }
                      if (buttonWrapper.parentNode) {
                        buttonWrapper.remove();
                      }
                      TextSelector.buttonWrappers?.delete(matchingTextKey);
                    }
                    
                    // Remove magic button from highlight's iconsWrapper if it exists
                    const existingIconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
                    if (existingIconsWrapper) {
                      const magicBtn = existingIconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
                      if (magicBtn) {
                        magicBtn.remove();
                      }
                      // Remove the old iconsWrapper since we'll create a new one for the book icon
                      existingIconsWrapper.remove();
                    }
                
                // Change underline to light green - remove inline styles that hide underline
                highlight.style.removeProperty('text-decoration');
                highlight.style.removeProperty('text-decoration-line');
                highlight.classList.add('vocab-text-simplified');
                
                // Replace purple cross button with green cross button at top-left
                const existingPurpleCross = highlight.querySelector('.vocab-text-remove-btn');
                if (existingPurpleCross) {
                  existingPurpleCross.remove();
                }
                
                    // Create green cross button at top-left
                const greenCrossBtn = document.createElement('button');
                greenCrossBtn.className = 'vocab-text-remove-green-btn';
                greenCrossBtn.setAttribute('aria-label', 'Remove simplified text');
                greenCrossBtn.style.position = 'absolute';
                greenCrossBtn.style.top = '-10px';
                greenCrossBtn.style.left = '-10px';
                greenCrossBtn.style.width = '18px';
                greenCrossBtn.style.height = '18px';
                greenCrossBtn.style.background = '#FFFFFF';
                greenCrossBtn.style.borderRadius = '50%';
                greenCrossBtn.style.zIndex = '10000003';
                greenCrossBtn.style.boxShadow = '0 2px 4px rgba(34, 197, 94, 0.4)';
                greenCrossBtn.style.display = 'flex';
                greenCrossBtn.style.alignItems = 'center';
                greenCrossBtn.style.justifyContent = 'center';
                greenCrossBtn.style.cursor = 'pointer';
                greenCrossBtn.style.opacity = '1';
                greenCrossBtn.style.border = '1px solid #22c55e';
                greenCrossBtn.style.padding = '0';
                greenCrossBtn.style.boxSizing = 'border-box';
                greenCrossBtn.innerHTML = `
                  <svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" style="width: 8px; height: 8px;">
                    <path d="M2 2L8 8M8 2L2 8" stroke="#22c55e" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                `;
                greenCrossBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  console.log('[TextSelector] Green cross button clicked for simplified text:', matchingTextKey);
                  TextSelector.removeFromSimplifiedTexts(matchingTextKey);
                });
                highlight.appendChild(greenCrossBtn);
                
                    // Create wrapper for icons (book icon positioned at top-left)
                const iconsWrapper = document.createElement('div');
                    iconsWrapper.className = 'vocab-text-icons-wrapper vocab-text-icons-wrapper-book';
                iconsWrapper.setAttribute('data-text-key', matchingTextKey);
                
                    // Add book icon
                const bookBtn = TextSelector.createBookButton(matchingTextKey);
                iconsWrapper.appendChild(bookBtn);
                
                    // Position book icon wrapper
                    iconsWrapper.style.setProperty('position', 'absolute', 'important');
                    iconsWrapper.style.setProperty('display', 'flex', 'important');
                    iconsWrapper.style.setProperty('margin', '0', 'important');
                    iconsWrapper.style.setProperty('padding', '0', 'important');
                    
                    // Force reflow to ensure animation starts immediately
                    void iconsWrapper.offsetHeight;
                    void bookBtn.offsetHeight;
                    
                    const isInModal = highlight.closest('.vocab-custom-content-modal');
                    if (isInModal) {
                      iconsWrapper.style.setProperty('left', '-50px', 'important');
                      iconsWrapper.style.setProperty('right', 'auto', 'important');
                      iconsWrapper.style.setProperty('top', '-2px', 'important');
                    } else {
                      iconsWrapper.style.setProperty('left', '-45px', 'important');
                      iconsWrapper.style.setProperty('right', 'auto', 'important');
                      iconsWrapper.style.setProperty('top', '0px', 'important');
                    }
                    
                    // Append icons wrapper to highlight
                    highlight.appendChild(iconsWrapper);
                    
                    // Force a reflow
                    iconsWrapper.offsetHeight;
                  }
                  
                  // Store streaming data with accumulated text
                  const streamingSimplifiedData = {
                  text: eventData.text,
                    simplifiedText: eventData.accumulatedSimplifiedText || '', // Use accumulated text for streaming
                  textStartIndex: eventData.textStartIndex,
                  textLength: eventData.textLength,
                  previousSimplifiedTexts: eventData.previousSimplifiedTexts || [],
                    shouldAllowSimplifyMore: false, // Will be set on complete
                    possibleQuestions: [], // Will be set on complete
                    context: contextMap.get(matchingTextKey) || '', // Store context for ask API
                    highlight: highlight
                  };
                  
                  // Store in TextSelector for real-time updates
                  TextSelector.simplifiedTexts.set(matchingTextKey, streamingSimplifiedData);
                  
                  // Helper function to update UI with streaming data
                  const updateUIWithStreamingData = () => {
                    // Update the simplified data in the dialog
                    ChatDialog.simplifiedData = streamingSimplifiedData;
                    
                    // Try to find the container - check multiple ways
                    let container = null;
                    if (ChatDialog.dialogContainer) {
                      container = ChatDialog.dialogContainer.querySelector('#vocab-chat-simplified-container');
                    }
                    if (!container) {
                      container = document.getElementById('vocab-chat-simplified-container');
                    }
                    
                    if (container) {
                      console.log('[ButtonPanel] Updating UI with streaming data for', matchingTextKey, ', accumulated text length:', eventData.accumulatedSimplifiedText?.length || 0);
                      ChatDialog.renderSimplifiedExplanations(container);
                } else {
                      console.log('[ButtonPanel] Container not found yet for', matchingTextKey, ', will retry on next chunk');
                    }
                  };
                  
                  // Open dialog on first chunk (only once per text)
                  if (!dialogOpenedMap.get(matchingTextKey)) {
                    dialogOpenedMap.set(matchingTextKey, true);
                    console.log('[ButtonPanel] Opening dialog on first chunk for streaming:', matchingTextKey);
                    
                    // Wait for book icon to be in DOM
                    requestAnimationFrame(() => {
                      requestAnimationFrame(() => {
                        ChatDialog.open(eventData.text, matchingTextKey, 'simplified', streamingSimplifiedData, 'selected');
                        
                        // Update UI immediately after opening
                        setTimeout(() => {
                          updateUIWithStreamingData();
                        }, 50); // Small delay to ensure dialog is fully rendered
                      });
                    });
                  } else {
                    // Update existing dialog with streaming text on every chunk
                    if (ChatDialog.isOpen && ChatDialog.currentTextKey === matchingTextKey) {
                      updateUIWithStreamingData();
                    } else {
                      // Dialog might still be opening, try to update anyway
                      updateUIWithStreamingData();
                    }
                  }
                }
                
                // Handle complete event (final data)
                // IMPORTANT: Check for type === 'complete' FIRST to ensure we properly handle the complete event
                else if (eventData.type === 'complete') {
                  console.log('[ButtonPanel] ===== COMPLETE EVENT HANDLER TRIGGERED (batch) =====');
                  console.log('[ButtonPanel] Complete event for', matchingTextKey, '- simplifiedText:', eventData.simplifiedText, 'shouldAllowSimplifyMore:', eventData.shouldAllowSimplifyMore);
                  console.log('[ButtonPanel] Complete event - possibleQuestions:', eventData.possibleQuestions);
                  console.log('[ButtonPanel] Complete event - possibleQuestions length:', eventData.possibleQuestions?.length || 0);
                  
                  // Remove loading animation
                  highlight.classList.remove('vocab-text-loading');
                  
                  // Ensure possibleQuestions is an array and store directly in ChatDialog property
                  // This matches the pattern used in "Simplify more" handler
                  ChatDialog.simplifiedPossibleQuestions = Array.isArray(eventData.possibleQuestions) 
                    ? eventData.possibleQuestions 
                    : (eventData.possibleQuestions ? [eventData.possibleQuestions] : []);
                  
                  console.log('[ButtonPanel] Stored simplifiedPossibleQuestions:', ChatDialog.simplifiedPossibleQuestions);
                  console.log('[ButtonPanel] Stored simplifiedPossibleQuestions length:', ChatDialog.simplifiedPossibleQuestions.length);
                  
                  // Get existing data to preserve explanationQuestions structure
                  const existingData = TextSelector.simplifiedTexts.get(matchingTextKey) || {};
                  
                  // Initialize explanationQuestions array if it doesn't exist
                  // This array stores possibleQuestions for each explanation version
                  let explanationQuestions = existingData.explanationQuestions || [];
                  if (!Array.isArray(explanationQuestions)) {
                    explanationQuestions = [];
                  }
                  
                  // Store possibleQuestions for this specific explanation version
                  // Ensure it's an array
                  const questionsForThisExplanation = Array.isArray(ChatDialog.simplifiedPossibleQuestions) 
                    ? ChatDialog.simplifiedPossibleQuestions 
                    : (ChatDialog.simplifiedPossibleQuestions ? [ChatDialog.simplifiedPossibleQuestions] : []);
                  
                  // This is the first explanation, so it should be at index 0
                  const explanationIndex = 0;
                  if (explanationIndex >= explanationQuestions.length) {
                    explanationQuestions.push(questionsForThisExplanation);
                  } else {
                    explanationQuestions[explanationIndex] = questionsForThisExplanation;
                  }
                  
                  console.log('[ButtonPanel] Storing questions for explanation index:', explanationIndex);
                  console.log('[ButtonPanel] explanationQuestions array length:', explanationQuestions.length);
                  
                  // Get existing streaming data to preserve accumulated text
                  const existingSimplifiedData = TextSelector.simplifiedTexts.get(matchingTextKey) || {};
                  
                  // IMPORTANT: Prioritize eventData.simplifiedText from API complete event
                  const preservedSimplifiedText = eventData.simplifiedText || existingSimplifiedData.accumulatedSimplifiedText || existingSimplifiedData.simplifiedText || '';
                  const preservedText = eventData.text || existingSimplifiedData.text || '';
                  const preservedTextStartIndex = eventData.textStartIndex !== undefined ? eventData.textStartIndex : (existingSimplifiedData.textStartIndex !== undefined ? existingSimplifiedData.textStartIndex : 0);
                  const preservedTextLength = eventData.textLength !== undefined ? eventData.textLength : (existingSimplifiedData.textLength !== undefined ? existingSimplifiedData.textLength : 0);
                  
                  // Final simplified data - matching the pattern from "Simplify more"
                  const simplifiedData = {
                    text: preservedText,
                    simplifiedText: preservedSimplifiedText,
                    textStartIndex: preservedTextStartIndex,
                    textLength: preservedTextLength,
                    previousSimplifiedTexts: eventData.previousSimplifiedTexts || existingSimplifiedData.previousSimplifiedTexts || [],
                    shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore !== undefined ? eventData.shouldAllowSimplifyMore : (existingSimplifiedData.shouldAllowSimplifyMore || false),
                    explanationQuestions: explanationQuestions, // Store questions per explanation version
                    possibleQuestions: ChatDialog.simplifiedPossibleQuestions, // Keep for backward compatibility
                    context: contextMap.get(matchingTextKey) || existingSimplifiedData.context || '', // Store context for ask API
                    highlight: highlight
                  };
                  
                  console.log('[ButtonPanel] Updated simplifiedData.possibleQuestions:', simplifiedData.possibleQuestions);
                  console.log('[ButtonPanel] Updated simplifiedData.possibleQuestions length:', simplifiedData.possibleQuestions.length);
                  console.log('[ButtonPanel] Updated simplifiedData.explanationQuestions length:', simplifiedData.explanationQuestions.length);
                  
                  // CRITICAL: Always update ChatDialog.simplifiedData with complete data FIRST
                  // This ensures questions are available when renderSimplifiedExplanations() is called
                  // Use a fresh object to ensure the reference is updated
                  ChatDialog.simplifiedData = {
                    text: simplifiedData.text,
                    simplifiedText: simplifiedData.simplifiedText,
                    textStartIndex: simplifiedData.textStartIndex,
                    textLength: simplifiedData.textLength,
                    previousSimplifiedTexts: simplifiedData.previousSimplifiedTexts,
                    shouldAllowSimplifyMore: simplifiedData.shouldAllowSimplifyMore,
                    explanationQuestions: simplifiedData.explanationQuestions, // CRITICAL: Must include questions
                    possibleQuestions: simplifiedData.possibleQuestions, // CRITICAL: Must include questions
                    context: simplifiedData.context,
                    highlight: simplifiedData.highlight
                  };
                  
                  console.log('[ButtonPanel] Updated ChatDialog.simplifiedData (batch) with explanationQuestions:', ChatDialog.simplifiedData.explanationQuestions);
                  console.log('[ButtonPanel] Updated ChatDialog.simplifiedData (batch) explanationQuestions[0]:', ChatDialog.simplifiedData.explanationQuestions?.[0]);
                  
                  // Store data BEFORE rendering to ensure it's available during rendering
                  console.log('[ButtonPanel] Storing simplified data BEFORE rendering (batch) with questions');
                  TextSelector.simplifiedTexts.set(matchingTextKey, ChatDialog.simplifiedData);
                  TextSelector.simplifiedTexts.set(`${matchingTextKey}-selected`, ChatDialog.simplifiedData);
                  TextSelector.simplifiedTexts.set(`${matchingTextKey}-generic`, ChatDialog.simplifiedData);
                  console.log('[ButtonPanel] Stored data BEFORE rendering (batch) - explanationQuestions[0] length:', ChatDialog.simplifiedData.explanationQuestions?.[0]?.length || 0);
                  
                  // Update dialog if it's open
                  if (ChatDialog.isOpen && ChatDialog.currentTextKey === matchingTextKey) {
                    // Use requestAnimationFrame to ensure ChatDialog.simplifiedData is fully updated
                    requestAnimationFrame(() => {
                      const container = ChatDialog.dialogContainer?.querySelector('#vocab-chat-simplified-container');
                      if (container) {
                        console.log('[ButtonPanel] About to call renderSimplifiedExplanations (batch) - ChatDialog.simplifiedData.explanationQuestions:', ChatDialog.simplifiedData.explanationQuestions);
                        console.log('[ButtonPanel] About to call renderSimplifiedExplanations (batch) - ChatDialog.simplifiedData.explanationQuestions[0]:', ChatDialog.simplifiedData.explanationQuestions?.[0]);
                        ChatDialog.renderSimplifiedExplanations(container);
                        
                        // CRITICAL: Store data AFTER rendering to ensure questions are persisted in memory
                        console.log('[ButtonPanel] Storing simplified data AFTER rendering (batch) with questions');
                        TextSelector.simplifiedTexts.set(matchingTextKey, ChatDialog.simplifiedData);
                        TextSelector.simplifiedTexts.set(`${matchingTextKey}-selected`, ChatDialog.simplifiedData);
                        TextSelector.simplifiedTexts.set(`${matchingTextKey}-generic`, ChatDialog.simplifiedData);
                        
                        // Verify the data was stored correctly
                        const storedData = TextSelector.simplifiedTexts.get(matchingTextKey);
                        console.log('[ButtonPanel] Verification AFTER storage (batch) - stored data.explanationQuestions[0] length:', storedData?.explanationQuestions?.[0]?.length || 0);
                        console.log('[ButtonPanel] Verification AFTER storage (batch) - stored data.possibleQuestions length:', storedData?.possibleQuestions?.length || 0);
                      } else {
                        // Retry if container not found
                        setTimeout(() => {
                          const retryContainer = ChatDialog.dialogContainer?.querySelector('#vocab-chat-simplified-container');
                          if (retryContainer) {
                            ChatDialog.renderSimplifiedExplanations(retryContainer);
                            
                            // Store data after retry rendering as well
                            TextSelector.simplifiedTexts.set(matchingTextKey, ChatDialog.simplifiedData);
                            TextSelector.simplifiedTexts.set(`${matchingTextKey}-selected`, ChatDialog.simplifiedData);
                            TextSelector.simplifiedTexts.set(`${matchingTextKey}-generic`, ChatDialog.simplifiedData);
                            
                            console.log('[ButtonPanel] Stored data after retry rendering (batch)');
                          }
                        }, 100);
                      }
                    });
                  } else if (!dialogOpenedMap.get(matchingTextKey)) {
                    // If dialog wasn't opened during streaming, open it now
                    dialogOpenedMap.set(matchingTextKey, true);
                    ChatDialog.open(eventData.text, matchingTextKey, 'simplified', simplifiedData, 'selected');
                    
                    // Store data after opening dialog
                    setTimeout(() => {
                      TextSelector.simplifiedTexts.set(matchingTextKey, ChatDialog.simplifiedData);
                      TextSelector.simplifiedTexts.set(`${matchingTextKey}-selected`, ChatDialog.simplifiedData);
                      TextSelector.simplifiedTexts.set(`${matchingTextKey}-generic`, ChatDialog.simplifiedData);
                      console.log('[ButtonPanel] Stored data after opening dialog (batch)');
                    }, 100);
                  }
                
                // Store simplified text in analysis data for persistence (with questions)
                if (this.topicsModal && this.topicsModal.customContentModal && this.topicsModal.customContentModal.activeTabId) {
                  const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(this.topicsModal.customContentModal.activeTabId));
                  if (activeContent && activeContent.analysis) {
                    const simplifiedTextData = {
                      textKey: matchingTextKey,
                      textStartIndex: eventData.textStartIndex,
                      textLength: eventData.textLength,
                      originalText: eventData.text,
                      simplifiedText: eventData.simplifiedText,
                      previousSimplifiedTexts: eventData.previousSimplifiedTexts || [],
                      shouldAllowSimplifyMore: eventData.shouldAllowSimplifyMore || false,
                      explanationQuestions: ChatDialog.simplifiedData.explanationQuestions, // Store questions
                      possibleQuestions: ChatDialog.simplifiedData.possibleQuestions, // Store questions
                      timestamp: new Date().toISOString()
                    };
                    
                    // Check if this text already exists in simplifiedMeanings
                    const existingTextIndex = activeContent.analysis.simplifiedMeanings.findIndex(s => 
                      s.textKey === matchingTextKey
                    );
                    
                    if (existingTextIndex !== -1) {
                      // Update existing simplified text
                      activeContent.analysis.simplifiedMeanings[existingTextIndex] = simplifiedTextData;
                      console.log(`[ButtonPanel] Updated existing simplified text for textKey "${matchingTextKey}" in analysis data with questions`);
                    } else {
                      // Add new simplified text
                      activeContent.analysis.simplifiedMeanings.push(simplifiedTextData);
                      console.log(`[ButtonPanel] Added new simplified text for textKey "${matchingTextKey}" to analysis data with questions`);
                    }
                  }
                }
                
                // Update button states after adding to simplifiedTexts
                  this.updateButtonStatesFromSelections();
                
                console.log('[ButtonPanel] Updated UI for text segment:', matchingTextKey);
                }
              }
            }
          },
          // onComplete callback
          () => {
            console.log('[ButtonPanel] All text simplification complete');
            
            // Remove loading animation from any remaining highlights (in case some failed)
            for (const textKey of textKeysToProcess) {
              const highlight = TextSelector.textToHighlights.get(textKey);
              if (highlight && highlight.classList.contains('vocab-text-loading')) {
                highlight.classList.remove('vocab-text-loading');
              }
            }

            // Mark simplify API as completed
            this.apiCompletionState.simplifyCompleted = true;
            console.log('[ButtonPanel] Simplify API marked as completed');
            
            // Check if all APIs are complete
            this.checkAPICompletion();
          },
          // onError callback
          (error) => {
            console.error('[ButtonPanel] Error during text simplification:', error);
            
            // Revert all changes for each textKey
            for (const textKey of textKeysToProcess) {
              const highlight = TextSelector.textToHighlights.get(textKey);
              
              // Remove pulsating animation
              if (highlight) {
                highlight.classList.remove('vocab-text-loading');
                
                // Remove data-processing-magic-meaning attribute
                highlight.removeAttribute('data-processing-magic-meaning');
                
                // Remove purple spinner at book icon location
                const bookSpinnerWrapper = highlight.querySelector('.vocab-text-book-spinner-wrapper');
                if (bookSpinnerWrapper) {
                  bookSpinnerWrapper.remove();
                }
              }
              
              // Remove spinner containers on document.body
              const spinnerOnBody = window.safeQueryByDataTextKey('.vocab-magic-meaning-spinner-container', textKey);
              if (spinnerOnBody) {
                spinnerOnBody.remove();
              }
              
              // Remove magic meaning button from buttonWrapper (floating button on body) if it exists
              const buttonWrapper = TextSelector.buttonWrappers?.get(textKey);
              if (buttonWrapper) {
                // Clean up fixed scroll handler if it exists
                if (buttonWrapper._fixedScrollHandler) {
                  window.removeEventListener('scroll', buttonWrapper._fixedScrollHandler);
                  buttonWrapper._fixedScrollHandler = null;
                  buttonWrapper._fixedPosition = null;
                }
                
                // Clean up event listeners if they exist
                if (buttonWrapper._cleanupHandlers) {
                  window.removeEventListener('scroll', buttonWrapper._cleanupHandlers.scroll);
                  window.removeEventListener('resize', buttonWrapper._cleanupHandlers.resize);
                  document.removeEventListener('mouseup', buttonWrapper._cleanupHandlers.cleanup);
                  document.removeEventListener('mousedown', buttonWrapper._cleanupHandlers.cleanup);
                  document.removeEventListener('selectionchange', buttonWrapper._cleanupHandlers.cleanup);
                  document.removeEventListener('touchend', buttonWrapper._cleanupHandlers.cleanup);
                }
                
                // Remove buttonWrapper from DOM
                if (buttonWrapper.parentNode) {
                  buttonWrapper.remove();
                }
                
                // Remove from buttonWrappers map
                TextSelector.buttonWrappers?.delete(textKey);
              }
              
              // Remove magic meaning button from highlight's iconsWrapper if it exists
              if (highlight) {
                const iconsWrapper = highlight.querySelector('.vocab-text-icons-wrapper');
                if (iconsWrapper) {
                  const magicBtn = iconsWrapper.querySelector('.vocab-text-magic-meaning-btn');
                  if (magicBtn) {
                    magicBtn.remove();
                  }
                  // Remove iconsWrapper if it's now empty
                  if (iconsWrapper.children.length === 0) {
                    iconsWrapper.remove();
                  }
                }
                
                // Also check for magic button directly in highlight (fallback)
                const magicBtnDirect = highlight.querySelector('.vocab-text-magic-meaning-btn');
                if (magicBtnDirect) {
                  magicBtnDirect.remove();
                }
              }
              
              // Revert span element: remove highlight and restore original text
              if (highlight) {
                TextSelector.removeHighlight(highlight);
              }
              
              // Clean up data structures
              TextSelector.selectedTexts.delete(textKey);
              TextSelector.textToHighlights.delete(textKey);
            }
            
            // Update button states after cleanup
            this.updateButtonStatesFromSelections();
            
            // Extract error message from error object
            const errorMessage = error?.message || error?.reason || error?.error?.message || 'Error simplifying text. Please try again.';
            
            // Show error notification with actual error message
            TextSelector.showNotification(errorMessage);

            // Mark simplify API as completed (even on error)
            this.apiCompletionState.simplifyCompleted = true;
            console.log('[ButtonPanel] Simplify API marked as completed (with error)');
            
            // Check if all APIs are complete
            this.checkAPICompletion();
          }
        );
      }
    }
    
    // ========== Process Word Selections (new functionality) ==========
    if (selectedWords.size > 0) {
      console.log('[ButtonPanel] ===== MAGIC MEANING: Processing Words =====');
      console.log('[ButtonPanel] Processing', selectedWords.size, 'selected words');
      console.log('[ButtonPanel] Selected words list:', Array.from(selectedWords));
      
      // Build API payload for words with 10-word context
      const wordPayload = WordSelector.buildWordsExplanationPayload();
      
      if (wordPayload.length === 0) {
        console.warn('[ButtonPanel] No word segments with position data');
        
        // Mark words explanation API as completed (no payload to process)
        this.apiCompletionState.wordsExplanationCompleted = true;
        console.log('[ButtonPanel] Words explanation API marked as completed (no payload)');
        
        // Check if all APIs are complete
        this.checkAPICompletion();
        return;
      }
      
      console.log('[ButtonPanel] Word payload segments:', wordPayload.length);
      console.log('[ButtonPanel] Full word payload:', JSON.stringify(wordPayload.map(s => ({
        textStartIndex: s.textStartIndex,
        text: s.text.substring(0, 100) + '...',
        words: s.important_words_location.map(w => w.word),
        highlightCount: s._wordHighlights ? s._wordHighlights.length : 0
      })), null, 2));
      
      // Track all word highlights for this request
      const allWordHighlights = [];
      wordPayload.forEach(segment => {
        if (segment._wordHighlights) {
          allWordHighlights.push(...segment._wordHighlights);
        }
      });
      
      console.log('[ButtonPanel] Total word highlights to process:', allWordHighlights.length);
      
      // Remove words from selectedWords container as API call starts
      selectedWords.forEach(word => {
        WordSelector.selectedWords.delete(word);
      });
      
      // Update button states
      this.updateButtonStatesFromSelections();
      
      // Visual feedback: Remove cross icons and start pulsating animation
      allWordHighlights.forEach((highlight, idx) => {
        const word = highlight.getAttribute('data-word');
        console.log(`[ButtonPanel] Setting up highlight #${idx + 1} for word "${word}"`);
        
        // Remove cross button
        const existingBtn = highlight.querySelector('.vocab-word-remove-btn');
        if (existingBtn) {
          existingBtn.remove();
        }
        
        // Add pulsating purple animation
        highlight.classList.add('vocab-word-loading');
      });
      
      // Prepare API payload (remove internal tracking property)
      const apiPayload = wordPayload.map(segment => ({
        textStartIndex: segment.textStartIndex,
        text: segment.text,
        important_words_location: segment.important_words_location
      }));
      
      console.log('[ButtonPanel] Sending API request with payload:', JSON.stringify(apiPayload, null, 2));
      
      // Call ApiService with SSE
      ApiService.explainWords(
        apiPayload,
        // onEvent callback - called for each word explanation
        (eventData) => {
          console.log('[ButtonPanel] ===== SSE EVENT RECEIVED =====');
          console.log('[ButtonPanel] Full event data:', JSON.stringify(eventData, null, 2));
          
          const wordInfo = eventData.word_info;
          if (!wordInfo) {
            console.warn('[ButtonPanel] No word_info in event data');
            return;
          }
          
          // Use word_info.location.word for matching instead of word_info.word
          // This fixes issues with incorrect word extraction and case sensitivity
          const targetWord = wordInfo.location?.word || wordInfo.word;
          const normalizedTargetWord = targetWord.toLowerCase().trim();
          
          console.log(`[ButtonPanel] ===== PROCESSING WORD: "${targetWord}" =====`);
          console.log(`[ButtonPanel] Word info - word: "${wordInfo.word}" (original)`);
          console.log(`[ButtonPanel] Word info - location.word: "${wordInfo.location?.word}" (using for matching)`);
          console.log(`[ButtonPanel] Target word for matching: "${targetWord}"`);
          console.log(`[ButtonPanel] Normalized target word: "${normalizedTargetWord}"`);
          console.log(`[ButtonPanel] Word info - textStartIndex: ${wordInfo.textStartIndex}`);
          console.log(`[ButtonPanel] Word location:`, wordInfo.location);
          console.log(`[ButtonPanel] Word meaning:`, wordInfo.meaning);
          console.log(`[ButtonPanel] Word examples:`, wordInfo.examples);
          
          // Special debugging for "government" word
          if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
            console.log(`[ButtonPanel] ===== SPECIAL DEBUG FOR GOVERNMENT WORD =====`);
            console.log(`[ButtonPanel] This is the government word!`);
            console.log(`[ButtonPanel] Full event data for government:`, JSON.stringify(eventData, null, 2));
          }
          
          // Log all available segments for debugging
          console.log('[ButtonPanel] Available segments for matching:');
          wordPayload.forEach((segment, idx) => {
            console.log(`[ButtonPanel] Segment #${idx + 1}:`, {
              textStartIndex: segment.textStartIndex,
              textEnd: segment.textStartIndex + segment.text.length,
              textPreview: segment.text.substring(0, 50) + '...',
              words: segment.important_words_location.map(w => w.word),
              highlightCount: segment._wordHighlights ? segment._wordHighlights.length : 0
            });
            
            // Special debugging for government word segments
            if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
              console.log(`[ButtonPanel] ===== GOVERNMENT SEGMENT DEBUG #${idx + 1} =====`);
              console.log(`[ButtonPanel] Segment textStartIndex: ${segment.textStartIndex}`);
              console.log(`[ButtonPanel] Segment text: "${segment.text}"`);
              console.log(`[ButtonPanel] Important words in segment:`, segment.important_words_location);
              console.log(`[ButtonPanel] Highlights in segment:`, segment._wordHighlights?.map(hl => ({
                dataWord: hl.getAttribute('data-word'),
                textContent: hl.textContent.trim(),
                classes: hl.className
              })));
            }
          });
          
          // Find the corresponding segment and highlight
          // First try exact match
          let matchingSegment = wordPayload.find(segment => 
            segment.textStartIndex === wordInfo.textStartIndex
          );
          
          console.log(`[ButtonPanel] Exact match result:`, matchingSegment ? 'FOUND' : 'NOT FOUND');
          
          // Special debugging for government word matching
          if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
            console.log(`[ButtonPanel] ===== GOVERNMENT EXACT MATCH DEBUG =====`);
            console.log(`[ButtonPanel] Looking for textStartIndex: ${wordInfo.textStartIndex}`);
            wordPayload.forEach((segment, idx) => {
              const isMatch = segment.textStartIndex === wordInfo.textStartIndex;
              console.log(`[ButtonPanel] Segment #${idx + 1} textStartIndex: ${segment.textStartIndex}, matches: ${isMatch}`);
            });
            console.log(`[ButtonPanel] Matching segment found:`, matchingSegment ? 'YES' : 'NO');
          }
          
          // If no exact match, try to find by word name and location within merged segments
          if (!matchingSegment) {
            console.log(`[ButtonPanel] No exact match for textStartIndex ${wordInfo.textStartIndex}, trying word-based matching`);
            
            matchingSegment = wordPayload.find(segment => {
              // Check if this segment contains the word using normalized target word
              const wordLocation = segment.important_words_location.find(w => 
                w.word.toLowerCase() === normalizedTargetWord
              );
              
              if (!wordLocation) return false;
              
              // Check if the textStartIndex falls within this segment's range
              const segmentEnd = segment.textStartIndex + segment.text.length;
              const isInRange = wordInfo.textStartIndex >= segment.textStartIndex && wordInfo.textStartIndex < segmentEnd;
              
              console.log(`[ButtonPanel] Checking segment (${segment.textStartIndex}-${segmentEnd}): word "${normalizedTargetWord}" found: ${!!wordLocation}, inRange: ${isInRange}`);
              
              // Special debugging for government word
              if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
                console.log(`[ButtonPanel] ===== GOVERNMENT WORD-BASED MATCH DEBUG =====`);
                console.log(`[ButtonPanel] Segment textStartIndex: ${segment.textStartIndex}`);
                console.log(`[ButtonPanel] Segment textEnd: ${segmentEnd}`);
                console.log(`[ButtonPanel] Word textStartIndex: ${wordInfo.textStartIndex}`);
                console.log(`[ButtonPanel] Word location found:`, wordLocation);
                console.log(`[ButtonPanel] Is in range: ${isInRange}`);
                console.log(`[ButtonPanel] All words in segment:`, segment.important_words_location.map(w => w.word));
              }
              
              return isInRange;
            });
            
            console.log(`[ButtonPanel] Word-based match result:`, matchingSegment ? 'FOUND' : 'NOT FOUND');
          }
          
          if (!matchingSegment) {
            console.error(`[ButtonPanel] ✗ NO MATCHING SEGMENT FOUND for textStartIndex ${wordInfo.textStartIndex}, word: "${targetWord}"`);
            console.log('[ButtonPanel] Available segments:', wordPayload.map(s => ({ 
              textStartIndex: s.textStartIndex, 
              textEnd: s.textStartIndex + s.text.length,
              words: s.important_words_location.map(w => w.word) 
            })));
            console.log(`[ButtonPanel] ✗ SKIPPING WORD "${targetWord}" - NO SEGMENT MATCH`);
            return;
          }
          
          console.log(`[ButtonPanel] ✓ Found matching segment with ${matchingSegment._wordHighlights ? matchingSegment._wordHighlights.length : 0} highlights`);
          
          if (matchingSegment && matchingSegment._wordHighlights) {
            // Find the specific word highlight within this segment
            const wordLocation = wordInfo.location;
            console.log(`[ButtonPanel] ===== LOOKING FOR HIGHLIGHT ELEMENT =====`);
            console.log(`[ButtonPanel] Looking for word "${targetWord}" (normalized: "${normalizedTargetWord}") in ${matchingSegment._wordHighlights.length} highlights`);
            
            // Log all highlights in detail
            matchingSegment._wordHighlights.forEach((hl, idx) => {
              const dataWord = hl.getAttribute('data-word');
              const textContent = hl.textContent.trim();
              const classes = hl.className;
              const isCurrentlyLoading = hl.classList.contains('vocab-word-loading');
              const isAlreadyExplained = hl.classList.contains('vocab-word-explained');
              
              console.log(`[ButtonPanel] Highlight #${idx + 1}:`, {
                dataWord: dataWord,
                textContent: textContent,
                classes: classes,
                isCurrentlyLoading: isCurrentlyLoading,
                isAlreadyExplained: isAlreadyExplained,
                matchesTargetWord: dataWord && dataWord.toLowerCase() === normalizedTargetWord
              });
              
              // Special debugging for government word highlights
              if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
                console.log(`[ButtonPanel] ===== GOVERNMENT HIGHLIGHT DEBUG #${idx + 1} =====`);
                console.log(`[ButtonPanel] Highlight data-word: "${dataWord}"`);
                console.log(`[ButtonPanel] Highlight textContent: "${textContent}"`);
                console.log(`[ButtonPanel] Highlight classes: "${classes}"`);
                console.log(`[ButtonPanel] Target word: "${normalizedTargetWord}"`);
                console.log(`[ButtonPanel] Does data-word match target: ${dataWord && dataWord.toLowerCase() === normalizedTargetWord}`);
                console.log(`[ButtonPanel] Does textContent match target: ${textContent.toLowerCase() === normalizedTargetWord}`);
                console.log(`[ButtonPanel] Is currently loading: ${isCurrentlyLoading}`);
                console.log(`[ButtonPanel] Is already explained: ${isAlreadyExplained}`);
              }
            });
            
            // Try multiple matching strategies for robustness
            console.log(`[ButtonPanel] ===== ATTEMPTING HIGHLIGHT MATCHING =====`);
            
            let wordHighlight = matchingSegment._wordHighlights.find(hl => {
              const dataWord = hl.getAttribute('data-word');
              const matches = dataWord && dataWord.toLowerCase() === normalizedTargetWord;
              console.log(`[ButtonPanel] Strategy 1 (data-word): "${dataWord}" === "${normalizedTargetWord}" = ${matches}`);
              
              // Special debugging for government word
              if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
                console.log(`[ButtonPanel] ===== GOVERNMENT STRATEGY 1 DEBUG =====`);
                console.log(`[ButtonPanel] Checking highlight with data-word: "${dataWord}"`);
                console.log(`[ButtonPanel] Target normalized word: "${normalizedTargetWord}"`);
                console.log(`[ButtonPanel] Match result: ${matches}`);
              }
              
              return matches;
            });
            
            // If not found by data-word attribute, try by text content
            if (!wordHighlight) {
              console.log(`[ButtonPanel] Strategy 1 failed, trying Strategy 2 (text content) for word "${normalizedTargetWord}"`);
              wordHighlight = matchingSegment._wordHighlights.find(hl => {
                const highlightText = hl.textContent.trim().toLowerCase();
                const matches = highlightText === normalizedTargetWord;
                console.log(`[ButtonPanel] Strategy 2 (text content): "${highlightText}" === "${normalizedTargetWord}" = ${matches}`);
                
                // Special debugging for government word
                if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
                  console.log(`[ButtonPanel] ===== GOVERNMENT STRATEGY 2 DEBUG =====`);
                  console.log(`[ButtonPanel] Checking highlight with textContent: "${highlightText}"`);
                  console.log(`[ButtonPanel] Target normalized word: "${normalizedTargetWord}"`);
                  console.log(`[ButtonPanel] Match result: ${matches}`);
                }
                
                return matches;
              });
            }
            
            // If still not found, try partial matching
            if (!wordHighlight) {
              console.log(`[ButtonPanel] Strategy 2 failed, trying Strategy 3 (partial matching) for word "${normalizedTargetWord}"`);
              wordHighlight = matchingSegment._wordHighlights.find(hl => {
                const highlightText = hl.textContent.trim().toLowerCase();
                const matches = highlightText.includes(normalizedTargetWord) || 
                       normalizedTargetWord.includes(highlightText);
                console.log(`[ButtonPanel] Strategy 3 (partial): "${highlightText}" includes "${normalizedTargetWord}" = ${matches}`);
                
                // Special debugging for government word
                if (normalizedTargetWord === 'government' || wordInfo.word?.toLowerCase().includes('government')) {
                  console.log(`[ButtonPanel] ===== GOVERNMENT STRATEGY 3 DEBUG =====`);
                  console.log(`[ButtonPanel] Checking highlight with textContent: "${highlightText}"`);
                  console.log(`[ButtonPanel] Target normalized word: "${normalizedTargetWord}"`);
                  console.log(`[ButtonPanel] Partial match result: ${matches}`);
                }
                
                return matches;
              });
            }
            
            if (wordHighlight) {
              console.log(`[ButtonPanel] ===== APPLYING GREEN BACKGROUND =====`);
              console.log(`[ButtonPanel] ✓ Found matching highlight for word "${targetWord}"`);
              console.log(`[ButtonPanel] Highlight element before changes:`, {
                classes: wordHighlight.className,
                dataWord: wordHighlight.getAttribute('data-word'),
                textContent: wordHighlight.textContent.trim(),
                hasLoadingClass: wordHighlight.classList.contains('vocab-word-loading'),
                hasExplainedClass: wordHighlight.classList.contains('vocab-word-explained')
              });
              
              // Remove pulsating animation
              console.log(`[ButtonPanel] Removing loading class from highlight`);
              wordHighlight.classList.remove('vocab-word-loading');
              
              // Remove old purple cross button if exists
              const oldBtn = wordHighlight.querySelector('.vocab-word-remove-btn');
              if (oldBtn) {
                console.log(`[ButtonPanel] Removing old purple cross button`);
                oldBtn.remove();
              }
              
              // Force a reflow to ensure the element is ready for animation
              void wordHighlight.offsetWidth;
              
              // Change background to green with popup animation
              console.log(`[ButtonPanel] Adding vocab-word-explained class for green background`);
              wordHighlight.classList.add('vocab-word-explained', 'word-popup');
              
              // Force another reflow to trigger the animation
              void wordHighlight.offsetWidth;
              
              // Remove popup animation after it completes (0.6s)
              setTimeout(() => {
                wordHighlight.classList.remove('word-popup');
                // Re-enable transition after animation completes
                wordHighlight.style.transition = '';
                wordHighlight.style.willChange = '';
              }, 600);
              
              // Store explanation data on the element
              console.log(`[ButtonPanel] Storing explanation data on element`);
              wordHighlight.setAttribute('data-meaning', wordInfo.meaning);
              wordHighlight.setAttribute('data-examples', JSON.stringify(wordInfo.examples));
              
              // Store word explanation in analysis data for persistence
              if (this.topicsModal.customContentModal.activeTabId) {
                const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(this.topicsModal.customContentModal.activeTabId));
                if (activeContent && activeContent.analysis) {
                  // Check if this word already exists in wordMeanings
                  const existingWordIndex = activeContent.analysis.wordMeanings.findIndex(w => 
                    w.word.toLowerCase() === normalizedTargetWord
                  );
                  
                  const wordExplanationData = {
                    word: targetWord,
                    normalizedWord: normalizedTargetWord,
                    meaning: wordInfo.meaning,
                    examples: wordInfo.examples,
                    shouldAllowFetchMoreExamples: wordInfo.shouldAllowFetchMoreExamples || false,
                    textStartIndex: wordInfo.textStartIndex,
                    location: wordInfo.location,
                    timestamp: new Date().toISOString()
                  };
                  
                  if (existingWordIndex !== -1) {
                    // Update existing word explanation
                    activeContent.analysis.wordMeanings[existingWordIndex] = wordExplanationData;
                    console.log(`[ButtonPanel] Updated existing word explanation for "${targetWord}" in analysis data`);
                  } else {
                    // Add new word explanation
                    activeContent.analysis.wordMeanings.push(wordExplanationData);
                    console.log(`[ButtonPanel] Added new word explanation for "${targetWord}" to analysis data`);
                  }
                }
              }
              
              // Add green wireframe cross button
              console.log(`[ButtonPanel] Adding green cross button`);
              const greenCrossBtn = WordSelector.createRemoveExplainedButton(targetWord);
              wordHighlight.appendChild(greenCrossBtn);
              
              // Store in explainedWords map
              // Extract languageCode from eventData (could be at top level or in word_info)
              const languageCode = eventData.languageCode || wordInfo.languageCode || null;
              const normalizedWord = normalizedTargetWord;
              
              if (!WordSelector.explainedWords.has(normalizedWord)) {
                console.log(`[ButtonPanel] Creating new entry in explainedWords map for "${normalizedWord}"`);
                WordSelector.explainedWords.set(normalizedWord, {
                  word: targetWord,
                  meaning: wordInfo.meaning,
                  examples: wordInfo.examples,
                  shouldAllowFetchMoreExamples: wordInfo.shouldAllowFetchMoreExamples || false,
                  hasCalledGetMoreExamples: false, // Track if get-more-explanations API has been called
                  languageCode: languageCode,
                  highlights: new Set()
                });
              } else {
                // Update existing entry with languageCode if not already set
                const existingEntry = WordSelector.explainedWords.get(normalizedWord);
                if (!existingEntry.languageCode && languageCode) {
                  existingEntry.languageCode = languageCode;
                }
              }
              WordSelector.explainedWords.get(normalizedWord).highlights.add(wordHighlight);
              
              // Setup hover and click interactions for this word
              console.log(`[ButtonPanel] Setting up word interactions`);
              WordSelector.setupWordInteractions(wordHighlight);
              
              // Update button states to show "Remove meanings" button
              console.log(`[ButtonPanel] Updating button states`);
              ButtonPanel.updateButtonStatesFromSelections();
              
              console.log(`[ButtonPanel] ===== GREEN BACKGROUND APPLIED SUCCESSFULLY =====`);
              console.log('[ButtonPanel] ✓ Updated UI for word:', targetWord);
              console.log('[ButtonPanel] Highlight element after changes:', {
                classes: wordHighlight.className,
                hasLoadingClass: wordHighlight.classList.contains('vocab-word-loading'),
                hasExplainedClass: wordHighlight.classList.contains('vocab-word-explained')
              });
              console.log('[ButtonPanel] explainedWords container size:', WordSelector.explainedWords.size);
              
              // Automatically show word meaning popup after green background is applied
              // Use a small delay to ensure DOM is updated and breathing animation starts
              setTimeout(() => {
                console.log('[ButtonPanel] ===== AUTO-SHOWING WORD MEANING POPUP =====');
                const normalizedTargetWord = targetWord.toLowerCase();
                console.log('[ButtonPanel] Word highlight element:', {
                  element: wordHighlight,
                  isInDOM: document.body.contains(wordHighlight),
                  classes: wordHighlight.className,
                  hasExplainedClass: wordHighlight.classList.contains('vocab-word-explained'),
                  textContent: wordHighlight.textContent.trim(),
                  dataWord: wordHighlight.getAttribute('data-word'),
                  normalizedWord: normalizedTargetWord,
                  isInExplainedWords: WordSelector.explainedWords.has(normalizedTargetWord)
                });
                
                // Validate element before showing popup
                if (!wordHighlight || !document.body.contains(wordHighlight)) {
                  console.error('[ButtonPanel] ✗ Word highlight element is not in DOM, cannot show popup');
                  return;
                }
                
                if (!wordHighlight.classList.contains('vocab-word-explained')) {
                  console.error('[ButtonPanel] ✗ Word highlight does not have vocab-word-explained class, cannot show popup');
                  console.error('[ButtonPanel] Current classes:', wordHighlight.className);
                  return;
                }
                
                if (!WordSelector.explainedWords.has(normalizedTargetWord)) {
                  console.error('[ButtonPanel] ✗ Word not found in explainedWords map, cannot show popup');
                  console.error('[ButtonPanel] Available words in map:', Array.from(WordSelector.explainedWords.keys()));
                  return;
                }
                
                console.log('[ButtonPanel] ✓ All validations passed, showing popup');
                WordSelector.showWordPopup(wordHighlight, true); // Show as sticky popup
              }, 100);
            } else {
              console.error(`[ButtonPanel] ===== HIGHLIGHT MATCHING FAILED =====`);
              console.error(`[ButtonPanel] ✗ No matching highlight found for word "${targetWord}"`);
              console.error(`[ButtonPanel] All matching strategies failed for word "${targetWord}"`);
              console.error(`[ButtonPanel] Available highlights:`, matchingSegment._wordHighlights.map(hl => ({
                word: hl.getAttribute('data-word'),
                text: hl.textContent.trim(),
                classes: hl.className
              })));
              console.error(`[ButtonPanel] ✗ WORD "${targetWord}" WILL NOT GET GREEN BACKGROUND`);
            }
          }
        },
        // onComplete callback
        () => {
          console.log('[ButtonPanel] ===== SSE STREAM COMPLETE =====');
          console.log('[ButtonPanel] All word explanations complete');
          
          // Count how many words are still loading
          let stillLoading = 0;
          const stillLoadingWords = [];
          
          console.log('[ButtonPanel] ===== CHECKING FINAL STATUS OF ALL HIGHLIGHTS =====');
          allWordHighlights.forEach((highlight, idx) => {
            const word = highlight.getAttribute('data-word');
            const isStillLoading = highlight.classList.contains('vocab-word-loading');
            const isExplained = highlight.classList.contains('vocab-word-explained');
            
            console.log(`[ButtonPanel] Highlight #${idx + 1} for word "${word}":`, {
              isStillLoading: isStillLoading,
              isExplained: isExplained,
              classes: highlight.className,
              textContent: highlight.textContent.trim()
            });
            
            if (isStillLoading) {
              stillLoading++;
              stillLoadingWords.push(word);
              console.warn(`[ButtonPanel] ⚠️ Highlight #${idx + 1} for word "${word}" still in loading state - NO API RESPONSE RECEIVED`);
              console.warn(`[ButtonPanel] ⚠️ This word will NOT get green background because no API response was received`);
              highlight.classList.remove('vocab-word-loading');
            } else if (isExplained) {
              console.log(`[ButtonPanel] ✅ Highlight #${idx + 1} for word "${word}" successfully explained with green background`);
            } else {
              console.warn(`[ButtonPanel] ❓ Highlight #${idx + 1} for word "${word}" is neither loading nor explained - UNKNOWN STATE`);
            }
          });
          
          console.log(`[ButtonPanel] ===== FINAL SUMMARY =====`);
          console.log(`[ButtonPanel] Total highlights: ${allWordHighlights.length}`);
          console.log(`[ButtonPanel] Successfully explained: ${allWordHighlights.length - stillLoading}`);
          console.log(`[ButtonPanel] Still loading (no response): ${stillLoading}`);
          console.log(`[ButtonPanel] Success rate: ${Math.round((allWordHighlights.length - stillLoading) / allWordHighlights.length * 100)}%`);
          
          if (stillLoadingWords.length > 0) {
            console.warn(`[ButtonPanel] ⚠️ Words that did NOT receive API responses:`, stillLoadingWords);
            console.warn(`[ButtonPanel] ⚠️ These words will remain purple (not green) because no backend response was received`);
          }
          
          console.log('[ButtonPanel] ===== MAGIC MEANING: Complete =====');

          // Mark words explanation API as completed
          this.apiCompletionState.wordsExplanationCompleted = true;
          console.log('[ButtonPanel] Words explanation API marked as completed');
          
          // Check if all APIs are complete
          this.checkAPICompletion();
        },
        // onError callback
        (error) => {
          console.error('[ButtonPanel] ===== WORDS-EXPLANATION ERROR CALLBACK =====');
          console.error('[ButtonPanel] Error during word explanation:', error);
          console.error('[ButtonPanel] Error name:', error?.name);
          console.error('[ButtonPanel] Error message:', error?.message);
          console.error('[ButtonPanel] Error status:', error?.status);
          console.error('[ButtonPanel] Error errorCode:', error?.errorCode);
          console.error('[ButtonPanel] Full error object:', error);
          
          // Check if this is a LOGIN_REQUIRED error
          if (error?.errorCode === 'LOGIN_REQUIRED') {
            console.log('[ButtonPanel] ===== LOGIN_REQUIRED DETECTED IN ERROR CALLBACK =====');
            console.log('[ButtonPanel] Error has errorCode LOGIN_REQUIRED, login modal should be shown via event');
            console.log('[ButtonPanel] Checking if api-login-required event was dispatched...');
            // The event should have been dispatched by ApiService.handleApiError
            // But we'll add a fallback check below
            
            // FALLBACK: Show login modal directly if event wasn't received
            // This ensures the modal is shown even if the event system fails
            console.log('[ButtonPanel] FALLBACK: Checking if LoginModal is available...');
            if (typeof LoginModal !== 'undefined') {
              console.log('[ButtonPanel] FALLBACK: LoginModal is defined, showing login modal directly');
              const reason = error?.message || 'Please sign in to continue';
              LoginModal.show(reason, 'WORDS_EXPLANATION');
              console.log('[ButtonPanel] FALLBACK: LoginModal.show() called with reason:', reason, 'and apiEndpoint: WORDS_EXPLANATION');
            } else {
              console.error('[ButtonPanel] FALLBACK: ⚠️ LoginModal is undefined! Cannot show login modal');
            }
          }
          
          // Remove pulsating animation from all highlights
          allWordHighlights.forEach((highlight, idx) => {
            const word = highlight.getAttribute('data-word');
            console.log(`[ButtonPanel] Removing loading state from highlight #${idx + 1} for word "${word}"`);
            highlight.classList.remove('vocab-word-loading');
          });
          
          // Show error notification (but not for LOGIN_REQUIRED - that should show modal)
          if (error?.errorCode !== 'LOGIN_REQUIRED') {
            TextSelector.showNotification('Error getting word meanings. Please try again.');
          } else {
            console.log('[ButtonPanel] Skipping error notification for LOGIN_REQUIRED (login modal should be shown)');
          }

          // Mark words explanation API as completed (even on error)
          this.apiCompletionState.wordsExplanationCompleted = true;
          console.log('[ButtonPanel] Words explanation API marked as completed (with error)');
          
          // Check if all APIs are complete
          this.checkAPICompletion();
          
          console.error('[ButtonPanel] ===== WORDS-EXPLANATION ERROR CALLBACK COMPLETE =====');
        }
      );
    }
  },

  /**
   * Handler for Ask button
   */
  async handleAsk() {
    // Check if extension is globally enabled
    const isEnabled = await this.checkExtensionEnabled();
    if (!isEnabled) {
      console.log('[ButtonPanel] Extension is disabled, ignoring ask click');
      return;
    }
    
    console.log('[ButtonPanel] Ask button clicked');
    
    // Get the first selected text
    const selectedTexts = TextSelector.getSelectedTexts();
    
    if (selectedTexts.size === 0) {
      console.warn('[ButtonPanel] No text selected');
      return;
    }
    
    if (selectedTexts.size > 1) {
      console.warn('[ButtonPanel] Multiple texts selected, button should be disabled');
      return;
    }
    
    // Get the first (and only) text
    const textKey = Array.from(selectedTexts)[0];
    const textHighlight = TextSelector.textToHighlights.get(textKey);
    
    if (textHighlight) {
      const originalText = textHighlight.textContent.replace(/\s+/g, ' ').trim();
      
      // Move text from selectedTexts to askedTexts
      TextSelector.moveToAskedTexts(textKey);
      
      // Open chat dialog with selected context
      ChatDialog.open(originalText, textKey, 'ask', null, 'selected');
    }
  },

  /**
   * Handler for Custom content button
   */
  handleCustomContent() {
    console.log('[ButtonPanel] Custom content button clicked');
    
    // For now, just show an alert - this can be expanded later
    alert('Custom content feature coming soon!');
  },

  /**
   * Check if the custom content modal is currently open
   * @returns {boolean} True if the modal is open, false otherwise
   */
  isCustomContentModalOpen() {
    return false;
  },

  /**
   * Get the currently active content type from the custom content modal
   * @returns {string|null} The active content type ('pdf', 'image', 'topic', 'text') or null if no modal is open
   */
  getCurrentContentType() {
    return null;
  },

  /**
   * Show text input modal
   */
  showTextInputModal() {
    console.log('[ButtonPanel] Showing text input modal');
    
    // Create modal if it doesn't exist
    if (!this.textInputModal) {
      this.createTextInputModal();
      
      // Wait for DOM to be ready before showing modal using double requestAnimationFrame
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          this.showTextModalWithAnimation();
        });
      });
    } else {
      // Modal already exists, just show it
      this.showTextModalWithAnimation();
    }
  },

  /**
   * Create text input modal HTML structure
   */
  createTextInputModal() {
    console.log('[ButtonPanel] Creating text input modal...');
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'vocab-text-input-overlay';
    overlay.id = 'vocab-text-input-overlay';
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'vocab-text-input-modal';
    
    // Create header
    const header = document.createElement('div');
    header.className = 'vocab-text-input-header';
    
    const title = document.createElement('h2');
    title.className = 'vocab-text-input-title';
    title.textContent = 'Paste content to study';
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'vocab-text-input-close';
    closeBtn.innerHTML = `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    closeBtn.setAttribute('aria-label', 'Close modal');
    
    header.appendChild(title);
    header.appendChild(closeBtn);
    
    
    // Create content container
    const contentContainer = document.createElement('div');
    contentContainer.className = 'vocab-text-input-content empty';
    
    // Create textarea (using contenteditable div for highlighting support)
    const textarea = document.createElement('div');
    textarea.className = 'vocab-text-input-textarea';
    textarea.setAttribute('contenteditable', 'true');
    textarea.setAttribute('data-placeholder', 'Paste your content here');
    textarea.setAttribute('role', 'textbox');
    textarea.setAttribute('aria-multiline', 'true');
    
    contentContainer.appendChild(textarea);
    
    // Create proceed button
    const proceedBtn = document.createElement('button');
    proceedBtn.className = 'vocab-text-input-proceed-btn hidden';
    proceedBtn.textContent = 'Proceed';
    
    // Assemble modal
    modal.appendChild(header);
    modal.appendChild(contentContainer);
    modal.appendChild(proceedBtn);
    
    overlay.appendChild(modal);
    
    // Append to body
    document.body.appendChild(overlay);
    
    // Store references
    this.textInputModal = {
      overlay: overlay,
      modal: modal,
      textarea: textarea,
      proceedBtn: proceedBtn,
      closeBtn: closeBtn
    };
    
    // Attach event listeners
    this.attachTextInputModalListeners();
  },

  /**
   * Show text modal with animation
   */
  showTextModalWithAnimation() {
    console.log('[ButtonPanel] Showing text modal with animation');
    
    // Clear all selections when opening modal
    this.clearSelectionsOnModalOpen();
    
    if (this.textInputModal && this.textInputModal.overlay) {
      this.textInputModal.overlay.classList.add('visible');
      this.textInputModal.modal.classList.add('visible');
      
      // Add class to body to blur webpage icons
      document.body.classList.add('vocab-text-modal-open');
      
      // Focus on textarea and check border radius
      setTimeout(() => {
        if (this.textInputModal.textarea) {
          this.textInputModal.textarea.focus();
          this.updateTextareaBorderRadius(this.textInputModal.textarea);
        }
      }, 300);
    }
  },

  /**
   * Hide text input modal
   */
  hideTextInputModal() {
    console.log('[ButtonPanel] Hiding text input modal');
    
    // Hide search preview if visible
    this.hideTextSearchPreview();
    
    if (this.textInputModal && this.textInputModal.overlay) {
      this.textInputModal.overlay.classList.remove('visible');
      this.textInputModal.modal.classList.remove('visible');
      
      // Remove class from body to show webpage icons again
      document.body.classList.remove('vocab-text-modal-open');
      
      // Clear textarea after animation and hide search bar and proceed button
      setTimeout(() => {
        if (this.textInputModal.textarea) {
          this.textInputModal.textarea.textContent = '';
          this.textInputModal.textarea.innerHTML = '';
        }
        
        // Clear search input
        if (this.textInputModal.searchInput) {
          this.textInputModal.searchInput.value = '';
        }
        
        // Hide search bar and proceed button
        const searchBar = this.textInputModal.modal.querySelector('.vocab-text-input-search');
        if (searchBar) {
          searchBar.classList.add('hidden');
        }
        if (this.textInputModal.proceedBtn) {
          this.textInputModal.proceedBtn.classList.add('hidden');
        }
        
        // Add empty class back to content container
        const contentContainer = this.textInputModal.modal.querySelector('.vocab-text-input-content');
        if (contentContainer) {
          contentContainer.classList.add('empty');
        }
      }, 300);
    }
  },

  /**
   * Attach event listeners to text input modal
   */
  attachTextInputModalListeners() {
    const overlay = this.textInputModal.overlay;
    const modal = this.textInputModal.modal;
    const closeBtn = this.textInputModal.closeBtn;
    const proceedBtn = this.textInputModal.proceedBtn;
    const textarea = this.textInputModal.textarea;
    
    if (!overlay || !modal || !closeBtn || !proceedBtn || !textarea) {
      console.error('Text input modal: Missing required elements for event listeners');
      return;
    }
    
    // Close modal events
    closeBtn.addEventListener('click', () => this.hideTextInputModal());
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        this.hideTextInputModal();
      }
    });
    
    // Update border radius when content changes and toggle visibility of proceed button
    textarea.addEventListener('input', () => {
      this.updateTextareaBorderRadius(textarea);
      
      // Show/hide proceed button based on whether there's text
      const hasText = textarea.textContent.trim().length > 0;
      const proceedBtn = this.textInputModal.proceedBtn;
      const contentContainer = this.textInputModal.modal.querySelector('.vocab-text-input-content');
      
      if (hasText) {
        proceedBtn.classList.remove('hidden');
        contentContainer.classList.remove('empty');
      } else {
        proceedBtn.classList.add('hidden');
        contentContainer.classList.add('empty');
      }
    });
    
    // Update border radius on resize
    textarea.addEventListener('resize', () => {
      this.updateTextareaBorderRadius(textarea);
    });
    
    // Initial border radius check
    setTimeout(() => {
      this.updateTextareaBorderRadius(textarea);
    }, 100);
    
    // Proceed button event
    proceedBtn.addEventListener('click', () => {
      const textContent = textarea.textContent.trim();
      if (textContent) {
        this.handleTextProceed(textContent);
      }
    });
    
    // Enter key to proceed (Ctrl+Enter for contenteditable)
    textarea.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.ctrlKey) {
        e.preventDefault();
        const textContent = textarea.textContent.trim();
        if (textContent) {
          this.handleTextProceed(textContent);
        }
      }
    });
  },


  /**
   * Show search preview with highlighted matches for textarea
   */
  showTextSearchPreview(textarea, text, searchTerm) {
    // Remove existing preview if any
    this.hideTextSearchPreview();
    
    // Create preview overlay
    const preview = document.createElement('div');
    preview.className = 'vocab-text-search-preview';
    preview.style.cssText = `
      position: fixed;
      background: white;
      border: 2px solid #FFE066;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      max-width: 400px;
      max-height: 200px;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.4;
      font-family: inherit;
    `;
    
    // Create highlighted content
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gim');
    const highlightedContent = text.replace(regex, '<span style="background: linear-gradient(120deg, #FFE066 0%, #FFD700 100%); padding: 2px 4px; border-radius: 3px; font-weight: 600; color: #333;">$1</span>');
    
    // Count matches
    const matches = text.match(regex);
    const matchCount = matches ? matches.length : 0;
    
    preview.innerHTML = `
      <div style="font-weight: 600; margin-bottom: 8px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 4px;">
        Search Results: ${matchCount} match${matchCount !== 1 ? 'es' : ''} found
      </div>
      <div style="white-space: pre-wrap;">${highlightedContent}</div>
    `;
    
    // Position relative to textarea
    const rect = textarea.getBoundingClientRect();
    preview.style.top = (rect.top + rect.height + 10) + 'px';
    preview.style.left = Math.max(10, rect.left) + 'px';
    
    document.body.appendChild(preview);
    
    // Store reference for cleanup
    this.textSearchPreview = preview;
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      this.hideTextSearchPreview();
    }, 5000);
  },

  /**
   * Hide text search preview overlay
   */
  hideTextSearchPreview() {
    if (this.textSearchPreview) {
      this.textSearchPreview.remove();
      this.textSearchPreview = null;
    }
  },

  /**
   * Scroll to the first text match in textarea
   */
  scrollToTextMatch(textarea, searchTerm) {
    const text = textarea.value;
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gim');
    const match = regex.exec(text);
    
    if (match) {
      const matchIndex = match.index;
      
      // Calculate line number and position
      const textBeforeMatch = text.substring(0, matchIndex);
      const lines = textBeforeMatch.split('\n');
      const lineNumber = lines.length - 1;
      
      // Scroll to the line containing the match
      const lineHeight = parseInt(getComputedStyle(textarea).lineHeight) || 20;
      const scrollTop = lineNumber * lineHeight;
      
      textarea.scrollTop = Math.max(0, scrollTop - textarea.clientHeight / 2);
      
      // Don't focus the textarea - this causes cursor to jump from search input
    }
  },

  /**
   * Update textarea border radius based on scrollbar presence
   */
  updateTextareaBorderRadius(textarea) {
    if (!textarea) return;
    
    // Check if scrollbar is present
    const hasScrollbar = textarea.scrollHeight > textarea.clientHeight;
    
    if (hasScrollbar) {
      // Scrollbar present - make top-right and bottom-right corners square
      textarea.style.borderRadius = '20px 0 0 20px';
    } else {
      // No scrollbar - keep all corners rounded
      textarea.style.borderRadius = '20px';
    }
  },

  /**
   * Handle text proceed button click
   */
  handleTextProceed(textContent) {
    console.log('[ButtonPanel] Processing text content, length:', textContent.length);
    
    // Hide the text input modal
    this.hideTextInputModal();
    
    // Text content processing removed - custom content modal functionality removed
    console.log('[ButtonPanel] Text content processing disabled - custom content modal removed');
  },

  /**
   * Show the button panel
   */
  show() {
    if (this.panelContainer) {
      this.panelContainer.style.display = 'block';
      // Ensure left-side positioning if no custom position is set
      if (!this.panelContainer.style.left || this.panelContainer.style.left === '') {
        this.panelContainer.style.left = '0';
        this.panelContainer.style.right = 'auto';
      }
      // Add visible class for initial slide-in animation
      this.panelContainer.classList.add('visible');
      
      // Get the wrapper container and trigger pop-in animation
      const wrapperContainer = this.panelContainer.querySelector('.vocab-wrapper-container');
      if (wrapperContainer) {
        // Remove any previous animation classes
        wrapperContainer.classList.remove('pop-out', 'pop-in');
        // Force reflow to ensure class removal is processed
        void wrapperContainer.offsetHeight;
        // Add pop-in animation class
        wrapperContainer.classList.add('pop-in');
        // Remove animation class after animation completes
        setTimeout(() => {
          wrapperContainer.classList.remove('pop-in');
        }, 500);
      }
      
      console.log('[ButtonPanel] Panel shown at left:', this.panelContainer.style.left);
    }
  },

  /**
   * Hide the button panel
   * @param {boolean} immediate - If true, hide immediately without animation (used when disabling extension)
   */
  hide(immediate = false) {
    if (this.panelContainer) {
      if (immediate) {
        // Hide immediately without animation (when extension is disabled)
        this.panelContainer.style.display = 'none';
        const wrapperContainer = this.panelContainer.querySelector('.vocab-wrapper-container');
        if (wrapperContainer) {
          wrapperContainer.classList.remove('pop-in', 'pop-out');
        }
        console.log('[ButtonPanel] Panel hidden immediately (extension disabled)');
        return;
      }
      
      // Get the wrapper container and trigger pop-out animation
      const wrapperContainer = this.panelContainer.querySelector('.vocab-wrapper-container');
      if (wrapperContainer) {
        // Remove any previous animation classes
        wrapperContainer.classList.remove('pop-in', 'pop-out');
        // Force reflow to ensure class removal is processed
        void wrapperContainer.offsetHeight;
        // Add pop-out animation class
        wrapperContainer.classList.add('pop-out');
        
        // Wait for animation to complete before hiding
        setTimeout(() => {
          this.panelContainer.style.display = 'none';
          wrapperContainer.classList.remove('pop-out');
          console.log('[ButtonPanel] Panel hidden');
        }, 300); // Match animation duration
      } else {
        // Fallback if wrapper container not found
        this.panelContainer.style.display = 'none';
        console.log('[ButtonPanel] Panel hidden');
      }
    }
  },

  /**
   * Remove the button panel from DOM
   */
  destroy() {
    if (this.panelContainer) {
      this.panelContainer.remove();
      this.panelContainer = null;
    }
  },

  /**
   * Smoothly show a button with animation
   */
  showButtonSmooth(button) {
    if (!button) return;
    
    if (button.classList.contains('hidden')) {
      button.classList.remove('hidden');
      button.classList.add('showing');
      
      // Remove showing class after animation (400ms to match animation duration)
      setTimeout(() => {
        button.classList.remove('showing');
      }, 400);
    }
  },

  /**
   * Smoothly hide a button with animation
   */
  hideButtonSmooth(button) {
    if (!button) return;
    
    if (!button.classList.contains('hidden')) {
      button.classList.add('hiding');
      
      // Wait for animation to complete, then hide (350ms to match animation duration)
      setTimeout(() => {
        button.classList.remove('hiding');
        button.classList.add('hidden');
      }, 350);
    }
  },

  /**
   * Update button states based on state variables
   */
  updateButtonStates() {
    // Hide upper button group since it's now empty
    if (this.upperButtonGroup) {
      this.upperButtonGroup.classList.remove('visible');
    }

    // Update enabled/disabled state of magic meaning button
    const magicMeaningBtn = document.getElementById('magic-meaning');
    if (magicMeaningBtn) {
      const wasDisabled = magicMeaningBtn.classList.contains('disabled');
      
      if (this.state.isMagicMeaningEnabled) {
        magicMeaningBtn.classList.remove('disabled');
        magicMeaningBtn.disabled = false; // Remove disabled attribute
      } else {
        magicMeaningBtn.classList.add('disabled');
        magicMeaningBtn.disabled = true; // Add disabled attribute
      }
    }

    // Update visibility of Ask button with smooth animation
    const askBtn = document.getElementById('ask');
    if (askBtn) {
      if (this.state.showAsk) {
        this.showButtonSmooth(askBtn);
      } else {
        this.hideButtonSmooth(askBtn);
      }
    }
  },


  /**
   * Update state and refresh button states
   * @param {Object} newState - Partial state object to update
   */
  updateState(newState) {
    this.state = { ...this.state, ...newState };
    this.updateButtonStates();
    console.log('Button panel state updated:', this.state);
  },
  
  /**
   * Update button states based on selections
   */
  updateButtonStatesFromSelections() {
    const hasWords = WordSelector.selectedWords.size > 0;
    const hasTexts = TextSelector.selectedTexts.size > 0;
    const hasExactlyOneText = TextSelector.selectedTexts.size === 1;
    
    // Get current context
    const context = this.getCurrentContentContext();
    console.log('[ButtonPanel] Current context for button states:', context);
    
    // Check for meanings in current context only
    const hasAskedTextsInContext = Array.from(TextSelector.askedTexts.keys()).some(textKey => 
      this.isTextKeyInCurrentContext(textKey, context)
    );
    const hasSimplifiedTextsInContext = Array.from(TextSelector.simplifiedTexts.keys()).some(textKey => 
      this.isTextKeyInCurrentContext(textKey, context)
    );
    const hasExplainedWordsInContext = Array.from(WordSelector.explainedWords.keys()).some(word => 
      this.isWordInCurrentContext(word, context)
    );
    
    // Debug logging
    console.log('[ButtonPanel] Button state checks:', {
      context: context.type,
      hasWords,
      hasTexts,
      hasAskedTextsInContext,
      hasSimplifiedTextsInContext,
      hasExplainedWordsInContext,
      totalAskedTexts: TextSelector.askedTexts.size,
      totalSimplifiedTexts: TextSelector.simplifiedTexts.size,
      totalExplainedWords: WordSelector.explainedWords.size,
      askedTextKeys: Array.from(TextSelector.askedTexts.keys()),
      simplifiedTextKeys: Array.from(TextSelector.simplifiedTexts.keys()),
      explainedWordKeys: Array.from(WordSelector.explainedWords.keys())
    });
    
    // Legacy global checks (for backward compatibility)
    const hasAskedTexts = TextSelector.askedTexts.size > 0;
    const hasSimplifiedTexts = TextSelector.simplifiedTexts.size > 0;
    const hasExplainedWords = WordSelector.explainedWords.size > 0;
    
    console.log('[ButtonPanel] Updating button states:', {
      context: context.type,
      hasWords,
      hasTexts,
      hasAskedTextsInContext,
      hasSimplifiedTextsInContext,
      hasExplainedWordsInContext
    });
    
    
    // Enable "Magic meaning" if there are any words or texts selected
    this.setMagicMeaningEnabled(hasWords || hasTexts);
    
    // Show "Ask" only if exactly one text is selected AND custom content modal is not open
    const isCustomModalOpen = this.isCustomContentModalOpen();
    this.setAskVisible(hasExactlyOneText && !isCustomModalOpen);
  },



  /**
   * Set enabled state of Magic meaning button
   * @param {boolean} enabled - Whether to enable the button
   */
  setMagicMeaningEnabled(enabled) {
    this.updateState({ isMagicMeaningEnabled: enabled });
  },

  /**
   * Set visibility of Ask button
   * @param {boolean} show - Whether to show the button
   */
  setAskVisible(show) {
    this.updateState({ showAsk: show });
  },

  /**
   * Show notification banner at top right corner
   * @param {string} message - Message to display
   * @param {string} type - Type of notification ('success', 'error', 'info')
   */
  showNotification(message, type = 'info') {
    console.log('[ButtonPanel] ===== SHOWING NOTIFICATION =====');
    console.log('[ButtonPanel] Message:', message);
    console.log('[ButtonPanel] Type:', type);
    
    // Check if notification already exists
    const existingNotification = document.getElementById('vocab-button-panel-notification');
    if (existingNotification) {
      existingNotification.remove();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.id = 'vocab-button-panel-notification';
    notification.className = `vocab-notification vocab-notification-${type}`;
    
    // Create close button
    const closeBtn = document.createElement('button');
    closeBtn.className = 'vocab-notification-close';
    // Use red color for error type, otherwise use the default from CSS
    const strokeColor = type === 'error' ? '#dc2626' : '#9527F5';
    closeBtn.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M9 3L3 9M3 3l6 6" stroke="${strokeColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    
    // Close button click handler
    closeBtn.addEventListener('click', () => {
      notification.classList.remove('visible');
      setTimeout(() => {
        notification.remove();
      }, 300);
    });
    
    // Create message text
    const messageText = document.createElement('span');
    messageText.className = 'vocab-notification-message';
    messageText.textContent = message;
    
    // Assemble notification
    notification.appendChild(closeBtn);
    notification.appendChild(messageText);
    
    // Add to document
    document.body.appendChild(notification);
    
    // Show with animation
    setTimeout(() => {
      notification.classList.add('visible');
    }, 100);
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.classList.remove('visible');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }
    }, 5000);
    
    console.log('[ButtonPanel] Notification displayed successfully');
  },

  /**
   * Handle PDF file upload and processing
   * @param {File} file - The PDF file to process
   */
  async handlePDFUpload(file) {
    console.log('[ButtonPanel] ===== PDF UPLOAD PROCESSING STARTED =====');
    console.log('[ButtonPanel] Processing file:', file.name);
    
    try {
      console.log('[ButtonPanel] Creating FormData for API call...');
      // Create FormData for file upload
      const formData = new FormData();
      formData.append('file', file);
      
      console.log('[ButtonPanel] Making API call to:', ApiConfig.getUrl(ApiConfig.ENDPOINTS.PDF_TO_TEXT));
      
      // Retry logic wrapper
      let retryCount = 0;
      const maxRetries = 1; // Only retry once to avoid infinite loops
      
      const makeRequest = async () => {
        // Get fresh headers for each request attempt (token may have been refreshed)
        const currentHeaders = {
          'Accept': 'application/json',
          ...(await ApiService.getUnauthenticatedUserIdHeader())
        };
        
        // Add Authorization header if access token is available
        await ApiService.addAuthorizationHeader(currentHeaders);
        
        return await fetch(ApiConfig.getUrl(ApiConfig.ENDPOINTS.PDF_TO_TEXT), {
          method: 'POST',
          body: formData,
          headers: currentHeaders,
          mode: 'cors',
          credentials: 'include'
        });
      };
      
      let response = await makeRequest();
      
      // Store X-Unauthenticated-User-Id from response header
      await ApiService.storeUnauthenticatedUserId(response);
      
      console.log('[ButtonPanel] API response received, status:', response.status);
      
      if (!response.ok) {
        // Clone response for error handling (response body can only be read once)
        const responseClone = response.clone();
        const errorInfo = await ApiService.handleApiError(responseClone, 'PDF_TO_TEXT');
        
        // Check if token was refreshed and we should retry
        if (errorInfo.errorCode === 'TOKEN_REFRESHED' && errorInfo.shouldRetry && retryCount < maxRetries) {
          console.log('[ButtonPanel] Token refreshed, retrying PDF upload request (attempt', retryCount + 1, ')');
          retryCount++;
          
          // Retry the request with the new token
          response = await makeRequest();
          await ApiService.storeUnauthenticatedUserId(response);
          
          // Check if retry also failed
          if (!response.ok) {
            const retryResponseClone = response.clone();
            const retryErrorInfo = await ApiService.handleApiError(retryResponseClone, 'PDF_TO_TEXT');
            
            if (retryErrorInfo.errorCode === 'LOGIN_REQUIRED') {
              throw new Error(retryErrorInfo.message || 'Please sign in to continue');
            } else {
              throw new Error(retryErrorInfo.message || `HTTP error! status: ${response.status}`);
            }
          }
        } else {
          if (errorInfo.errorCode === 'LOGIN_REQUIRED') {
            throw new Error(errorInfo.message || 'Please sign in to continue');
          } else {
            throw new Error(errorInfo.message || `HTTP error! status: ${response.status}`);
          }
        }
      }
      
      const data = await response.json();
      console.log('[ButtonPanel] ===== API SUCCESS =====');
      console.log('[ButtonPanel] Response data:', data);
      console.log('[ButtonPanel] Text content length:', data.text ? data.text.length : 'No text');
      
      // API SUCCESS: Close both processing overlay and PDF modal, then open custom content modal
      console.log('[ButtonPanel] Hiding processing overlay...');
      this.hidePDFProcessingOverlayFromModal();
      
      console.log('[ButtonPanel] Closing PDF upload modal...');
      this.hidePDFUploadModal();
      
      console.log('[ButtonPanel] Creating PDF tab and loading content...');
      await this.createPDFTabAndLoadContent(file.name, data.text);
      
      console.log('[ButtonPanel] ===== PDF UPLOAD PROCESSING COMPLETED SUCCESSFULLY =====');
      
    } catch (error) {
      console.error('[ButtonPanel] ===== API ERROR =====');
      console.error('[ButtonPanel] Error details:', error);
      
      // API ERROR: Close processing overlay, keep PDF modal open, show error banner
      console.log('[ButtonPanel] Hiding processing overlay due to error...');
      this.hidePDFProcessingOverlayFromModal();
      
      console.log('[ButtonPanel] Keeping PDF modal open and showing error notification...');
      this.showNotification('Failed to process PDF file. Please try again.', 'error');
      
      console.log('[ButtonPanel] ===== PDF UPLOAD PROCESSING FAILED =====');
    }
  },

  /**
   * Show PDF processing loading state
   */
  showPDFProcessingState() {
    console.log('[ButtonPanel] Showing PDF processing overlay');
    
    // Create processing overlay if it doesn't exist
    if (!this.topicsModal.processingOverlay) {
      this.createProcessingOverlay();
    }
    
    // Update the processing text for PDF
    const processingText = this.topicsModal.processingOverlay.querySelector('.vocab-processing-text');
    if (processingText) {
      processingText.textContent = 'Reading PDF file';
    }
    
    // Show the overlay
    this.topicsModal.processingOverlay.classList.add('visible');
  },

  /**
   * Hide PDF processing loading state
   */
  hidePDFProcessingState() {
    console.log('[ButtonPanel] Hiding PDF processing overlay');
    
    if (this.topicsModal.processingOverlay) {
      this.topicsModal.processingOverlay.classList.remove('visible');
    }
  },

  /**
   * Create PDF tab and load generated content
   * @param {string} fileName - Name of the PDF file
   * @param {string} content - Generated markdown content
   */
  async createPDFTabAndLoadContent(fileName, content) {
    console.log('[ButtonPanel] ===== CREATING PDF TAB AND LOADING CONTENT =====');
    console.log('[ButtonPanel] File name:', fileName);
    console.log('[ButtonPanel] Content length:', content ? content.length : 'No content');
    
    // Set current content type
    this.topicsModal.currentContentType = 'pdf';
    
    // Create PDF content using the new data structure
    const tabName = fileName.replace('.pdf', '');
    console.log('[ButtonPanel] Creating content with name:', tabName);
    
    const newContent = this.topicsModal.customContentModal.addContent('pdf', tabName, content, {
      fileName: fileName,
      uploadedAt: new Date().toISOString()
    });
    
    if (!newContent) {
      console.error('[ButtonPanel] ===== FAILED TO CREATE PDF CONTENT =====');
      this.showNotification('Failed to create PDF content. Please try again.', 'error');
      return;
    }

    console.log('[ButtonPanel] PDF content created successfully');
    
    // Custom content modal has been removed
    console.log('[ButtonPanel] PDF content created successfully (custom content modal removed)');
  },

  // ===================================
  // Topics Modal Functionality
  // ===================================
  
  /**
   * Topics modal state
   */
  topicsModal: {
    overlay: null,
    modal: null,
    topics: [],
    wordCount: 100,
    difficulty: 'hard',
    processingOverlay: null,
    textInputModal: null // Text input modal
  },

  /**
   * Create and show the topics modal
   * @param {boolean} clearInputs - Whether to clear inputs (true for new content, false for regeneration)
   */
  showTopicsModal(clearInputs = true) {
    console.log('[ButtonPanel] Showing topics modal, clearInputs:', clearInputs);
    
  
    // Create modal if it doesn't exist
    if (!this.topicsModal.overlay) {
      this.createTopicsModal();
      
      // Wait for DOM to be ready before showing modal using a single requestAnimationFrame
      requestAnimationFrame(() => {
        this.showModalWithAnimation();
      });
    
      // Hide the vertical button group
      this.hideVerticalButtonGroup();
    } else {
      // Modal already exists
      if (clearInputs) {
        // Clear inputs for new content
        this.clearTopicsModalInputs();
      }
      this.showModalWithAnimation();
    }
  },

  /**
   * Show modal with animation and initialize everything
   */
  showModalWithAnimation() {
    // Clear all selections when opening modal
    this.clearSelectionsOnModalOpen();
    
    // Show modal with animation
    this.topicsModal.overlay.classList.add('visible');
    this.topicsModal.modal.classList.add('visible');
    
    // Add class to body to blur webpage icons
    document.body.classList.add('vocab-topics-modal-open');
    
    // Focus on input field
    const input = this.topicsModal.modal.querySelector('.vocab-topics-input');
    if (input) {
      setTimeout(() => input.focus(), 300);
    }
    
    // Initialize plus icon state
    setTimeout(() => {
      if (this.updatePlusIconState) {
        this.updatePlusIconState();
      }
    }, 300);
    
    // Initialize topics UI state
    setTimeout(() => {
      this.updateTopicsUIState();
    }, 300);
  },

  /**
   * Hide the topics modal
   */
  hideTopicsModal() {
    console.log('[ButtonPanel] Hiding topics modal');
    
    if (this.topicsModal.overlay) {
      this.topicsModal.overlay.classList.remove('visible');
      this.topicsModal.modal.classList.remove('visible');
    }
    
    // Remove class from body to show webpage icons again
    document.body.classList.remove('vocab-topics-modal-open');
    
    // Remove blur from custom content modal if it was blurred
    if (this.topicsModal.customContentModal.overlay) {
      this.topicsModal.customContentModal.overlay.style.filter = 'none';
    }
    

    // Clear inputs on close so next open starts clean
    this.clearTopicsModalInputs();
  },

  /**
   * Create the topics modal HTML structure
   */
  createTopicsModal() {
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'vocab-topics-modal-overlay';
    overlay.id = 'vocab-topics-modal-overlay';
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'vocab-topics-modal';
    
    // Create header
    const header = document.createElement('div');
    header.className = 'vocab-topics-modal-header';
    
    const title = document.createElement('h2');
    title.className = 'vocab-topics-modal-title';
    title.textContent = 'Enter keywords or topic you want to study on';
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'vocab-topics-modal-close';
    closeBtn.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 4L4 12M4 4L12 12" stroke="#A24EFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    closeBtn.setAttribute('aria-label', 'Close modal');
    
    header.appendChild(title);
    
    // Create first container (input + generate button)
    const firstContainer = document.createElement('div');
    firstContainer.className = 'vocab-topics-first-container';
    
    // Input section (left side of first container)
    const inputSection = document.createElement('div');
    inputSection.className = 'vocab-topics-input-section';
    
    const inputContainer = document.createElement('div');
    inputContainer.className = 'vocab-topics-input-container';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'vocab-topics-input';
    input.placeholder = 'Type keywords or topic here';
    
    const searchIcon = document.createElement('div');
    searchIcon.className = 'vocab-topics-search-icon disabled';
    searchIcon.innerHTML = this.createPlusIcon();
    
    inputContainer.appendChild(input);
    inputContainer.appendChild(searchIcon);
    inputSection.appendChild(inputContainer);
    
    // Generate button (right side of first container)
    const generateBtn = document.createElement('button');
    generateBtn.className = 'vocab-topics-generate-btn hidden';
    generateBtn.textContent = 'Generate content';
    
    firstContainer.appendChild(inputSection);
    
    // Create second container (topic tags + controls)
    const secondContainer = document.createElement('div');
    secondContainer.className = 'vocab-topics-second-container hidden';
    
    // Topic tags section (left side of second container)
    const tagsSection = document.createElement('div');
    tagsSection.className = 'vocab-topics-tags-section';
    
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'vocab-topics-tags-container';
    
    const tags = document.createElement('div');
    tags.className = 'vocab-topics-tags';
    tags.id = 'vocab-topics-tags';
    
    // Tags container starts empty
    tagsContainer.appendChild(tags);
    tagsSection.appendChild(tagsContainer);
    
    // Controls section (right side of second container)
    const controlsSection = document.createElement('div');
    controlsSection.className = 'vocab-topics-controls-section';
    
    // Word count control (top of controls section)
    const wordCountGroup = document.createElement('div');
    wordCountGroup.className = 'vocab-topics-word-count-group';
    
    const wordCountLabel = document.createElement('h3');
    wordCountLabel.className = 'vocab-topics-control-label';
    wordCountLabel.textContent = 'Total Word Count';
    
    const wordCountButtons = document.createElement('div');
    wordCountButtons.className = 'vocab-topics-word-count-buttons';
    
    // Create sliding background
    const wordCountSlider = document.createElement('div');
    wordCountSlider.className = 'vocab-topics-word-count-slider';
    wordCountSlider.id = 'word-count-slider';
    
    const btn100 = document.createElement('button');
    btn100.className = 'vocab-topics-word-count-btn selected';
    btn100.textContent = '100';
    btn100.setAttribute('data-count', '100');
    
    const btn250 = document.createElement('button');
    btn250.className = 'vocab-topics-word-count-btn';
    btn250.textContent = '250';
    btn250.setAttribute('data-count', '250');
    
    const btn500 = document.createElement('button');
    btn500.className = 'vocab-topics-word-count-btn';
    btn500.textContent = '500';
    btn500.setAttribute('data-count', '500');
    
    wordCountButtons.appendChild(wordCountSlider);
    wordCountButtons.appendChild(btn100);
    wordCountButtons.appendChild(btn250);
    wordCountButtons.appendChild(btn500);
    
    wordCountGroup.appendChild(wordCountLabel);
    wordCountGroup.appendChild(wordCountButtons);
    
    // Difficulty control (bottom of controls section)
    const difficultyGroup = document.createElement('div');
    difficultyGroup.className = 'vocab-topics-difficulty-group';
    
    const difficultyLabel = document.createElement('h3');
    difficultyLabel.className = 'vocab-topics-control-label';
    difficultyLabel.textContent = 'Difficulty Level';
    
    const difficultyButtons = document.createElement('div');
    difficultyButtons.className = 'vocab-topics-difficulty-buttons';
    
    // Create sliding background
    const difficultySlider = document.createElement('div');
    difficultySlider.className = 'vocab-topics-difficulty-slider';
    difficultySlider.id = 'difficulty-slider';
    
    const easyBtn = document.createElement('button');
    easyBtn.className = 'vocab-topics-difficulty-btn easy';
    easyBtn.textContent = 'Easy';
    easyBtn.setAttribute('data-difficulty', 'easy');
    
    const mediumBtn = document.createElement('button');
    mediumBtn.className = 'vocab-topics-difficulty-btn medium';
    mediumBtn.textContent = 'Medium';
    mediumBtn.setAttribute('data-difficulty', 'medium');
    
    const hardBtn = document.createElement('button');
    hardBtn.className = 'vocab-topics-difficulty-btn hard selected';
    hardBtn.textContent = 'Hard';
    hardBtn.setAttribute('data-difficulty', 'hard');
    
    difficultyButtons.appendChild(difficultySlider);
    difficultyButtons.appendChild(easyBtn);
    difficultyButtons.appendChild(mediumBtn);
    difficultyButtons.appendChild(hardBtn);
    
    difficultyGroup.appendChild(difficultyLabel);
    difficultyGroup.appendChild(difficultyButtons);
    
    // Assemble controls section
    controlsSection.appendChild(wordCountGroup);
    controlsSection.appendChild(difficultyGroup);
    
    // Assemble second container
    secondContainer.appendChild(tagsSection);
    secondContainer.appendChild(controlsSection);
    
    // Create content container for everything except header and generate button
    const contentContainer = document.createElement('div');
    contentContainer.className = 'vocab-topics-content-container';
    
    // Add content to the container (excluding generate button)
    contentContainer.appendChild(firstContainer);
    contentContainer.appendChild(secondContainer);
    
    // Assemble modal
    modal.appendChild(header);
    modal.appendChild(contentContainer);
    modal.appendChild(generateBtn);
    modal.appendChild(closeBtn);
    
    overlay.appendChild(modal);
    
    // Add to document
    document.body.appendChild(overlay);
    
    // Store references
    this.topicsModal.overlay = overlay;
    this.topicsModal.modal = modal;
    
    // Attach event listeners
    this.attachTopicsModalListeners();
  },

  /**
   * Attach event listeners to topics modal
   */
  attachTopicsModalListeners() {
    const overlay = this.topicsModal.overlay;
    const modal = this.topicsModal.modal;
    
    const input = modal.querySelector('.vocab-topics-input');
    const closeBtn = modal.querySelector('.vocab-topics-modal-close');
    const generateBtn = modal.querySelector('.vocab-topics-generate-btn');
    const wordCountButtons = modal.querySelectorAll('.vocab-topics-word-count-btn');
    const difficultyButtons = modal.querySelectorAll('.vocab-topics-difficulty-btn');
    const plusIcon = modal.querySelector('.vocab-topics-search-icon');
    
    // Check for null elements before adding listeners
    if (!overlay || !modal || !closeBtn || !input || !generateBtn || !plusIcon) {
      console.error('Topics modal: Missing required elements for event listeners');
      return;
    }
    
    // Close modal events
    closeBtn.addEventListener('click', () => this.hideTopicsModal());
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        this.hideTopicsModal();
      }
    });
    
    // Function to add topic
    const addTopicFromInput = () => {
      const topic = input.value.trim();
      if (topic) {
        this.addTopic(topic);
        input.value = '';
        updatePlusIconState();
      }
    };
    
    // Function to update plus icon state
    const updatePlusIconState = () => {
      if (plusIcon) {
        if (input.value.trim()) {
          plusIcon.classList.remove('disabled');
        } else {
          plusIcon.classList.add('disabled');
        }
      }
    };
    
    // Store reference for external access
    this.updatePlusIconState = updatePlusIconState;
    
    // Initialize plus icon state immediately
    updatePlusIconState();
    
    // Input events - add topic on Enter
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault(); // Prevent form submission if this is in a form
        addTopicFromInput();
      }
    });
    
    // Input change events - update plus icon state
    input.addEventListener('input', () => {
      updatePlusIconState();
    });
    
    // Plus icon click event
    plusIcon.addEventListener('click', () => {
      if (!plusIcon.classList.contains('disabled')) {
        addTopicFromInput();
      }
    });
    
    // Generate button
    generateBtn.addEventListener('click', () => this.handleGenerateStory());
    
    // Word count buttons
    wordCountButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        // Don't remove selected class yet - animate first
        // Animate slider to new position
        this.animateSlider('word-count-slider', e.target);
        
        // Update word count
        this.topicsModal.wordCount = parseInt(e.target.getAttribute('data-count'));
        
        // Remove selected class from all buttons after animation starts
        wordCountButtons.forEach(b => b.classList.remove('selected'));
        
        // Add selected class to clicked button
        e.target.classList.add('selected');
      });
    });
    
    // Difficulty buttons
    difficultyButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        // Don't remove selected class yet - animate first
        // Animate slider to new position and update color
        this.animateSlider('difficulty-slider', e.target);
        this.updateDifficultySliderColor(e.target);
        
        // Update difficulty
        this.topicsModal.difficulty = e.target.getAttribute('data-difficulty');
        
        // Remove selected class from all buttons after animation starts
        difficultyButtons.forEach(b => b.classList.remove('selected'));
        
        // Add selected class to clicked button
        e.target.classList.add('selected');
      });
    });
  },

  /**
   * Add a topic to the list
   * @param {string} topic - The topic to add
   */
  addTopic(topic) {
    if (!topic || this.topicsModal.topics.includes(topic)) {
      return;
    }
    
    console.log('[ButtonPanel] Adding topic:', topic);
    
    // Add to topics array
    this.topicsModal.topics.push(topic);
    
    // Create and add tag element
    const tag = this.createTopicTag(topic);
    const tagsContainer = this.topicsModal.modal.querySelector('#vocab-topics-tags');
    tagsContainer.appendChild(tag);
    
    // Update UI state
    this.updateTopicsUIState();
  },

  /**
   * Create a topic tag element
   * @param {string} topic - The topic text
   * @returns {HTMLElement} Topic tag element
   */
  createTopicTag(topic) {
    const tag = document.createElement('div');
    tag.className = 'vocab-topics-tag';
    tag.setAttribute('data-topic', topic);
    
    const tagText = document.createElement('span');
    tagText.textContent = topic;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'vocab-topics-tag-remove';
    removeBtn.innerHTML = '×';
    removeBtn.setAttribute('aria-label', `Remove ${topic}`);
    
    tag.appendChild(tagText);
    tag.appendChild(removeBtn);
    
    // Add remove event listener
    removeBtn.addEventListener('click', () => this.removeTopic(topic));
    
    return tag;
  },

  /**
   * Remove a topic from the list
   * @param {string} topic - The topic to remove
   */
  removeTopic(topic) {
    console.log('[ButtonPanel] Removing topic:', topic);
    
    // Remove from topics array
    const index = this.topicsModal.topics.indexOf(topic);
    if (index > -1) {
      this.topicsModal.topics.splice(index, 1);
    }
    
    // Remove tag element
    const tag = this.topicsModal.modal.querySelector(`[data-topic="${topic}"]`);
    if (tag) {
      tag.remove();
    }
    
    // Update UI state
    this.updateTopicsUIState();
  },

  /**
   * Update UI state based on whether there are topics
   */
  updateTopicsUIState() {
    // Check if topics modal exists before trying to access it
    if (!this.topicsModal.modal) {
      console.log('[ButtonPanel] Topics modal does not exist, skipping updateTopicsUIState');
      return;
    }
    
    const hasTopics = this.topicsModal.topics.length > 0;
    const secondContainer = this.topicsModal.modal.querySelector('.vocab-topics-second-container');
    const generateBtn = this.topicsModal.modal.querySelector('.vocab-topics-generate-btn');
    const contentContainer = this.topicsModal.modal.querySelector('.vocab-topics-content-container');
    
    if (secondContainer) {
      if (hasTopics) {
        secondContainer.classList.remove('hidden');
        // Ensure it's visible and interactive
        secondContainer.style.display = 'flex';
        
        // Initialize sliders after container becomes visible
        setTimeout(() => {
          this.initializeSliders();
        }, 100);
      } else {
        secondContainer.classList.add('hidden');
        // Hide after animation completes
        setTimeout(() => {
          if (secondContainer.classList.contains('hidden')) {
            secondContainer.style.display = 'none';
          }
        }, 300);
      }
    }
    
    if (generateBtn) {
      if (hasTopics) {
        generateBtn.classList.remove('hidden');
        // Ensure it's visible and interactive
        generateBtn.style.display = 'block';
      } else {
        generateBtn.classList.add('hidden');
        // Hide after animation completes
        setTimeout(() => {
          if (generateBtn.classList.contains('hidden')) {
            generateBtn.style.display = 'none';
          }
        }, 300);
      }
    }
  },

  /**
   * Handle generate story button click
   */
  async handleGenerateStory() {
    console.log('[ButtonPanel] ===== GENERATE STORY STARTED =====');
    console.log('[ButtonPanel] Generating story with topics:', this.topicsModal.topics);
    console.log('[ButtonPanel] Word count:', this.topicsModal.wordCount);
    console.log('[ButtonPanel] Difficulty:', this.topicsModal.difficulty);
    console.log('[ButtonPanel] customContentModal state:', this.topicsModal.customContentModal);
    
    if (this.topicsModal.topics.length === 0) {
      alert('Please add at least one topic before generating a story.');
      return;
    }
    
    // Check if this is a regeneration
    const generateBtn = this.topicsModal.modal.querySelector('.vocab-topics-generate-btn');
    const isRegenerate = generateBtn && generateBtn.getAttribute('data-regenerate') === 'true';
    const tabId = generateBtn ? generateBtn.getAttribute('data-tab-id') : null;
    
    // Hide processing overlay
    this.hideProcessingOverlay();
    
    // Show error message - functionality removed
    alert('Story generation functionality has been removed.');
  },

  /**
   * Show processing overlay
   */
  showProcessingOverlay() {
    console.log('[ButtonPanel] Showing processing overlay');
    
    // Create processing overlay if it doesn't exist
    if (!this.topicsModal.processingOverlay) {
      this.createProcessingOverlay();
    }
    
    // Show the overlay
    this.topicsModal.processingOverlay.classList.add('visible');
  },

  /**
   * Hide processing overlay
   */
  hideProcessingOverlay() {
    console.log('[ButtonPanel] Hiding processing overlay');
    
    if (this.topicsModal.processingOverlay) {
      this.topicsModal.processingOverlay.classList.remove('visible');
    }
  },

  /**
   * Create processing overlay HTML structure
   */
  createProcessingOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'vocab-processing-overlay';
    overlay.id = 'vocab-processing-overlay';
    
    const content = document.createElement('div');
    content.className = 'vocab-processing-content';
    
    const text = document.createElement('div');
    text.className = 'vocab-processing-text';
    text.textContent = 'Generating contents on topics...';
    
    const icon = document.createElement('div');
    icon.className = 'vocab-processing-icon';
    
    content.appendChild(text);
    content.appendChild(icon);
    overlay.appendChild(content);
    
    // Add to topics modal instead of document body
    this.topicsModal.modal.appendChild(overlay);
    
    // Store reference
    this.topicsModal.processingOverlay = overlay;
  },


  /**
   * Generate tab title based on content type and metadata
   * @param {string} contentType - The content type ('pdf', 'image', 'topic')
   * @param {Object} metadata - Additional metadata for the tab
   * @returns {string} Generated tab title
   */
  generateTabTitle(contentType, metadata = {}) {
    const titleMap = {
      'pdf': () => {
        if (metadata.fileName) {
          return `PDF: ${metadata.fileName}`;
        }
        return 'PDF Content';
      },
      'image': () => {
        if (metadata.fileName) {
          return `Image: ${metadata.fileName}`;
        }
        return 'Image Content';
      },
      'topic': () => {
        // Prioritize topicName from API response
        if (metadata.topicName) {
          return metadata.topicName;
        }
        // Fallback to topics list if topicName not available
        if (metadata.topics && metadata.topics.length > 0) {
          const topicList = metadata.topics.slice(0, 3).join(', ');
          const suffix = metadata.topics.length > 3 ? '...' : '';
          return `Topics: ${topicList}${suffix}`;
        }
        return 'Topic Content';
      },
      'text': () => {
        if (metadata.inputText) {
          const words = metadata.inputText.trim().split(/\s+/);
          return words.slice(0, 3).join(' ');
        }
        return 'Text Content';
      },
      'default': () => 'Generated Content'
    };
    
    const generator = titleMap[contentType] || titleMap['default'];
    return generator();
  },

  /**
   * Clear all text and word selections when opening modals
   */
  clearSelectionsOnModalOpen() {
    console.log('[ButtonPanel] Clearing only selections due to modal opening, preserving meanings');
    
    // Clear word selections only (preserve meanings)
    if (typeof WordSelector !== 'undefined' && WordSelector.clearSelectionsOnly) {
      WordSelector.clearSelectionsOnly();
    }
    
    // Clear text selections only (preserve meanings)
    if (typeof TextSelector !== 'undefined' && TextSelector.clearSelectionsOnly) {
      TextSelector.clearSelectionsOnly();
    }
    
    // Clear any browser text selection
    if (window.getSelection) {
      window.getSelection().removeAllRanges();
    }
    
    console.log('[ButtonPanel] Selections cleared, meanings preserved');
  },

  /**
   * Update icon context attributes for existing icons
   */
  updateIconContexts() {
    // Update all existing icon wrappers with proper context
    const allIconWrappers = document.querySelectorAll('.vocab-text-icons-wrapper');
    allIconWrappers.forEach(wrapper => {
      if (!wrapper.hasAttribute('data-icon-context')) {
        const isInModal = wrapper.closest('.vocab-custom-content-modal');
        wrapper.setAttribute('data-icon-context', isInModal ? 'custom-content-modal' : 'main-webpage');
      }
    });
  },


  /**
   * Show image upload modal
   */
  showImageUploadModal() {
    console.log('[ButtonPanel] Showing image upload modal');
    
    // Create modal if it doesn't exist
    if (!this.imageUploadModal) {
      this.createImageUploadModal();
      
      // Wait for DOM to be ready before showing modal using double requestAnimationFrame
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          this.showImageModalWithAnimation();
        });
      });
    } else {
      // Modal already exists; show with animation
      this.showImageModalWithAnimation();
    }
  },

  /**
   * Show image modal with animation
   */
  showImageModalWithAnimation() {
    // Clear all selections when opening modal
    this.clearSelectionsOnModalOpen();
    
    if (this.imageUploadModal.overlay) {
      this.imageUploadModal.overlay.classList.add('visible');
    }
    if (this.imageUploadModal.modal) {
      this.imageUploadModal.modal.classList.add('visible');
    }
    
    // Add class to body to blur webpage icons
    document.body.classList.add('vocab-image-modal-open');
  },

  /**
   * Hide image upload modal
   */
  hideImageUploadModal() {
    console.log('[ButtonPanel] Hiding image upload modal');
    
    if (this.imageUploadModal && this.imageUploadModal.overlay) {
      this.imageUploadModal.overlay.classList.remove('visible');
    }
    if (this.imageUploadModal && this.imageUploadModal.modal) {
      this.imageUploadModal.modal.classList.remove('visible');
    }
    
    // Remove class from body to show webpage icons again
    document.body.classList.remove('vocab-image-modal-open');
  },

  /**
   * Create image upload modal HTML structure
   */
  createImageUploadModal() {
    console.log('[ButtonPanel] Creating image upload modal...');
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'vocab-image-upload-overlay';
    overlay.id = 'vocab-image-upload-overlay';
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'vocab-image-upload-modal';
    
    // Create modal content
    modal.innerHTML = `
      <div class="vocab-image-upload-header">
        <h2 class="vocab-image-upload-title">Upload Image containing text</h2>
        <button class="vocab-image-upload-close" id="vocab-image-upload-close">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      
      <div class="vocab-image-upload-content">
        <div class="vocab-image-upload-content-container">
          <div class="vocab-image-upload-icon">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M21 19V5C21 3.9 20.1 3 19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19ZM8.5 13.5L11 16.51L14.5 12L19 18H5L8.5 13.5Z" fill="#9527F5"/>
              <circle cx="16" cy="8" r="2" fill="#9527F5"/>
              <path d="M12 6H12.01" stroke="#9527F5" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <div class="vocab-image-upload-plus">+</div>
          </div>
          
          <div class="vocab-image-upload-instructions">
            <p class="vocab-image-upload-main-text">Drop, Upload or Paste Image file</p>
            <p class="vocab-image-upload-format-text">Supporting formats: JPG, PNG, JPEG, HEIC</p>
            <p class="vocab-image-upload-secondary-text">use Ctrl+V (Windows) / Cmd+V (Mac) to paste from clipboard.</p>
            <p class="vocab-image-upload-size-text">Maximum file size 5 MB.</p>
          </div>
          
          <button class="vocab-image-upload-browse-btn" id="vocab-image-upload-browse">
            Browse
          </button>
        </div>
        
        <input type="file" id="vocab-image-upload-input" accept="image/*" style="display: none;">
      </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // Store references
    this.imageUploadModal = {
      overlay: overlay,
      modal: modal,
      closeBtn: modal.querySelector('#vocab-image-upload-close'),
      browseBtn: modal.querySelector('#vocab-image-upload-browse'),
      fileInput: modal.querySelector('#vocab-image-upload-input')
    };
    
    // Add event listeners
    this.setupImageUploadModalEvents();
    
    console.log('[ButtonPanel] Image upload modal created successfully');
  },

  /**
   * Setup event listeners for image upload modal
   */
  setupImageUploadModalEvents() {
    const { overlay, closeBtn, browseBtn, fileInput } = this.imageUploadModal;
    const container = overlay.querySelector('.vocab-image-upload-content-container');
    
    // Close modal events
    closeBtn.addEventListener('click', () => this.hideImageUploadModal());
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        this.hideImageUploadModal();
      }
    });
    
    // Browse button click
    browseBtn.addEventListener('click', () => {
      fileInput.click();
    });
    
    // Container click to open file dialog
    container.addEventListener('click', () => {
      fileInput.click();
    });
    
    // File input change
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        this.handleImageFile(file);
      }
    });
    
    // Drag and drop functionality
    overlay.addEventListener('dragover', (e) => {
      e.preventDefault();
      overlay.classList.add('drag-over');
    });
    
    overlay.addEventListener('dragleave', (e) => {
      e.preventDefault();
      overlay.classList.remove('drag-over');
    });
    
    overlay.addEventListener('drop', (e) => {
      e.preventDefault();
      overlay.classList.remove('drag-over');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.type.startsWith('image/')) {
          this.handleImageFile(file);
        } else {
          alert('Please select an image file.');
        }
      }
    });
    
    // Paste functionality
    document.addEventListener('paste', (e) => {
      if (overlay.classList.contains('visible')) {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.startsWith('image/')) {
            const file = items[i].getAsFile();
            this.handleImageFile(file);
            break;
          }
        }
      }
    });
  },

  /**
   * Handle uploaded image file
   */
  handleImageFile(file) {
    console.log('[ButtonPanel] ===== IMAGE FILE UPLOAD STARTED =====');
    console.log('[ButtonPanel] File details:', {
      name: file.name,
      size: file.size,
      type: file.type
    });
    
    // Check file size (5MB limit)
    if (file.size > 5 * 1024 * 1024) {
      this.showNotification('File size exceeds 5MB limit. Please select a smaller image.', 'error');
      return;
    }
    
    // Check file type - support JPG, PNG, JPEG, HEIC
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/heic'];
    if (!allowedTypes.includes(file.type.toLowerCase())) {
      this.showNotification('Please select a valid image file (JPG, PNG, JPEG, HEIC).', 'error');
      return;
    }
    
    console.log('[ButtonPanel] File validation passed, starting processing...');
    this.showImageProcessingOverlayOnModal(); // Keep image modal open and show processing overlay on top
    this.handleImageUpload(file);
  },

  /**
   * Handle image upload API call
   */
  async handleImageUpload(file) {
    console.log('[ButtonPanel] ===== IMAGE UPLOAD PROCESSING STARTED =====');
    console.log('[ButtonPanel] Uploading file:', file.name);
    
    try {
      const formData = new FormData();
      formData.append('file', file);
      
      console.log('[ButtonPanel] Making API call to image-to-text endpoint...');
      
      // Retry logic wrapper
      let retryCount = 0;
      const maxRetries = 1; // Only retry once to avoid infinite loops
      
      const makeRequest = async () => {
        // Get fresh headers for each request attempt (token may have been refreshed)
        // FormData doesn't need Content-Type, browser sets it automatically
        const currentHeaders = {
          ...(await ApiService.getUnauthenticatedUserIdHeader())
        };
        
        // Add Authorization header if access token is available
        await ApiService.addAuthorizationHeader(currentHeaders);
        
        return await fetch(ApiConfig.getUrl(ApiConfig.ENDPOINTS.IMAGE_TO_TEXT), {
          method: 'POST',
          body: formData,
          headers: currentHeaders,
          mode: 'cors',
          credentials: 'include'
        });
      };
      
      let response = await makeRequest();
      
      // Store X-Unauthenticated-User-Id from response header
      await ApiService.storeUnauthenticatedUserId(response);
      
      console.log('[ButtonPanel] API response received:', response.status);
      
      if (!response.ok) {
        // Clone response for error handling (response body can only be read once)
        const responseClone = response.clone();
        const errorInfo = await ApiService.handleApiError(responseClone, 'IMAGE_TO_TEXT');
        
        // Check if token was refreshed and we should retry
        if (errorInfo.errorCode === 'TOKEN_REFRESHED' && errorInfo.shouldRetry && retryCount < maxRetries) {
          console.log('[ButtonPanel] Token refreshed, retrying image upload request (attempt', retryCount + 1, ')');
          retryCount++;
          
          // Retry the request with the new token
          response = await makeRequest();
          await ApiService.storeUnauthenticatedUserId(response);
          
          // Check if retry also failed
          if (!response.ok) {
            const retryResponseClone = response.clone();
            const retryErrorInfo = await ApiService.handleApiError(retryResponseClone, 'IMAGE_TO_TEXT');
            
            if (retryErrorInfo.errorCode === 'LOGIN_REQUIRED') {
              throw new Error(retryErrorInfo.message || 'Please sign in to continue');
            } else {
              throw new Error(retryErrorInfo.message || `HTTP error! status: ${response.status}`);
            }
          }
        } else {
          if (errorInfo.errorCode === 'LOGIN_REQUIRED') {
            throw new Error(errorInfo.message || 'Please sign in to continue');
          } else {
            throw new Error(errorInfo.message || `HTTP error! status: ${response.status}`);
          }
        }
      }
      
      const data = await response.json();
      console.log('[ButtonPanel] ===== API SUCCESS =====');
      console.log('[ButtonPanel] Response data:', data);
      
      this.hideImageProcessingOverlayFromModal();
      this.hideImageUploadModal(); // Close image upload modal on success
      await this.createImageTabAndLoadContent(data.topicName, data.text);
      
      console.log('[ButtonPanel] ===== IMAGE UPLOAD PROCESSING COMPLETED SUCCESSFULLY =====');
      
    } catch (error) {
      console.error('[ButtonPanel] ===== API ERROR =====');
      console.error('[ButtonPanel] Error details:', error);
      
      this.hideImageProcessingOverlayFromModal();
      // Image modal remains open
      this.showNotification('Failed to process image file. Please try again.', 'error');
    }
  },

  /**
   * Create image tab and load content
   */
  async createImageTabAndLoadContent(topicName, content) {
    console.log('[ButtonPanel] ===== CREATING IMAGE TAB AND LOADING CONTENT =====');
    console.log('[ButtonPanel] Topic name:', topicName);
    console.log('[ButtonPanel] Content length:', content.length);
    
    // Ensure modal is initialized
    if (!this.topicsModal || !this.topicsModal.customContentModal) {
      console.error('[ButtonPanel] Topics modal not initialized');
      this.showNotification('Modal not initialized. Please try again.', 'error');
      return;
    }
    
    // Set current content type
    this.topicsModal.currentContentType = 'image';
    
    // Custom content modal has been removed
    console.log('[ButtonPanel] Image content processed (custom content modal removed)');
  },

  /**
   * Show image processing overlay on modal
   */
  showImageProcessingOverlayOnModal() {
    console.log('[ButtonPanel] ===== SHOWING IMAGE PROCESSING OVERLAY =====');
    
    if (!this.imageUploadModal || !this.imageUploadModal.modal) {
      console.error('[ButtonPanel] Image upload modal not found');
      return;
    }
    
    // Create processing overlay if it doesn't exist
    if (!this.imageProcessingOverlay) {
      this.createImageProcessingOverlay();
    }
    
    // Show the overlay
    if (this.imageProcessingOverlay) {
      this.imageProcessingOverlay.classList.add('visible');
      console.log('[ButtonPanel] Image processing overlay shown');
    }
  },

  /**
   * Hide image processing overlay from modal
   */
  hideImageProcessingOverlayFromModal() {
    console.log('[ButtonPanel] ===== HIDING IMAGE PROCESSING OVERLAY =====');
    
    if (this.imageProcessingOverlay) {
      this.imageProcessingOverlay.classList.remove('visible');
      console.log('[ButtonPanel] Image processing overlay hidden');
    }
  },

  /**
   * Create image processing overlay
   */
  createImageProcessingOverlay() {
    console.log('[ButtonPanel] ===== CREATING IMAGE PROCESSING OVERLAY =====');
    
    if (!this.imageUploadModal || !this.imageUploadModal.modal) {
      console.error('[ButtonPanel] Image upload modal not found for overlay creation');
      return;
    }
    
    // Create overlay element
    const overlay = document.createElement('div');
    overlay.className = 'vocab-image-processing-overlay';
    overlay.id = 'vocab-image-processing-overlay';
    
    // Create processing content
    overlay.innerHTML = `
      <div class="vocab-image-processing-content">
        <div class="vocab-image-processing-text">
          <p class="vocab-image-processing-main">Reading image file</p>
          <p class="vocab-image-processing-sub">Extracting text from image</p>
        </div>
        <div class="vocab-processing-icon"></div>
      </div>
    `;
    
    // Append to image upload modal
    this.imageUploadModal.modal.appendChild(overlay);
    
    // Store reference
    this.imageProcessingOverlay = overlay;
    
    console.log('[ButtonPanel] Image processing overlay created successfully');
  },

  /**
   * Hide image upload modal for processing (without showing custom content button)
   */
  hideImageUploadModalForProcessing() {
    console.log('[ButtonPanel] Hiding image upload modal for processing');
    
    if (this.imageUploadModal && this.imageUploadModal.overlay) {
      this.imageUploadModal.overlay.classList.remove('visible');
    }
    if (this.imageUploadModal && this.imageUploadModal.modal) {
      this.imageUploadModal.modal.classList.remove('visible');
    }
    
    // Don't show the custom content button - we want to keep the custom content modal visible
  },

  /**
   * Show PDF upload modal
   */
  showPDFUploadModal() {
    console.log('[ButtonPanel] Showing PDF upload modal');
    
    // Create modal if it doesn't exist
    if (!this.pdfUploadModal) {
      this.createPDFUploadModal();
      
      // Wait for DOM to be ready before showing modal using double requestAnimationFrame
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          this.showPDFModalWithAnimation();
        });
      });
    } else {
      // Modal already exists; show with animation
      this.showPDFModalWithAnimation();
    }
  },

  /**
   * Show PDF modal with animation
   */
  showPDFModalWithAnimation() {
    // Clear all selections when opening modal
    this.clearSelectionsOnModalOpen();
    
    if (this.pdfUploadModal.overlay) {
      this.pdfUploadModal.overlay.classList.add('visible');
    }
    if (this.pdfUploadModal.modal) {
      this.pdfUploadModal.modal.classList.add('visible');
    }
    
    // Add class to body to blur webpage icons
    document.body.classList.add('vocab-pdf-modal-open');
  },

  /**
   * Show processing overlay on top of PDF modal
   */
  showPDFProcessingOverlayOnModal() {
    console.log('[ButtonPanel] ===== SHOWING PDF PROCESSING OVERLAY =====');
    
    // Create processing overlay if it doesn't exist
    if (!this.pdfUploadModal.processingOverlay) {
      this.createPDFProcessingOverlay();
    }
    
    // Update the processing text for PDF
    const processingText = this.pdfUploadModal.processingOverlay.querySelector('.vocab-processing-text');
    if (processingText) {
      processingText.textContent = 'Reading PDF file';
    }
    
    // Show the overlay on top of PDF modal
    this.pdfUploadModal.processingOverlay.classList.add('visible');
    console.log('[ButtonPanel] PDF processing overlay is now visible');
  },

  /**
   * Hide processing overlay from PDF modal
   */
  hidePDFProcessingOverlayFromModal() {
    console.log('[ButtonPanel] ===== HIDING PDF PROCESSING OVERLAY =====');
    
    if (this.pdfUploadModal.processingOverlay) {
      this.pdfUploadModal.processingOverlay.classList.remove('visible');
      console.log('[ButtonPanel] PDF processing overlay hidden');
    }
  },

  /**
   * Create processing overlay for PDF modal
   */
  createPDFProcessingOverlay() {
    console.log('[ButtonPanel] ===== CREATING PDF PROCESSING OVERLAY =====');
    
    const overlay = document.createElement('div');
    overlay.className = 'vocab-processing-overlay';
    overlay.id = 'vocab-pdf-processing-overlay';
    
    const content = document.createElement('div');
    content.className = 'vocab-processing-content';
    
    const text = document.createElement('div');
    text.className = 'vocab-processing-text';
    text.textContent = 'Reading PDF file';
    
    const icon = document.createElement('div');
    icon.className = 'vocab-processing-icon';
    
    content.appendChild(text);
    content.appendChild(icon);
    overlay.appendChild(content);
    
    // Add to PDF modal instead of document body
    this.pdfUploadModal.modal.appendChild(overlay);
    
    // Store reference
    this.pdfUploadModal.processingOverlay = overlay;
    
    console.log('[ButtonPanel] PDF processing overlay created and added to PDF modal');
  },

  /**
   * Hide PDF upload modal for processing (without showing custom content button)
   */
  hidePDFUploadModalForProcessing() {
    console.log('[ButtonPanel] Hiding PDF upload modal for processing');
    
    if (this.pdfUploadModal && this.pdfUploadModal.overlay) {
      this.pdfUploadModal.overlay.classList.remove('visible');
    }
    if (this.pdfUploadModal && this.pdfUploadModal.modal) {
      this.pdfUploadModal.modal.classList.remove('visible');
    }
    
    // Reset the file input to allow re-uploading the same file
    if (this.pdfUploadModal && this.pdfUploadModal.fileInput) {
      this.pdfUploadModal.fileInput.value = '';
      console.log('[ButtonPanel] PDF file input reset for processing');
    }
    
    // Remove class from body to show webpage icons again
    document.body.classList.remove('vocab-pdf-modal-open');
    
    // Don't show the custom content button - we want to keep the custom content modal visible
  },

  /**
   * Hide PDF upload modal
   */
  hidePDFUploadModal() {
    console.log('[ButtonPanel] Hiding PDF upload modal');
    
    if (this.pdfUploadModal && this.pdfUploadModal.overlay) {
      this.pdfUploadModal.overlay.classList.remove('visible');
    }
    if (this.pdfUploadModal && this.pdfUploadModal.modal) {
      this.pdfUploadModal.modal.classList.remove('visible');
    }
    
    // Reset the file input to allow re-uploading the same file
    if (this.pdfUploadModal && this.pdfUploadModal.fileInput) {
      this.pdfUploadModal.fileInput.value = '';
      console.log('[ButtonPanel] PDF file input reset');
    }
    
    // Remove class from body to show webpage icons again
    document.body.classList.remove('vocab-pdf-modal-open');
  },

  /**
   * Create PDF upload modal HTML structure
   */
  createPDFUploadModal() {
    console.log('[ButtonPanel] Creating PDF upload modal...');
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'vocab-pdf-upload-overlay';
    overlay.id = 'vocab-pdf-upload-overlay';
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'vocab-pdf-upload-modal';
    
    // Create modal content
    modal.innerHTML = `
      <div class="vocab-pdf-upload-header">
        <h2 class="vocab-pdf-upload-title">Upload PDF containing text</h2>
        <button class="vocab-pdf-upload-close" id="vocab-pdf-upload-close">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      
      <div class="vocab-pdf-upload-content">
        <div class="vocab-pdf-upload-content-container">
          <div class="vocab-pdf-upload-icon">
            <svg width="80" height="80" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <!-- Main document rectangle -->
              <rect x="4" y="3" width="16" height="20" rx="2" fill="#9527F5"/>
              <!-- Folded corner -->
              <path d="M16 3L20 7V3H16Z" fill="#7A3FD1"/>
              <!-- PDF text in the center -->
              <text x="12" y="14" font-family="Arial, sans-serif" font-size="4" font-weight="bold" fill="white" text-anchor="middle">PDF</text>
              <!-- Upload arrow on the right side pointing upward -->
              <path d="M18 16L16 18M18 16L20 18M18 16V20" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          
          <div class="vocab-pdf-upload-instructions">
            <p class="vocab-pdf-upload-main-text">Drop, Upload or Paste PDF file</p>
            <p class="vocab-pdf-upload-secondary-text">use Ctrl+V (Windows) / Cmd+V (Mac) to paste from clipboard.</p>
            <p class="vocab-pdf-upload-size-text">Maximum file size 5 MB.</p>
          </div>
          
          <button class="vocab-pdf-upload-browse-btn" id="vocab-pdf-upload-browse">
            Browse
          </button>
        </div>
        
        <input type="file" id="vocab-pdf-upload-input" accept=".pdf" style="display: none;">
      </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // Store references
    this.pdfUploadModal = {
      overlay: overlay,
      modal: modal,
      closeBtn: modal.querySelector('#vocab-pdf-upload-close'),
      browseBtn: modal.querySelector('#vocab-pdf-upload-browse'),
      fileInput: modal.querySelector('#vocab-pdf-upload-input')
    };
    
    // Add event listeners
    this.setupPDFUploadModalEvents();
    
    console.log('[ButtonPanel] PDF upload modal created successfully');
  },

  /**
   * Setup event listeners for PDF upload modal
   */
  setupPDFUploadModalEvents() {
    const { overlay, closeBtn, browseBtn, fileInput } = this.pdfUploadModal;
    const container = overlay.querySelector('.vocab-pdf-upload-content-container');
    
    // Close modal events
    closeBtn.addEventListener('click', () => this.hidePDFUploadModal());
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        this.hidePDFUploadModal();
      }
    });
    
    // Browse button click
    browseBtn.addEventListener('click', () => {
      fileInput.click();
    });
    
    // Container click to open file dialog
    container.addEventListener('click', () => {
      fileInput.click();
    });
    
    // File input change
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        this.handlePDFFile(file);
      }
    });
    
    // Drag and drop functionality
    overlay.addEventListener('dragover', (e) => {
      e.preventDefault();
      overlay.classList.add('drag-over');
    });
    
    overlay.addEventListener('dragleave', (e) => {
      e.preventDefault();
      overlay.classList.remove('drag-over');
    });
    
    overlay.addEventListener('drop', (e) => {
      e.preventDefault();
      overlay.classList.remove('drag-over');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.type === 'application/pdf') {
          this.handlePDFFile(file);
        } else {
          alert('Please select a PDF file.');
        }
      }
    });
    
    // Paste functionality
    document.addEventListener('paste', (e) => {
      if (overlay.classList.contains('visible')) {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type === 'application/pdf') {
            const file = items[i].getAsFile();
            this.handlePDFFile(file);
            break;
          }
        }
      }
    });
  },

  /**
   * Handle uploaded PDF file
   */
  handlePDFFile(file) {
    console.log('[ButtonPanel] ===== PDF FILE UPLOAD STARTED =====');
    console.log('[ButtonPanel] File details:', {
      name: file.name,
      size: file.size,
      type: file.type
    });
    
    // Check file size (5MB limit)
    if (file.size > 5 * 1024 * 1024) {
      console.log('[ButtonPanel] File size exceeds limit:', file.size);
      alert('File size exceeds 5MB limit. Please select a smaller PDF.');
      return;
    }
    
    // Check file type
    if (file.type !== 'application/pdf') {
      console.log('[ButtonPanel] Invalid file type:', file.type);
      alert('Please select a valid PDF file.');
      return;
    }
    
    console.log('[ButtonPanel] File validation passed, starting processing...');
    
    // Keep PDF modal open and show processing overlay on top
    this.showPDFProcessingOverlayOnModal();
    
    // Process the PDF file using the existing handlePDFUpload method
    this.handlePDFUpload(file);
  },


  /**
   * Show topics modal for creating a new tab
   */
  showTopicsModalForNewTab() {
    console.log('[ButtonPanel] Showing topics modal for new tab');
    
    // Blur the custom content modal background
    if (this.topicsModal.customContentModal.overlay) {
      this.topicsModal.customContentModal.overlay.style.filter = 'blur(2px)';
    }
    
    // Clear existing topics and inputs
    this.topicsModal.topics = [];
    this.topicsModal.wordCount = 100;
    this.topicsModal.difficulty = 'hard';
    
    // Clear topics tags if modal exists
    if (this.topicsModal.modal) {
      const tagsContainer = this.topicsModal.modal.querySelector('#vocab-topics-tags');
      if (tagsContainer) {
        tagsContainer.innerHTML = '';
      }
      
      // Clear input field
      const input = this.topicsModal.modal.querySelector('.vocab-topics-input');
      if (input) {
        input.value = '';
      }
      
      // Reset word count and difficulty selections
      const wordCountButtons = this.topicsModal.modal.querySelectorAll('.vocab-topics-word-count-btn');
      wordCountButtons.forEach(btn => btn.classList.remove('selected'));
      const wordCountBtn100 = this.topicsModal.modal.querySelector('[data-count="100"]');
      if (wordCountBtn100) {
        wordCountBtn100.classList.add('selected');
      }
      
      const difficultyButtons = this.topicsModal.modal.querySelectorAll('.vocab-topics-difficulty-btn');
      difficultyButtons.forEach(btn => btn.classList.remove('selected'));
      const hardBtn = this.topicsModal.modal.querySelector('[data-difficulty="hard"]');
      if (hardBtn) {
        hardBtn.classList.add('selected');
      }
      
      // Update UI state
      this.updateTopicsUIState();
    }
    
    // Show the topics modal
    this.showTopicsModal();
  },

  /**
   * Show topics modal for regenerating content
   */
  showTopicsModalForRegenerate() {
    console.log('[ButtonPanel] Showing topics modal for regenerate');
    
    // Blur the custom content modal background
    if (this.topicsModal.customContentModal.overlay) {
      this.topicsModal.customContentModal.overlay.style.filter = 'blur(2px)';
    }
    
    // Get current active tab data using new data structure
    const activeTabId = parseInt(this.topicsModal.customContentModal.activeTabId);
    const activeContent = this.topicsModal.customContentModal.getContentByTabId(activeTabId);
    if (!activeContent) {
      console.log('[ButtonPanel] No active content found, cannot regenerate');
      return;
    }
    
    // Check if this is a topic tab (can be regenerated)
    if (activeContent.contentType !== 'topic') {
      console.log('[ButtonPanel] Only topic tabs can be regenerated, current type:', activeContent.contentType);
      return;
    }
    
    // Load the topics data from the active content metadata
    if (activeContent.input) {
      // Restore the topics and settings from the content input data
      this.topicsModal.topics = activeContent.input.topics || [];
      this.topicsModal.wordCount = activeContent.input.wordCount || 100;
      this.topicsModal.difficulty = activeContent.input.difficultyLevel || 'hard';
    } else if (activeContent.metadata) {
      // Fallback to metadata for backward compatibility
      this.topicsModal.topics = activeContent.metadata.topics || [];
      this.topicsModal.wordCount = activeContent.metadata.wordCount || 100;
      this.topicsModal.difficulty = activeContent.metadata.difficulty || 'hard';
    }
    
    // Show the topics modal
    this.showTopicsModal(false);
    
    // Populate form fields with stored metadata
    setTimeout(() => {
      this.populateTopicsFormFields();
      
      // Change the generate button text to "Re-generate content"
      const generateBtn = this.topicsModal.modal.querySelector('.vocab-topics-generate-btn');
      if (generateBtn) {
        generateBtn.textContent = 'Re-generate content';
        generateBtn.setAttribute('data-regenerate', 'true');
        generateBtn.setAttribute('data-tab-id', activeTabId.toString());
      }
    }, 100);
  },

  /**
   * Populate topics form fields with stored metadata
   */
  populateTopicsFormFields() {
    console.log('[ButtonPanel] Populating topics form fields');
    
    // Clear existing topic tags
    const tagsContainer = this.topicsModal.modal.querySelector('#vocab-topics-tags');
    if (tagsContainer) {
      tagsContainer.innerHTML = '';
    }
    
    // Add topic tags from stored metadata
    this.topicsModal.topics.forEach(topic => {
      const tag = this.createTopicTag(topic);
      const tagsContainer = this.topicsModal.modal.querySelector('#vocab-topics-tags');
      if (tagsContainer) {
        tagsContainer.appendChild(tag);
      }
    });
    
    // Set word count buttons
    const wordCountButtons = this.topicsModal.modal.querySelectorAll('.vocab-topics-word-count-btn');
    wordCountButtons.forEach(btn => {
      btn.classList.remove('selected');
      if (btn.getAttribute('data-count') === this.topicsModal.wordCount.toString()) {
        btn.classList.add('selected');
      }
    });
    
    // Set difficulty buttons
    const difficultyButtons = this.topicsModal.modal.querySelectorAll('.vocab-topics-difficulty-btn');
    difficultyButtons.forEach(btn => {
      btn.classList.remove('selected');
      if (btn.getAttribute('data-difficulty') === this.topicsModal.difficulty) {
        btn.classList.add('selected');
      }
    });
    
    // Initialize sliders to show the selected options
    setTimeout(() => {
      this.initializeSliders();
    }, 50);
    
    // Update UI state
    this.updateTopicsUIState();
  },

  /**
   * Show custom content modal with contents of specific type
   */

  /**
   * Create custom content info banner
   */
  createCustomContentInfoBanner() {
    console.log('[ButtonPanel] Creating custom content info banner');
    
    // Check if banner already exists
    if (document.querySelector('.vocab-custom-content-info-banner')) {
      console.log('[ButtonPanel] Banner already exists');
      return;
    }
    
    // Create banner
    const banner = document.createElement('div');
    banner.className = 'vocab-custom-content-info-banner';
    
    // Create header
    const header = document.createElement('div');
    header.className = 'vocab-custom-content-info-banner-header';
    
    const title = document.createElement('h3');
    title.className = 'vocab-custom-content-info-banner-title';
    title.textContent = 'Quick Tips';
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'vocab-custom-content-info-banner-close';
    closeBtn.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    closeBtn.setAttribute('aria-label', 'Close banner');
    
    header.appendChild(title);
    header.appendChild(closeBtn);
    
    // Create content
    const content = document.createElement('div');
    content.className = 'vocab-custom-content-info-banner-content';
    
    const list = document.createElement('ul');
    list.className = 'vocab-custom-content-info-banner-list';
    
    const item1 = document.createElement('li');
    item1.innerHTML = 'Double click a <span class="vocab-custom-content-info-banner-highlight">word</span> to select';
    
    const item2 = document.createElement('li');
    item2.innerHTML = 'Select one or more sentences';
    
    list.appendChild(item1);
    list.appendChild(item2);
    content.appendChild(list);
    
    // Create footer
    const footer = document.createElement('div');
    footer.className = 'vocab-custom-content-info-banner-footer';
    
    const dismissBtn = document.createElement('button');
    dismissBtn.className = 'vocab-custom-content-info-banner-dismiss-btn';
    dismissBtn.innerHTML = `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M9 3L3 9M3 3L9 9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      Don't show this again
    `;
    
    footer.appendChild(dismissBtn);
    
    // Assemble banner
    banner.appendChild(header);
    banner.appendChild(content);
    banner.appendChild(footer);
    
    // Add to document
    document.body.appendChild(banner);
    
    // Attach event listeners
    closeBtn.addEventListener('click', () => {
      banner.classList.remove('visible');
      setTimeout(() => {
        banner.remove();
      }, 300);
    });
    
    dismissBtn.addEventListener('click', () => {
      // Set session storage flag
      sessionStorage.setItem('vocab-hide-custom-content-info-banner', 'true');
      banner.classList.remove('visible');
      setTimeout(() => {
        banner.remove();
      }, 300);
    });
    
    console.log('[ButtonPanel] Info banner created successfully');
  },

  /**
   * Show custom content info banner
   */
  showCustomContentInfoBanner() {
    console.log('[ButtonPanel] Showing custom content info banner');
    
    // Check if user has dismissed the banner
    const shouldHide = sessionStorage.getItem('vocab-hide-custom-content-info-banner');
    if (shouldHide === 'true') {
      console.log('[ButtonPanel] User has dismissed banner, not showing');
      return;
    }
    
    // Create banner if it doesn't exist
    let banner = document.querySelector('.vocab-custom-content-info-banner');
    if (!banner) {
      this.createCustomContentInfoBanner();
      banner = document.querySelector('.vocab-custom-content-info-banner');
    }
    
    // Show with animation
    if (banner) {
      setTimeout(() => {
        banner.classList.add('visible');
      }, 100);
    }
  },

  /**
   * Hide custom content info banner
   */
  hideCustomContentInfoBanner() {
    console.log('[ButtonPanel] Hiding custom content info banner');
    const banner = document.querySelector('.vocab-custom-content-info-banner');
    if (banner) {
      banner.classList.remove('visible');
      setTimeout(() => {
        banner.remove();
      }, 300);
    }
  },

  /**
   * Show custom content modal with existing tabs
   */

  /**
   * Filter tabs to show only the specified content type
   * @param {string} contentType - The content type to filter by ('pdf', 'image', 'topic')
   */
  filterTabsByContentType(contentType) {
    console.log('[ButtonPanel] Filtering tabs by content type:', contentType);
    
    // Get tabs for the specified content type
    const tabsToShow = this.topicsModal.customContentModal.getTabsByType(contentType);
    console.log('[ButtonPanel] Tabs to show for', contentType + ':', tabsToShow);
    
    // Clear existing tabs from the UI
    const existingTabs = this.topicsModal.customContentModal.modal.querySelectorAll('.vocab-custom-content-tab');
    existingTabs.forEach(tab => tab.remove());
    
    // Render only the filtered tabs
    tabsToShow.forEach(tab => {
      this.renderTab(tab);
    });
    
    // Update active content type
    this.topicsModal.customContentModal.activeContentType = contentType;
    
    console.log('[ButtonPanel] Filtered tabs successfully for content type:', contentType);
  },

  /**
   * Create a new tab
   * @param {string} title - The tab title
   * @param {string} content - The tab content
   * @param {string} contentType - The content type ('pdf', 'image', 'topic')
   * @param {Object} metadata - Additional metadata for the tab
   * @returns {string} Tab ID
   */
  createTab(title, content, contentType = 'topic', metadata = {}) {
    console.log('[ButtonPanel] Creating new tab:', title, 'for content type:', contentType);
    console.log('[ButtonPanel] tabsContainer before renderTab:', this.topicsModal.customContentModal.tabsContainer);
    
    // Set current content type
    this.topicsModal.currentContentType = contentType;
    console.log('[ButtonPanel] Set currentContentType to:', contentType);
    
    // Update button visibility
    setTimeout(() => {
      this.updateVerticalButtonVisibility();
    }, 100);
    
    // Use the new container system to add tab
    const newTab = this.topicsModal.customContentModal.addTab(contentType, title, content, metadata);
    
    if (!newTab) {
      console.error('[ButtonPanel] Failed to create tab for content type:', contentType);
      return null;
    }
    
    try {
      this.renderTab(newTab);
    } catch (error) {
      console.error('[ButtonPanel] Error in renderTab:', error);
      console.error('[ButtonPanel] Error stack:', error.stack);
    }
    
    // Set as active tab if it's the first one for this content type
    const containerTabs = this.topicsModal.customContentModal.getTabsByType(contentType);
    if (containerTabs.length === 1) {
      this.switchToTab(newTab.id);
    }
    
    return newTab.id;
  },

  /**
   * Render a tab element
   * @param {Object} tab - Tab object
   */
  renderTab(tab) {
    const tabsContainer = this.topicsModal.customContentModal.tabsContainer;
    if (!tabsContainer) {
      console.warn('[ButtonPanel] tabsContainer not found, cannot render tab');
      return;
    }
    
    const tabElement = document.createElement('div');
    tabElement.className = 'vocab-custom-content-tab';
    tabElement.setAttribute('data-tab-id', tab.id);
    
    // Add content type indicator
    const contentType = tab.id.split('-')[0];
    tabElement.setAttribute('data-content-type', contentType);
    
    const titleElement = document.createElement('div');
    titleElement.className = 'vocab-custom-content-tab-title';
    
    // Get the full title - prioritize topicName from metadata for topic tabs
    let fullTitle = tab.name || tab.title; // Support both new and old structure
    
    // For topic tabs, use topicName from metadata if available
    if (contentType === 'topic' && tab.metadata && tab.metadata.topicName) {
      fullTitle = tab.metadata.topicName;
    }
    
    // Set up truncation and tooltip
    this.setupTabTitleWithTooltip(titleElement, fullTitle);
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'vocab-custom-content-tab-close';
    closeBtn.innerHTML = `
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M9 3L3 9M3 3L9 9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    closeBtn.setAttribute('aria-label', 'Close tab');
    
    tabElement.appendChild(titleElement);
    tabElement.appendChild(closeBtn);
    tabsContainer.appendChild(tabElement);
    
    // Add event listeners
    tabElement.addEventListener('click', (e) => {
      if (e.target !== closeBtn && !closeBtn.contains(e.target)) {
        this.switchToTab(tab.id);
      }
    });
    
    closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      this.closeTab(tab.id);
    });
    
    // Update arrow states after adding tab
    setTimeout(() => {
      this.updateTabArrowStates();
    }, 100);
  },

  /**
   * Set up tab title with truncation and hover tooltip
   * @param {HTMLElement} titleElement - The title element to configure
   * @param {string} fullTitle - The complete title text
   */
  setupTabTitleWithTooltip(titleElement, fullTitle) {
    const maxLength = 25; // Maximum characters to show before truncation
    
    if (fullTitle.length <= maxLength) {
      // Title is short enough, just set it directly
      titleElement.textContent = fullTitle;
      return;
    }
    
    // Title is too long, truncate it
    const truncatedTitle = fullTitle.substring(0, maxLength - 3) + '...';
    titleElement.textContent = truncatedTitle;
    
    // Add tooltip functionality - use custom CSS tooltip only
    titleElement.setAttribute('title', fullTitle); // This enables the CSS tooltip
    titleElement.setAttribute('data-full-title', fullTitle); // Store for custom tooltip if needed
    
    // Add CSS class for styling
    titleElement.classList.add('vocab-tab-title-truncated');
  },

  /**
   * Switch to a specific tab
   * @param {string} tabId - The tab ID to switch to
   */
  switchToTab(tabId) {
    // Check if modal and required elements exist
    if (!this.topicsModal || !this.topicsModal.customContentModal || !this.topicsModal.customContentModal.modal) {
      console.error('[ButtonPanel] Cannot switch tab - modal not initialized');
      return;
    }
    
    // Update active tab
    this.topicsModal.customContentModal.activeTabId = tabId;
    
    // Update active content type based on the tab being switched to
    const tabContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(tabId));
    if (tabContent) {
      // Determine content type from the content data
      let contentType = 'topic'; // default
      if (tabContent.metadata && tabContent.metadata.fileName) {
        contentType = 'pdf';
      } else if (tabContent.metadata && tabContent.metadata.inputText) {
        contentType = 'text';
      } else if (tabContent.metadata && tabContent.metadata.imageUrl) {
        contentType = 'image';
      } else if (tabContent.metadata && tabContent.metadata.topics) {
        contentType = 'topic';
      }
      
      this.topicsModal.customContentModal.activeContentType = contentType;
      console.log('[ButtonPanel] Updated active content type to:', contentType, 'for tab:', tabId);
    }
    
    // Handle chat popup when switching tabs
    this.handleChatPopupOnTabSwitch(tabId);
    
    // Add smooth transition class to tabs container
    const tabsContainer = this.topicsModal.customContentModal.tabsContainer;
    if (tabsContainer) {
      tabsContainer.classList.add('tab-transitioning');
      tabsContainer.classList.add('has-active-tab');
    }
    
    // Update tab visual states
    const tabs = this.topicsModal.customContentModal.modal.querySelectorAll('.vocab-custom-content-tab');
    tabs.forEach(tab => {
      tab.classList.remove('active');
      if (tab.getAttribute('data-tab-id') === tabId) {
        tab.classList.add('active');
      }
    });
    
    // Get content from new data structure using tabId
    const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(tabId));
    const contentType = activeContent ? activeContent.contentType : null;
    
    // Update sliding background position
    const activeTabElement = tabsContainer.querySelector(`[data-tab-id="${tabId}"]`);
    if (activeTabElement) {
      const tabRect = activeTabElement.getBoundingClientRect();
      const containerRect = tabsContainer.getBoundingClientRect();
      const left = tabRect.left - containerRect.left + tabsContainer.scrollLeft;
      const width = tabRect.width;
      tabsContainer.style.setProperty('--sliding-bg-left', `${left}px`);
      tabsContainer.style.setProperty('--sliding-bg-width', `${width}px`);
    }
    
    // Update content with fade transition
    const editorContent = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    
    if (activeContent && editorContent) {
      // Fade out current content
      editorContent.classList.add('fade-out');
      
      setTimeout(() => {
        // Update content
        this.updateCustomContentEditor(activeContent.content);
        
        // Restore analysis data for this tab
        this.restoreAnalysisData(activeContent);
      
      // Update heading based on content type
      this.updateCustomContentHeading(contentType);
      
        // Fade in new content
        editorContent.classList.remove('fade-out');
        editorContent.classList.add('fade-in');
        
        setTimeout(() => {
          editorContent.classList.remove('fade-in');
        }, 300);
      }, 150);
    }
    
    // Remove transition class after animation
    setTimeout(() => {
      if (tabsContainer) {
        tabsContainer.classList.remove('tab-transitioning');
      }
      
      // Update button states after tab switch to reflect new context
      this.updateButtonStatesFromSelections();
    }, 300);
  },

  /**
   * Restore analysis data for a tab (word meanings, simplified texts, chats)
   * @param {Object} activeContent - The active content object with analysis data
   */
  restoreAnalysisData(activeContent) {
    if (!activeContent || !activeContent.analysis) {
      console.log('[ButtonPanel] No analysis data to restore for tab:', activeContent?.tabId);
      return;
    }

    console.log('[ButtonPanel] Restoring analysis data for tab:', activeContent.tabId);
    console.log('[ButtonPanel] Analysis data:', activeContent.analysis);

    // Wait for content to be fully loaded before restoring visual elements
    setTimeout(() => {
      // Verify content element is ready
      const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
      if (!contentElement) {
        console.log('[ButtonPanel] Content element not ready, retrying restoration in 200ms');
        setTimeout(() => this.restoreAnalysisData(activeContent), 200);
        return;
      }
      
      console.log('[ButtonPanel] Content element ready, proceeding with restoration');
      console.log('[ButtonPanel] Content text length:', contentElement.textContent.length);
      
      // Clear existing highlights first to avoid duplicates
      this.clearExistingHighlights();
      
      // Restore simplified texts FIRST to establish text highlight containers
      if (activeContent.analysis.simplifiedMeanings && activeContent.analysis.simplifiedMeanings.length > 0) {
        console.log('[ButtonPanel] Restoring', activeContent.analysis.simplifiedMeanings.length, 'simplified texts');
        // Add extra delay for simplified texts to ensure content is fully rendered
        setTimeout(() => {
          activeContent.analysis.simplifiedMeanings.forEach(simplifiedData => {
            this.restoreSimplifiedText(simplifiedData);
          });
          
          // After text highlights are restored, restore word meanings
          setTimeout(() => {
            if (activeContent.analysis.wordMeanings && activeContent.analysis.wordMeanings.length > 0) {
              console.log('[ButtonPanel] Restoring', activeContent.analysis.wordMeanings.length, 'word meanings');
              activeContent.analysis.wordMeanings.forEach(wordData => {
                this.restoreWordExplanationWithHierarchy(wordData);
              });
            }
            
            // Additional repositioning after all highlights are restored
            setTimeout(() => {
              this.repositionAllSimplifiedIcons();
            }, 100);
          }, 100);
        }, 200);
      } else {
        // If no simplified texts, restore word meanings directly
        if (activeContent.analysis.wordMeanings && activeContent.analysis.wordMeanings.length > 0) {
          console.log('[ButtonPanel] Restoring', activeContent.analysis.wordMeanings.length, 'word meanings');
          activeContent.analysis.wordMeanings.forEach(wordData => {
            this.restoreWordExplanation(wordData);
          });
        }
      }

      // Restore chats
      if (activeContent.analysis.chats && activeContent.analysis.chats.length > 0) {
        console.log('[ButtonPanel] Restoring', activeContent.analysis.chats.length, 'chats');
        activeContent.analysis.chats.forEach(chatData => {
          // Restore chat history in ChatDialog
          if (chatData.messages && chatData.messages.length > 0) {
            console.log('[ButtonPanel] ===== RESTORING FROM ANALYSIS DATA =====');
            console.log('[ButtonPanel] Restoring chat history for textKey:', chatData.textKey, 'with', chatData.messages.length, 'messages');
            console.log('[ButtonPanel] ChatDialog.chatHistories before analysis restore:', Array.from(ChatDialog.chatHistories.keys()));
            
            ChatDialog.chatHistories.set(chatData.textKey, chatData.messages);
            
            console.log('[ButtonPanel] ChatDialog.chatHistories after analysis restore:', Array.from(ChatDialog.chatHistories.keys()));
            console.log('[ButtonPanel] Chat messages:', chatData.messages);
          }
        });
      }

      // Update button states to reflect restored data
      this.updateButtonStatesFromSelections();
      
      console.log('[ButtonPanel] Analysis data restoration complete');
    }, 500); // Wait for content to be fully rendered
  },

  /**
   * Clear existing highlights from the content
   */
  clearExistingHighlights() {
    const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!contentElement) {
      return;
    }

    // Remove all word highlights
    const wordHighlights = contentElement.querySelectorAll('.vocab-word-highlight');
    wordHighlights.forEach(highlight => {
      const parent = highlight.parentNode;
      if (parent) {
        parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
        parent.normalize();
      }
    });

    // Remove all text highlights
    const textHighlights = contentElement.querySelectorAll('.vocab-text-highlight');
    textHighlights.forEach(highlight => {
      const parent = highlight.parentNode;
      if (parent) {
        parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
        parent.normalize();
      }
    });

    // Remove only icon wrappers from modal overlay (if in modal context)
    const modalOverlay = this.topicsModal.customContentModal.overlay;
    if (modalOverlay) {
      const iconWrappers = modalOverlay.querySelectorAll('.vocab-text-icons-wrapper');
      iconWrappers.forEach(wrapper => {
        wrapper.remove();
      });
    }

    // Don't remove icon wrappers from document body - they should be preserved for main webpage
    // The main webpage icons should remain visible and functional

    console.log('[ButtonPanel] Cleared existing highlights');
  },

  /**
   * Restore visual word explanation elements with hierarchy awareness
   * @param {Object} wordData - Word explanation data
   */
  restoreWordExplanationWithHierarchy(wordData) {
    console.log('[ButtonPanel] Restoring word explanation with hierarchy for:', wordData.word);
    console.log('[ButtonPanel] Word data:', wordData);
    
    // Find the content element
    const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!contentElement) {
      console.log('[ButtonPanel] Content element not found for word restoration');
      return;
    }

    const textContent = contentElement.textContent || contentElement.innerText;
    if (!textContent) {
      console.log('[ButtonPanel] No text content found for word restoration');
      return;
    }

    // Use stored textStartIndex if available, otherwise fall back to regex search
    if (wordData.textStartIndex !== undefined && wordData.location !== undefined) {
      console.log('[ButtonPanel] Using stored positioning data - textStartIndex:', wordData.textStartIndex, 'location:', wordData.location);
      console.log('[ButtonPanel] Text content length:', textContent.length);
      console.log('[ButtonPanel] Text content preview:', textContent.substring(0, 200));
      
      // Use the stored location data to find the word
      const wordStart = wordData.textStartIndex + wordData.location.index;
      const wordEnd = wordStart + wordData.location.length;
      
      console.log('[ButtonPanel] Calculated word position:', wordStart, '-', wordEnd);
      
      // Verify the word matches at this position
      const wordAtPosition = textContent.substring(wordStart, wordEnd);
      console.log('[ButtonPanel] Word at calculated position:', wordAtPosition);
      
      if (wordAtPosition.toLowerCase() === wordData.normalizedWord) {
        console.log('[ButtonPanel] Word matches at calculated position');
        
        // Check if this word is inside an existing text highlight
        const textHighlights = contentElement.querySelectorAll('.vocab-text-highlight');
        let targetTextHighlight = null;
        
        for (const textHighlight of textHighlights) {
          const textHighlightStart = this.getTextNodeOffset(textHighlight);
          const textHighlightEnd = textHighlightStart + textHighlight.textContent.length;
          
          console.log('[ButtonPanel] Checking text highlight:', textHighlightStart, '-', textHighlightEnd);
          
          // Check if word position is within this text highlight
          if (wordStart >= textHighlightStart && wordEnd <= textHighlightEnd) {
            console.log('[ButtonPanel] Word is inside text highlight, will nest it');
            targetTextHighlight = textHighlight;
            break;
          }
        }
        
        if (targetTextHighlight) {
          // Word should be nested inside the text highlight
          this.createNestedWordHighlight(targetTextHighlight, wordStart, wordEnd, wordData);
        } else {
          // Word is not inside any text highlight, create standalone highlight
          this.createStandaloneWordHighlight(contentElement, wordStart, wordEnd, wordData);
        }
      } else {
        console.log('[ButtonPanel] Word does not match at calculated position, falling back to regex search');
        this.restoreWordExplanation(wordData);
      }
    } else {
      console.log('[ButtonPanel] No stored positioning data, falling back to regex search');
      this.restoreWordExplanation(wordData);
    }
  },

  /**
   * Create a word highlight nested inside a text highlight
   * @param {HTMLElement} textHighlight - The parent text highlight element
   * @param {number} wordStart - Start position of the word
   * @param {number} wordEnd - End position of the word
   * @param {Object} wordData - Word explanation data
   */
  createNestedWordHighlight(textHighlight, wordStart, wordEnd, wordData) {
    console.log('[ButtonPanel] Creating nested word highlight for:', wordData.word);
    
    const textHighlightStart = this.getTextNodeOffset(textHighlight);
    const relativeWordStart = wordStart - textHighlightStart;
    const relativeWordEnd = wordEnd - textHighlightStart;
    
    console.log('[ButtonPanel] Text highlight start:', textHighlightStart);
    console.log('[ButtonPanel] Relative word position:', relativeWordStart, '-', relativeWordEnd);
    
    // Create word highlight element
    const wordHighlight = document.createElement('span');
    wordHighlight.className = 'vocab-word-highlight vocab-word-explained';
    wordHighlight.setAttribute('data-word-highlight', `${wordData.normalizedWord}-0`);
    wordHighlight.setAttribute('data-meaning', wordData.meaning);
    wordHighlight.setAttribute('data-examples', JSON.stringify(wordData.examples));
    
    // Replace the word text within the text highlight
    this.replaceTextInElement(textHighlight, relativeWordStart, relativeWordEnd, wordHighlight);
    
    // Add to WordSelector explained words
    if (!WordSelector.explainedWords.has(wordData.normalizedWord)) {
      WordSelector.explainedWords.set(wordData.normalizedWord, {
        word: wordData.word,
        meaning: wordData.meaning,
        examples: wordData.examples,
        shouldAllowFetchMoreExamples: wordData.shouldAllowFetchMoreExamples || false,
        hasCalledGetMoreExamples: false,
        languageCode: wordData.languageCode || null,
        highlights: new Set()
      });
    }
    WordSelector.explainedWords.get(wordData.normalizedWord).highlights.add(wordHighlight);

    // Add green cross button
    const greenCrossBtn = WordSelector.createRemoveExplainedButton(wordData.word);
    wordHighlight.appendChild(greenCrossBtn);

    // Setup word interactions
    WordSelector.setupWordInteractions(wordHighlight);

    console.log('[ButtonPanel] Created nested word highlight for:', wordData.word);
  },

  /**
   * Create a standalone word highlight (not nested)
   * @param {HTMLElement} contentElement - The content element
   * @param {number} wordStart - Start position of the word
   * @param {number} wordEnd - End position of the word
   * @param {Object} wordData - Word explanation data
   */
  createStandaloneWordHighlight(contentElement, wordStart, wordEnd, wordData) {
    console.log('[ButtonPanel] Creating standalone word highlight for:', wordData.word);
    
    // Create word highlight element
    const wordHighlight = document.createElement('span');
    wordHighlight.className = 'vocab-word-highlight vocab-word-explained';
    wordHighlight.setAttribute('data-word-highlight', `${wordData.normalizedWord}-0`);
    wordHighlight.setAttribute('data-meaning', wordData.meaning);
    wordHighlight.setAttribute('data-examples', JSON.stringify(wordData.examples));
    
    // Replace the word text in the content
    this.replaceTextInElement(contentElement, wordStart, wordEnd, wordHighlight);
    
    // Add to WordSelector explained words
    if (!WordSelector.explainedWords.has(wordData.normalizedWord)) {
      WordSelector.explainedWords.set(wordData.normalizedWord, {
        word: wordData.word,
        meaning: wordData.meaning,
        examples: wordData.examples,
        shouldAllowFetchMoreExamples: wordData.shouldAllowFetchMoreExamples || false,
        hasCalledGetMoreExamples: false,
        languageCode: wordData.languageCode || null,
        highlights: new Set()
      });
    }
    WordSelector.explainedWords.get(wordData.normalizedWord).highlights.add(wordHighlight);

    // Add green cross button
    const greenCrossBtn = WordSelector.createRemoveExplainedButton(wordData.word);
    wordHighlight.appendChild(greenCrossBtn);

    // Setup word interactions
    WordSelector.setupWordInteractions(wordHighlight);

    console.log('[ButtonPanel] Created standalone word highlight for:', wordData.word);
  },

  /**
   * Get the text node offset of an element within its parent
   * @param {HTMLElement} element - The element to get offset for
   * @returns {number} The offset position
   */
  getTextNodeOffset(element) {
    let offset = 0;
    let node = element.previousSibling;
    
    while (node) {
      if (node.nodeType === Node.TEXT_NODE) {
        offset += node.textContent.length;
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        offset += node.textContent.length;
      }
      node = node.previousSibling;
    }
    
    return offset;
  },

  /**
   * Restore visual word explanation elements (original function for fallback)
   * @param {Object} wordData - Word explanation data
   */
  restoreWordExplanation(wordData) {
    console.log('[ButtonPanel] Restoring word explanation for:', wordData.word);
    console.log('[ButtonPanel] Word data:', wordData);
    
    // Find the content element
    const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!contentElement) {
      console.log('[ButtonPanel] Content element not found for word restoration');
      return;
    }

    const textContent = contentElement.textContent || contentElement.innerText;
    if (!textContent) {
      console.log('[ButtonPanel] No text content found for word restoration');
      return;
    }

    // Use stored textStartIndex if available, otherwise fall back to regex search
    if (wordData.textStartIndex !== undefined && wordData.location !== undefined) {
      console.log('[ButtonPanel] Using stored positioning data - textStartIndex:', wordData.textStartIndex, 'location:', wordData.location);
      console.log('[ButtonPanel] Text content length:', textContent.length);
      console.log('[ButtonPanel] Text content preview:', textContent.substring(0, 200));
      
      // Use the stored location data to find the word
      const wordStart = wordData.textStartIndex + wordData.location.index;
      const wordEnd = wordStart + wordData.location.length;
      
      console.log('[ButtonPanel] Calculated word position:', wordStart, '-', wordEnd);
      
      // Verify the word matches at this position
      const wordAtPosition = textContent.substring(wordStart, wordEnd);
      console.log('[ButtonPanel] Word at calculated position:', wordAtPosition);
      console.log('[ButtonPanel] Expected word:', wordData.word);
      
      if (wordAtPosition.toLowerCase() === wordData.word.toLowerCase()) {
        console.log('[ButtonPanel] Found word at stored position:', wordAtPosition);
        
        // Check if this word is already highlighted
        const existingHighlight = contentElement.querySelector(`[data-word-highlight="${wordData.normalizedWord}-0"]`);
        if (existingHighlight) {
          console.log('[ButtonPanel] Word already highlighted:', wordData.word);
          return;
        }

        // Create word highlight element
        const highlight = document.createElement('span');
        highlight.className = 'vocab-word-highlight vocab-word-explained';
        highlight.setAttribute('data-word-highlight', `${wordData.normalizedWord}-0`);
        highlight.setAttribute('data-meaning', wordData.meaning);
        highlight.setAttribute('data-examples', JSON.stringify(wordData.examples));
        highlight.textContent = wordAtPosition;

        // Replace the word in the DOM using stored position
        this.replaceTextInElement(contentElement, wordStart, wordEnd, highlight);

        // Add to WordSelector explained words
        if (!WordSelector.explainedWords.has(wordData.normalizedWord)) {
          WordSelector.explainedWords.set(wordData.normalizedWord, {
            word: wordData.word,
            meaning: wordData.meaning,
            examples: wordData.examples,
            shouldAllowFetchMoreExamples: wordData.shouldAllowFetchMoreExamples || false,
            hasCalledGetMoreExamples: false,
            languageCode: wordData.languageCode || null,
            highlights: new Set()
          });
        }
        WordSelector.explainedWords.get(wordData.normalizedWord).highlights.add(highlight);

        // Add green cross button
        const greenCrossBtn = WordSelector.createRemoveExplainedButton(wordData.word);
        highlight.appendChild(greenCrossBtn);

        // Setup word interactions
        WordSelector.setupWordInteractions(highlight);

        console.log('[ButtonPanel] Restored word highlight for:', wordData.word, 'at position', wordStart, '-', wordEnd);
        return;
      } else {
        console.log('[ButtonPanel] Word mismatch at stored position. Expected:', wordData.word, 'Found:', wordAtPosition);
        console.log('[ButtonPanel] Falling back to regex search');
      }
    }

    // Fallback: Find word positions using regex (original logic)
    console.log('[ButtonPanel] Using regex search fallback for word:', wordData.word);
    const wordRegex = new RegExp(`\\b${wordData.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
    let match;
    const wordPositions = [];
    
    while ((match = wordRegex.exec(textContent)) !== null) {
      wordPositions.push({
        start: match.index,
        end: match.index + match[0].length,
        word: match[0]
      });
    }

    console.log('[ButtonPanel] Found', wordPositions.length, 'instances of word:', wordData.word);

    // Create highlights for each word instance
    wordPositions.forEach((pos, index) => {
      // Check if this word is already highlighted
      const existingHighlight = contentElement.querySelector(`[data-word-highlight="${wordData.normalizedWord}-${index}"]`);
      if (existingHighlight) {
        console.log('[ButtonPanel] Word already highlighted:', wordData.word, 'instance', index);
        return;
      }

      // Create word highlight element
      const highlight = document.createElement('span');
      highlight.className = 'vocab-word-highlight vocab-word-explained';
      highlight.setAttribute('data-word-highlight', `${wordData.normalizedWord}-${index}`);
      highlight.setAttribute('data-meaning', wordData.meaning);
      highlight.setAttribute('data-examples', JSON.stringify(wordData.examples));
      highlight.textContent = pos.word;

      // Replace the word in the DOM
      this.replaceTextInElement(contentElement, pos.start, pos.end, highlight);

      // Add to WordSelector explained words
      if (!WordSelector.explainedWords.has(wordData.normalizedWord)) {
        WordSelector.explainedWords.set(wordData.normalizedWord, {
          word: wordData.word,
          meaning: wordData.meaning,
          examples: wordData.examples,
          shouldAllowFetchMoreExamples: wordData.shouldAllowFetchMoreExamples || false,
          hasCalledGetMoreExamples: false,
          highlights: new Set()
        });
      }
      WordSelector.explainedWords.get(wordData.normalizedWord).highlights.add(highlight);

      // Add green cross button
      const greenCrossBtn = WordSelector.createRemoveExplainedButton(wordData.word);
      highlight.appendChild(greenCrossBtn);

      // Setup word interactions
      WordSelector.setupWordInteractions(highlight);

      console.log('[ButtonPanel] Restored word highlight for:', wordData.word, 'instance', index);
    });
  },

  /**
   * Restore visual simplified text elements
   * @param {Object} simplifiedData - Simplified text data
   */
  restoreSimplifiedText(simplifiedData) {
    console.log('[ButtonPanel] ===== RESTORING SIMPLIFIED TEXT =====');
    console.log('[ButtonPanel] Restoring simplified text for textKey:', simplifiedData.textKey);
    console.log('[ButtonPanel] Simplified data:', simplifiedData);
    
    const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!contentElement) {
      console.log('[ButtonPanel] Content element not found for simplified text restoration');
      return;
    }

    const textContent = contentElement.textContent || contentElement.innerText;
    if (!textContent) {
      console.log('[ButtonPanel] No text content found for simplified text restoration');
      return;
    }

    // Instead of using indices, search for the original text content
    const originalText = simplifiedData.originalText;
    if (!originalText) {
      console.log('[ButtonPanel] No original text found in simplified data');
      return;
    }

    console.log('[ButtonPanel] Searching for original text:', originalText.substring(0, 50) + '...');
    console.log('[ButtonPanel] Content length:', textContent.length);

    // Find the text segment in the content using text matching
    const textIndex = textContent.indexOf(originalText);
    if (textIndex === -1) {
      console.log('[ButtonPanel] Original text not found in current content');
      // Try to find a partial match
      const words = originalText.split(' ').slice(0, 5); // First 5 words
      const partialText = words.join(' ');
      const partialIndex = textContent.indexOf(partialText);
      if (partialIndex !== -1) {
        console.log('[ButtonPanel] Found partial match, using first 5 words');
        this.createSimplifiedHighlight(contentElement, partialIndex, partialText.length, partialText, simplifiedData);
      } else {
        console.log('[ButtonPanel] No match found for simplified text');
      }
      return;
    }

    console.log('[ButtonPanel] Found original text at index:', textIndex);
    this.createSimplifiedHighlight(contentElement, textIndex, originalText.length, originalText, simplifiedData);
    console.log('[ButtonPanel] ===== SIMPLIFIED TEXT RESTORATION COMPLETE =====');
  },

  /**
   * Create a simplified text highlight
   * @param {HTMLElement} contentElement - The content element
   * @param {number} startIndex - Start index of the text
   * @param {number} length - Length of the text
   * @param {string} text - The text content
   * @param {Object} simplifiedData - The simplified data object
   */
  createSimplifiedHighlight(contentElement, startIndex, length, text, simplifiedData) {
    console.log('[ButtonPanel] ===== CREATING SIMPLIFIED HIGHLIGHT =====');
    console.log('[ButtonPanel] Start index:', startIndex, 'Length:', length, 'Text:', text.substring(0, 50) + '...');
    
    // Check if this text is already highlighted
    const existingHighlight = window.safeQueryByDataAttribute('[data-text-highlight]', 'data-text-highlight', simplifiedData.textKey, contentElement);
    if (existingHighlight) {
      console.log('[ButtonPanel] Text already highlighted for textKey:', simplifiedData.textKey);
      return;
    }

    console.log('[ButtonPanel] Creating simplified text highlight for:', text.substring(0, 30) + '...');

    // Create text highlight element
    const highlight = document.createElement('span');
    highlight.className = 'vocab-text-highlight vocab-text-simplified';
    highlight.setAttribute('data-text-highlight', simplifiedData.textKey);
    highlight.textContent = text;

    // Replace the text in the DOM
    this.replaceTextInElement(contentElement, startIndex, startIndex + length, highlight);

    // Create wrapper for icons
    const iconsWrapper = document.createElement('div');
    iconsWrapper.className = 'vocab-text-icons-wrapper';
    iconsWrapper.setAttribute('data-text-key', simplifiedData.textKey);
    
    // Add book button first (top position)
    const bookBtn = TextSelector.createBookButton(simplifiedData.textKey);
    iconsWrapper.appendChild(bookBtn);
    
    // Force reflow to ensure animation starts immediately
    void iconsWrapper.offsetHeight;
    void bookBtn.offsetHeight;
    
    // Add green remove button second (bottom position)
    const greenRemoveBtn = TextSelector.createGreenRemoveButtonForSimplifiedText(simplifiedData.textKey);
    iconsWrapper.appendChild(greenRemoveBtn);
    
    // Check if we're in modal context or main webpage context
    const modalOverlay = this.topicsModal.customContentModal.overlay;
    if (modalOverlay && contentElement.closest('.vocab-custom-content-modal')) {
      // Modal context: append to editor container so icons scroll with text
      const editorContainer = contentElement.closest('.vocab-custom-content-editor-content');
      if (editorContainer) {
        editorContainer.appendChild(iconsWrapper);
        iconsWrapper.setAttribute('data-icon-context', 'custom-content-modal');
        this.positionIconsRelativeToHighlight(iconsWrapper, highlight);
      } else {
        // Fallback to modal overlay if editor container not found
        modalOverlay.appendChild(iconsWrapper);
        iconsWrapper.setAttribute('data-icon-context', 'custom-content-modal');
        this.positionIconsRelativeToHighlight(iconsWrapper, highlight);
      }
    } else {
      // Main webpage context: append to document body and position relative to highlight
      document.body.appendChild(iconsWrapper);
      iconsWrapper.setAttribute('data-icon-context', 'main-webpage');
      this.positionIconsRelativeToHighlight(iconsWrapper, highlight);
    }

    // Add to TextSelector simplified texts
    TextSelector.simplifiedTexts.set(simplifiedData.textKey, {
      textStartIndex: startIndex,
      textLength: length,
      text: text,
      simplifiedText: simplifiedData.simplifiedText,
      previousSimplifiedTexts: simplifiedData.previousSimplifiedTexts || [],
      shouldAllowSimplifyMore: simplifiedData.shouldAllowSimplifyMore || false,
      highlight: highlight
    });

    console.log('[ButtonPanel] Restored simplified text highlight for textKey:', simplifiedData.textKey);
    console.log('[ButtonPanel] ===== SIMPLIFIED HIGHLIGHT CREATION COMPLETE =====');
  },

  /**
   * Position icons relative to a text highlight
   * @param {HTMLElement} iconsWrapper - The icons wrapper element
   * @param {HTMLElement} highlight - The text highlight element
   */
  positionIconsRelativeToHighlight(iconsWrapper, highlight) {
    // Function to perform the actual positioning
    const performPositioning = () => {
      const highlightRect = highlight.getBoundingClientRect();
      const isModalContext = highlight.closest('.vocab-custom-content-modal');
      
      // Check if highlight has valid dimensions
      if (highlightRect && highlightRect.width > 0 && highlightRect.height > 0) {
        if (isModalContext) {
          // Modal context: position relative to editor container
          const editorContainer = highlight.closest('.vocab-custom-content-editor-content');
          if (editorContainer) {
            const editorRect = editorContainer.getBoundingClientRect();
            
            // Position icons on the top left of the highlight (like main webpage)
            const top = highlightRect.top - editorRect.top - 40; // 40px above
            const left = highlightRect.left - editorRect.left - 60; // 60px to the left
            
            iconsWrapper.style.top = `${Math.max(10, top)}px`; // Ensure it doesn't go above editor
            iconsWrapper.style.left = `${Math.max(10, left)}px`; // Ensure it doesn't go left of editor
            iconsWrapper.style.position = 'absolute'; // Ensure absolute positioning within editor
            
            console.log('[ButtonPanel] Modal context - Positioned icons relative to editor:', { 
              top: iconsWrapper.style.top, 
              left: iconsWrapper.style.left,
              highlightRect: { top: highlightRect.top, left: highlightRect.left },
              editorRect: { top: editorRect.top, left: editorRect.left }
            });
          } else {
            // Fallback to modal overlay positioning
            const modalOverlay = this.topicsModal.customContentModal.overlay;
            if (modalOverlay) {
              const overlayRect = modalOverlay.getBoundingClientRect();
              
              const top = highlightRect.top - overlayRect.top - 40;
              const left = highlightRect.left - overlayRect.left - 60;
              
              iconsWrapper.style.top = `${Math.max(10, top)}px`;
              iconsWrapper.style.left = `${Math.max(10, left)}px`;
            }
          }
        } else {
          // Main webpage context: position relative to viewport (original behavior)
          const top = highlightRect.top - 40; // 40px above
          const left = highlightRect.left - 40; // 40px to the left
          
          iconsWrapper.style.top = `${Math.max(10, top)}px`; // Ensure it doesn't go above viewport
          iconsWrapper.style.left = `${Math.max(10, left)}px`; // Ensure it doesn't go left of viewport
          
          console.log('[ButtonPanel] Main webpage context - Positioned icons at:', { 
            top: iconsWrapper.style.top, 
            left: iconsWrapper.style.left,
            highlightRect: { top: highlightRect.top, left: highlightRect.left }
          });
        }
        return true; // Successfully positioned
      }
      return false; // Not ready yet
    };

    // Try positioning immediately
    if (performPositioning()) {
      return;
    }

    // If not ready, try with increasing delays
    const delays = [50, 100, 200, 300];
    delays.forEach(delay => {
      setTimeout(() => {
        if (!performPositioning()) {
          console.log('[ButtonPanel] Positioning attempt failed at delay:', delay);
        }
      }, delay);
    });
  },

  /**
   * Reposition all simplified text icons after restoration
   */
  repositionAllSimplifiedIcons() {
    console.log('[ButtonPanel] Repositioning all simplified text icons');
    
    // Get all simplified text highlights
    const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!contentElement) {
      console.log('[ButtonPanel] No content element found for repositioning');
      return;
    }
    
    const simplifiedHighlights = contentElement.querySelectorAll('.vocab-text-highlight.vocab-text-simplified');
    console.log('[ButtonPanel] Found', simplifiedHighlights.length, 'simplified highlights to reposition');
    
    simplifiedHighlights.forEach(highlight => {
      const textKey = highlight.getAttribute('data-text-highlight');
      if (textKey) {
        // Find the corresponding icon wrapper
        const modalOverlay = this.topicsModal.customContentModal.overlay;
        if (modalOverlay) {
          const iconsWrapper = window.safeQueryByDataTextKey('[data-text-key]', textKey, modalOverlay);
          if (iconsWrapper) {
            console.log('[ButtonPanel] Repositioning icons for textKey:', textKey);
            this.positionIconsRelativeToHighlight(iconsWrapper, highlight);
          }
        }
      }
    });
    
    console.log('[ButtonPanel] Completed repositioning all simplified text icons');
  },

  /**
   * Open chat dialog for current content tab
   */
  openChatForCurrentContent() {
    console.log('[ButtonPanel] ===== OPENING CHAT FOR CURRENT CONTENT =====');
    console.log('[ButtonPanel] Opening chat for current content');
    
    // Get the currently active tab content
    const activeTabId = this.topicsModal.customContentModal.activeTabId;
    console.log('[ButtonPanel] Active tab ID:', activeTabId);
    if (!activeTabId) {
      console.log('[ButtonPanel] ERROR: No active tab found');
      return;
    }
    
    const activeContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(activeTabId));
    console.log('[ButtonPanel] Active content found:', !!activeContent);
    if (!activeContent) {
      console.log('[ButtonPanel] ERROR: No active content found for tabId:', activeTabId);
      return;
    }
    
    console.log('[ButtonPanel] Active content details:', {
      tabId: activeContent.tabId,
      tabName: activeContent.tabName,
      contentType: activeContent.contentType,
      hasAnalysis: !!activeContent.analysis,
      chatsCount: activeContent.analysis?.chats?.length || 0
    });
    
    // Get the text content from the editor
    const editorContent = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!editorContent) {
      console.log('[ButtonPanel] No editor content found');
      return;
    }
    
    // Get the text content (remove any HTML tags)
    let textContent = editorContent.textContent || editorContent.innerText;
    if (!textContent || textContent.trim().length === 0) {
      console.log('[ButtonPanel] No text content found in editor');
      return;
    }
    
    // Truncate text content if it's too large to prevent API 422 errors
    // Most APIs have limits around 50,000 characters for context
    const MAX_CONTEXT_LENGTH = 40000; // Leave some buffer
    if (textContent.length > MAX_CONTEXT_LENGTH) {
      console.log('[ButtonPanel] Text content too large (' + textContent.length + ' chars), truncating to ' + MAX_CONTEXT_LENGTH + ' chars');
      textContent = textContent.substring(0, MAX_CONTEXT_LENGTH) + '...\n\n[Content truncated for API processing]';
    }
    
    console.log('[ButtonPanel] Text content length:', textContent.length);
    console.log('[ButtonPanel] Text content preview:', textContent.substring(0, 100) + '...');
    
    // Generate a consistent textKey for this content tab using proper format
    const contentType = activeContent.contentType || 'custom-content';
    const textKey = `${contentType}-${activeTabId}`;
    console.log('[ButtonPanel] Generated textKey:', textKey, 'for contentType:', contentType, 'tabId:', activeTabId);
    
    // Check if chat dialog is already open for this tab
    if (ChatDialog.isOpen && ChatDialog.currentTextKey === textKey) {
      console.log('[ButtonPanel] Chat already open for this tab, closing it');
      ChatDialog.close();
      return;
    }
    
    // Check if there's existing chat history for this tab
    let existingChatHistory = null;
    const contextualTextKey = `${contentType}-${activeTabId}-generic`;
    console.log('[ButtonPanel] Looking for chat history with contextualTextKey:', contextualTextKey);
    
    if (activeContent.analysis && activeContent.analysis.chats) {
      console.log('[ButtonPanel] Available chats in analysis:', activeContent.analysis.chats.map(c => c.textKey));
      
      // Find chat history for this specific contextual textKey
      existingChatHistory = activeContent.analysis.chats.find(chat => 
        chat.textKey === contextualTextKey && chat.messages && chat.messages.length > 0
      );
      
      if (existingChatHistory) {
        console.log('[ButtonPanel] Found existing chat history for contextualTextKey:', contextualTextKey, 'with', existingChatHistory.messages.length, 'messages');
      } else {
        console.log('[ButtonPanel] No existing chat history found for contextualTextKey:', contextualTextKey);
      }
    }
    
    console.log('[ButtonPanel] Existing chat history found:', existingChatHistory ? existingChatHistory.messages.length : 0, 'messages');
    
    // Open the chat dialog with the current content as initial context
    console.log('[ButtonPanel] Calling ChatDialog.open with:', {
      textContentLength: textContent.length,
      textKey: textKey,
      mode: 'ask',
      chatContext: 'general'
    });
    ChatDialog.open(textContent, textKey, 'ask', null, 'general');
    console.log('[ButtonPanel] ChatDialog.open called successfully');
    
    // If there's existing chat history, restore it to the ChatDialog
    if (existingChatHistory && existingChatHistory.messages.length > 0) {
      console.log('[ButtonPanel] ===== RESTORING CHAT HISTORY =====');
      console.log('[ButtonPanel] Restoring chat history for contextualTextKey:', contextualTextKey);
      console.log('[ButtonPanel] Messages to restore:', existingChatHistory.messages.length);
      console.log('[ButtonPanel] ChatDialog.chatHistories before set:', Array.from(ChatDialog.chatHistories.keys()));
      
      ChatDialog.chatHistories.set(contextualTextKey, existingChatHistory.messages);
      ChatDialog.chatHistory = [...existingChatHistory.messages];
      
      console.log('[ButtonPanel] ChatDialog.chatHistories after set:', Array.from(ChatDialog.chatHistories.keys()));
      console.log('[ButtonPanel] ChatDialog.chatHistory length:', ChatDialog.chatHistory.length);
      
      // Re-render the chat messages
      setTimeout(() => {
        ChatDialog.renderChatMessages();
      }, 100);
    } else {
      // No existing chat history in analysis data - check if it exists in ChatDialog.chatHistories
      console.log('[ButtonPanel] No existing chat history in analysis data, checking ChatDialog.chatHistories');
      console.log('[ButtonPanel] Available keys in ChatDialog.chatHistories:', Array.from(ChatDialog.chatHistories.keys()));
      
      const existingInMemory = ChatDialog.chatHistories.get(contextualTextKey);
      if (existingInMemory && existingInMemory.length > 0) {
        console.log('[ButtonPanel] Found existing chat history in memory for contextualTextKey:', contextualTextKey);
        ChatDialog.chatHistory = [...existingInMemory];
        
        // Re-render the chat messages
        setTimeout(() => {
          ChatDialog.renderChatMessages();
        }, 100);
      } else {
        // No existing chat history anywhere - start fresh
        console.log('[ButtonPanel] No existing chat history anywhere, starting fresh');
        ChatDialog.chatHistory = []; // Clear current chat history only
        
        // Re-render the chat messages to show empty state
        setTimeout(() => {
          ChatDialog.renderChatMessages();
        }, 100);
      }
    }
    
    // Auto-focus is now handled by ChatDialog.show() based on chat context
    // No need to auto-focus here since generic chat should not be auto-focused
    
    console.log('[ButtonPanel] Chat dialog opened for current content');
  },

  /**
   * Handle chat popup behavior when switching tabs
   * @param {string} tabId - The tab ID being switched to
   */
  handleChatPopupOnTabSwitch(tabId) {
    console.log('[ButtonPanel] Handling chat popup for tab switch to:', tabId);
    
    // Get the PREVIOUS tab ID (the one we're leaving)
    const previousTabId = this.topicsModal.customContentModal.activeTabId;
    console.log('[ButtonPanel] Previous tab ID:', previousTabId);
    
    // Save current chat history to analysis data before closing (for the tab where chat was opened)
    if (ChatDialog.isOpen && ChatDialog.currentTextKey && ChatDialog.chatHistory.length > 0) {
      // Extract the tab ID from the currentTextKey (format: <contentType>-<tabId>-generic or <contentType>-<tabId>-<startIndex>-<length>)
      const chatTabId = ChatDialog.currentTextKey.replace(/^[^-]+-(\d+)-.*/, '$1');
      console.log('[ButtonPanel] Saving current chat history for chat tab:', chatTabId);
      console.log('[ButtonPanel] Chat was opened for tab:', chatTabId, 'but switching to tab:', tabId);
      console.log('[ButtonPanel] CurrentTextKey:', ChatDialog.currentTextKey, 'ChatContext:', ChatDialog.chatContext);
      
      // Get the content for the tab where the chat was originally opened
      const chatActiveContent = this.topicsModal.customContentModal.getContentByTabId(parseInt(chatTabId));
      if (chatActiveContent && chatActiveContent.analysis) {
        console.log('[ButtonPanel] Available chats before saving:', chatActiveContent.analysis.chats.map(c => c.textKey));
        const existingChatIndex = chatActiveContent.analysis.chats.findIndex(c =>
          c.textKey === ChatDialog.currentTextKey
        );

        const chatData = {
          textKey: ChatDialog.currentTextKey,
          originalText: ChatDialog.currentText,
          messages: [...ChatDialog.chatHistory],
          lastUpdated: new Date().toISOString()
        };

        if (existingChatIndex !== -1) {
          chatActiveContent.analysis.chats[existingChatIndex] = chatData;
          console.log(`[ButtonPanel] Updated existing chat for textKey "${ChatDialog.currentTextKey}" in analysis data for tab ${chatTabId}`);
        } else {
          chatActiveContent.analysis.chats.push(chatData);
          console.log(`[ButtonPanel] Added new chat for textKey "${ChatDialog.currentTextKey}" to analysis data for tab ${chatTabId}`);
        }
      }
    }
    
    // Close current chat popup if it's open
    if (ChatDialog.isOpen) {
      console.log('[ButtonPanel] Closing current chat popup');
      ChatDialog.close();
    }
    
    // NO AUTO-OPENING - just track chat history per tab in memory
    console.log('[ButtonPanel] Chat history saved, no auto-opening chat popup');
  },


  /**
   * Replace text in an element with a new element
   * @param {HTMLElement} element - The element containing the text
   * @param {number} startIndex - Start index of text to replace
   * @param {number} endIndex - End index of text to replace
   * @param {HTMLElement} newElement - The new element to insert
   */
  replaceTextInElement(element, startIndex, endIndex, newElement) {
    console.log('[ButtonPanel] replaceTextInElement called with:', { startIndex, endIndex, newElement: newElement.textContent });
    
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );

    let currentPos = 0;
    let node;
    let targetNode = null;
    let targetStart = 0;

    // Find the text node containing our target range
    while (node = walker.nextNode()) {
      const nodeLength = node.textContent.length;
      
      if (currentPos + nodeLength > startIndex) {
        targetNode = node;
        targetStart = startIndex - currentPos;
        break;
      }
      currentPos += nodeLength;
    }

    if (!targetNode) {
      console.log('[ButtonPanel] Could not find target text node for replacement at position', startIndex);
      console.log('[ButtonPanel] Element text content length:', element.textContent.length);
      console.log('[ButtonPanel] Element text content preview:', element.textContent.substring(0, 100));
      return;
    }

    // Verify the target text matches what we expect
    const targetText = targetNode.textContent.substring(targetStart, targetStart + (endIndex - startIndex));
    const expectedText = newElement.textContent;
    
    console.log('[ButtonPanel] Target text at position:', targetText);
    console.log('[ButtonPanel] Expected text:', expectedText);
    
    if (targetText.toLowerCase() !== expectedText.toLowerCase()) {
      console.warn('[ButtonPanel] Text mismatch at position. Expected:', expectedText, 'Found:', targetText);
      // Continue anyway, as the text might have slight differences (case, whitespace)
    }

    // Split the text node if necessary
    const beforeText = targetNode.textContent.substring(0, targetStart);
    const afterText = targetNode.textContent.substring(targetStart + (endIndex - startIndex));

    // Create new text nodes
    if (beforeText) {
      const beforeNode = document.createTextNode(beforeText);
      targetNode.parentNode.insertBefore(beforeNode, targetNode);
    }

    // Insert the new element
    targetNode.parentNode.insertBefore(newElement, targetNode);

    if (afterText) {
      const afterNode = document.createTextNode(afterText);
      targetNode.parentNode.insertBefore(afterNode, targetNode);
    }

    // Remove the original node
    targetNode.remove();
    
    console.log('[ButtonPanel] Successfully replaced text at position', startIndex, '-', endIndex);
  },

  /**
   * Clean up analysis data when content is removed
   * @param {Object} content - The content object being removed
   */
  cleanupAnalysisData(content) {
    if (!content || !content.analysis) {
      console.log('[ButtonPanel] No analysis data to clean up for content:', content?.tabId);
      return;
    }

    console.log('[ButtonPanel] Cleaning up analysis data for content:', content.tabId);

    // Clean up word meanings
    if (content.analysis.wordMeanings && content.analysis.wordMeanings.length > 0) {
      console.log('[ButtonPanel] Cleaning up', content.analysis.wordMeanings.length, 'word meanings');
      content.analysis.wordMeanings.forEach(wordData => {
        // Remove from WordSelector if it exists
        if (WordSelector.explainedWords.has(wordData.normalizedWord)) {
          WordSelector.explainedWords.delete(wordData.normalizedWord);
          console.log('[ButtonPanel] Cleaned up word explanation for:', wordData.word);
        }
      });
    }

    // Clean up simplified texts
    if (content.analysis.simplifiedMeanings && content.analysis.simplifiedMeanings.length > 0) {
      console.log('[ButtonPanel] Cleaning up', content.analysis.simplifiedMeanings.length, 'simplified texts');
      content.analysis.simplifiedMeanings.forEach(simplifiedData => {
        // Remove from TextSelector if it exists
        if (TextSelector.simplifiedTexts.has(simplifiedData.textKey)) {
          TextSelector.simplifiedTexts.delete(simplifiedData.textKey);
          console.log('[ButtonPanel] Cleaned up simplified text for textKey:', simplifiedData.textKey);
        }
        
        // Remove visual elements from DOM
        this.removeSimplifiedTextHighlights(simplifiedData.textKey);
      });
    }

    // Clean up chats
    if (content.analysis.chats && content.analysis.chats.length > 0) {
      console.log('[ButtonPanel] Cleaning up', content.analysis.chats.length, 'chats');
      content.analysis.chats.forEach(chatData => {
        // Remove from ChatDialog if it exists
        if (ChatDialog.chatHistories.has(chatData.textKey)) {
          ChatDialog.chatHistories.delete(chatData.textKey);
          console.log('[ButtonPanel] Cleaned up chat history for textKey:', chatData.textKey);
        }
      });
    }

    console.log('[ButtonPanel] Analysis data cleanup complete');
  },

  /**
   * Remove simplified text highlights from DOM
   * @param {string} textKey - The text key to remove highlights for
   */
  removeSimplifiedTextHighlights(textKey) {
    console.log('[ButtonPanel] Removing simplified text highlights for textKey:', textKey);
    
    // Find all simplified text highlights with this textKey
    const contentElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-editor-content');
    if (!contentElement) {
      console.log('[ButtonPanel] Content element not found');
      return;
    }
    
    // Find all simplified text highlights
    const simplifiedHighlights = contentElement.querySelectorAll('.vocab-text-highlight');
    simplifiedHighlights.forEach(highlight => {
      const highlightTextKey = highlight.getAttribute('data-text-key');
      if (highlightTextKey === textKey) {
        console.log('[ButtonPanel] Removing simplified text highlight for textKey:', textKey);
        
        // Remove the book icon button if it exists
        const bookButton = highlight.querySelector('.vocab-simplified-text-btn');
        if (bookButton) {
          bookButton.remove();
        }
        
        // Replace the highlight span with plain text
        const parent = highlight.parentNode;
        if (parent) {
          parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
          parent.normalize();
        }
      }
    });
    
    // Also remove explanations from the explainedText container if chat dialog is open
    this.removeSimplifiedTextExplanations(textKey);
    
    console.log('[ButtonPanel] Simplified text highlights removal complete');
  },

  /**
   * Remove simplified text explanations from explainedText container
   * @param {string} textKey - The text key to remove explanations for
   */
  removeSimplifiedTextExplanations(textKey) {
    console.log('[ButtonPanel] Removing simplified text explanations for textKey:', textKey);
    
    // Find the simplified explanations container in chat dialog
    const explanationsContainer = document.getElementById('vocab-chat-simplified-container');
    if (!explanationsContainer) {
      console.log('[ButtonPanel] Explanations container not found (chat dialog may not be open)');
      return;
    }
    
    // Find all explanation elements with this textKey
    // Use safe method to avoid CSS selector syntax errors with quotes in textKey
    const allElements = explanationsContainer.querySelectorAll('[data-text-key]');
    const explanationElements = Array.from(allElements).filter(el => el.getAttribute('data-text-key') === textKey);
    explanationElements.forEach(element => {
      console.log('[ButtonPanel] Removing explanation element for textKey:', textKey);
      element.remove();
    });
    
    // If no explanations left, hide the container
    const remainingExplanations = explanationsContainer.querySelectorAll('[data-text-key]');
    if (remainingExplanations.length === 0) {
      explanationsContainer.style.display = 'none';
      console.log('[ButtonPanel] No explanations left, hiding container');
    }
    
    console.log('[ButtonPanel] Simplified text explanations removal complete');
  },

  /**
   * Close a tab
   * @param {string} tabId - The tab ID to close
   */
  closeTab(tabId) {
    console.log('[ButtonPanel] Closing tab:', tabId);
    
    // Get the content type of the tab being closed BEFORE removing it
    const contentToClose = this.topicsModal.customContentModal.getContentByTabId(parseInt(tabId));
    if (!contentToClose) {
      console.log('[ButtonPanel] Content not found for tabId:', tabId);
      return;
    }
    
    const contentTypeToClose = contentToClose.contentType;
    console.log('[ButtonPanel] Closing tab of content type:', contentTypeToClose);
    
    // Remove content from new data structure using tabId
    const removedContent = this.topicsModal.customContentModal.removeContentByTabId(parseInt(tabId));
    console.log('[ButtonPanel] Content removed:', removedContent);
    
    if (!removedContent) return;
    
    // Clean up analysis data for this tab
    this.cleanupAnalysisData(removedContent);
    
    // Remove tab element from DOM
    const tabElement = this.topicsModal.customContentModal.modal.querySelector(`[data-tab-id="${tabId}"]`);
    if (tabElement) {
      tabElement.remove();
      console.log('[ButtonPanel] Tab element removed from DOM');
    }
    
    // Check if there are any tabs left at all (across all content types)
    const allTabs = this.topicsModal.customContentModal.getAllTabs();
    
    // Also check DOM to ensure sync
    const visibleTabs = this.topicsModal.customContentModal.modal.querySelectorAll('.vocab-custom-content-tab');
    
    console.log('[ButtonPanel] ===== TAB CLOSING DEBUG INFO =====');
    console.log('[ButtonPanel] Tab being closed ID:', tabId);
    console.log('[ButtonPanel] Content type being closed:', contentTypeToClose);
    console.log('[ButtonPanel] Active tab ID:', this.topicsModal.customContentModal.activeTabId);
    console.log('[ButtonPanel] Total remaining tabs (data):', allTabs.length);
    console.log('[ButtonPanel] Total remaining tabs (DOM):', visibleTabs.length);
    console.log('[ButtonPanel] All remaining tabs:', allTabs);
    console.log('[ButtonPanel] Topic contents:', this.topicsModal.customContentModal.topicContents);
    console.log('[ButtonPanel] Image contents:', this.topicsModal.customContentModal.imageContents);
    console.log('[ButtonPanel] PDF contents:', this.topicsModal.customContentModal.pdfContents);
    console.log('[ButtonPanel] Text contents:', this.topicsModal.customContentModal.textContents);
    
    // Check if this is the last tab (no tabs remaining in data OR DOM)
    const isLastTab = allTabs.length === 0 || visibleTabs.length === 0;
    
    if (isLastTab) {
      console.log('[ButtonPanel] ===== LAST TAB - CLOSING MODAL =====');
      console.log('[ButtonPanel] No tabs remaining, closing modal');
      console.log('[ButtonPanel] Calling clearTopicsModalInputs()');
      this.clearTopicsModalInputs();
      console.log('[ButtonPanel] Modal close sequence completed (custom content modal removed)');
    } else if (this.topicsModal.customContentModal.activeTabId === tabId) {
      // Only handle active tab switching if we're not closing the modal
      console.log('[ButtonPanel] Closing active tab - switching to another tab');
      console.log('[ButtonPanel] Switching to tab ID:', allTabs[0].id);
      if (allTabs.length > 0) {
        this.switchToTab(allTabs[0].id);
      }
    } else {
      console.log('[ButtonPanel] Tab being closed was not active, updating visual selection');
      // Update the visual selection indicator to match the current active tab
      this.updateTabSelectionVisual();
    }
    
    console.log('[ButtonPanel] ===== END TAB CLOSING DEBUG =====');
    
    // Update arrow states after removing tab
    setTimeout(() => {
      this.updateTabArrowStates();
    }, 100);
  },

  /**
   * Update tab selection visual indicator without switching tabs
   */
  updateTabSelectionVisual() {
    console.log('[ButtonPanel] Updating tab selection visual indicator');
    
    const modal = this.topicsModal.customContentModal.modal;
    if (!modal) {
      console.log('[ButtonPanel] Modal not found, cannot update visual selection');
      return;
    }
    
    const tabsContainer = modal.querySelector('.vocab-custom-content-tabs-container');
    if (!tabsContainer) {
      console.log('[ButtonPanel] Tabs container not found, cannot update visual selection');
      return;
    }
    
    const activeTabId = this.topicsModal.customContentModal.activeTabId;
    if (!activeTabId) {
      console.log('[ButtonPanel] No active tab ID, cannot update visual selection');
      return;
    }
    
    // Update sliding background position
    const activeTabElement = tabsContainer.querySelector(`[data-tab-id="${activeTabId}"]`);
    if (activeTabElement) {
      const tabRect = activeTabElement.getBoundingClientRect();
      const containerRect = tabsContainer.getBoundingClientRect();
      const left = tabRect.left - containerRect.left + tabsContainer.scrollLeft;
      const width = tabRect.width;
      tabsContainer.style.setProperty('--sliding-bg-left', `${left}px`);
      tabsContainer.style.setProperty('--sliding-bg-width', `${width}px`);
      console.log('[ButtonPanel] Updated sliding background position:', { left, width });
    } else {
      console.log('[ButtonPanel] Active tab element not found for ID:', activeTabId);
    }
  },

  /**
   * Initialize modal positioning for resize functionality
   * Converts modal from centered positioning to absolute positioning
   * @param {HTMLElement} modal - The modal element to initialize
   */
  initializeModalPositioning(modal) {
    // Wait for modal to be rendered and positioned
    requestAnimationFrame(() => {
      const rect = modal.getBoundingClientRect();
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      
      // Convert from centered positioning to absolute positioning
      modal.style.left = `${centerX - rect.width / 2}px`;
      modal.style.top = `${centerY - rect.height / 2}px`;
      modal.style.transform = 'none';
      
      console.log('[ButtonPanel] Initialized modal positioning for resize functionality');
    });
  },

  /**
   * Create resize handles for the modal
   * @returns {HTMLElement} Container with resize handles
   */
  createResizeHandles() {
    const container = document.createElement('div');
    container.className = 'vocab-custom-content-resize-handles';
    
    // Create handles for all four edges
    const edgePositions = ['top', 'bottom', 'left', 'right'];
    
    edgePositions.forEach(position => {
      const handle = document.createElement('div');
      handle.className = `vocab-custom-content-resize-handle vocab-custom-content-resize-handle-${position}`;
      handle.setAttribute('data-position', position);
      container.appendChild(handle);
    });
    
    // Create handles for all four corners
    const cornerPositions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    
    cornerPositions.forEach(position => {
      const handle = document.createElement('div');
      handle.className = `vocab-custom-content-resize-handle vocab-custom-content-resize-handle-${position}`;
      handle.setAttribute('data-position', position);
      container.appendChild(handle);
    });
    
    return container;
  },

  /**
   * Initialize resize functionality for modal
   * @param {HTMLElement} modal - The modal element to resize
   */
  initModalResize(modal) {
    const handles = modal.querySelectorAll('.vocab-custom-content-resize-handle');
    
    handles.forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const position = handle.getAttribute('data-position');
        const startX = e.clientX;
        const startY = e.clientY;
        // Get current modal dimensions and position using getBoundingClientRect for accuracy
        const rect = modal.getBoundingClientRect();
        const startWidth = rect.width;
        const startHeight = rect.height;
        const startLeft = rect.left;
        const startTop = rect.top;
        
        // Modal should already be in absolute positioning mode
        const computedStyle = window.getComputedStyle(modal);
        let actualStartLeft = parseFloat(computedStyle.left) || startLeft;
        let actualStartTop = parseFloat(computedStyle.top) || startTop;
        
        const handleMouseMove = (e) => {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = actualStartLeft;
        let newTop = actualStartTop;
        
          // Calculate new dimensions based on position with proportional scaling
          switch (position) {
            case 'right':
              newWidth = startWidth + deltaX;
              break;
            case 'left':
              newWidth = startWidth - deltaX;
              newLeft = actualStartLeft + deltaX;
              break;
            case 'bottom':
              newHeight = startHeight + deltaY;
              break;
            case 'top':
              newHeight = startHeight - deltaY;
              newTop = actualStartTop + deltaY;
              break;
            case 'top-right':
              newWidth = startWidth + deltaX;
              newHeight = startHeight - deltaY;
              newTop = actualStartTop + deltaY;
              break;
            case 'top-left':
              newWidth = startWidth - deltaX;
              newHeight = startHeight - deltaY;
              newLeft = actualStartLeft + deltaX;
              newTop = actualStartTop + deltaY;
              break;
            case 'bottom-right':
              newWidth = startWidth + deltaX;
              newHeight = startHeight + deltaY;
              break;
            case 'bottom-left':
              newWidth = startWidth - deltaX;
              newHeight = startHeight + deltaY;
              newLeft = actualStartLeft + deltaX;
              break;
          }
        
          // Apply viewport constraints with better proportions and resistance
        const minWidth = 400;
        const minHeight = 300;
          const maxWidth = Math.min(900, window.innerWidth - 40); // Respect CSS max-width and viewport
          const maxHeight = Math.min(window.innerHeight * 0.9, window.innerHeight - 40); // Respect CSS max-height
        
          // Add resistance when approaching limits for smoother feel
          const resistanceFactor = 0.3; // How much resistance to apply near limits
          
          // Apply resistance to width
          if (newWidth < minWidth + 50) {
            const resistance = (minWidth + 50 - newWidth) * resistanceFactor;
            newWidth = Math.max(minWidth, newWidth + resistance);
          } else if (newWidth > maxWidth - 50) {
            const resistance = (newWidth - (maxWidth - 50)) * resistanceFactor;
            newWidth = Math.min(maxWidth, newWidth - resistance);
          }
          
          // Apply resistance to height
          if (newHeight < minHeight + 50) {
            const resistance = (minHeight + 50 - newHeight) * resistanceFactor;
            newHeight = Math.max(minHeight, newHeight + resistance);
          } else if (newHeight > maxHeight - 50) {
            const resistance = (newHeight - (maxHeight - 50)) * resistanceFactor;
            newHeight = Math.min(maxHeight, newHeight - resistance);
          }
        
          // Final constraint check
        newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
        newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
        
          // Constrain position to keep modal within viewport
          const maxLeft = window.innerWidth - newWidth;
          const maxTop = window.innerHeight - newHeight;
          
          newLeft = Math.max(0, Math.min(maxLeft, newLeft));
          newTop = Math.max(0, Math.min(maxTop, newTop));
          
          // Apply new dimensions with smooth transitions
        modal.style.width = `${newWidth}px`;
        modal.style.height = `${newHeight}px`;
        modal.style.left = `${newLeft}px`;
        modal.style.top = `${newTop}px`;
      };
      
      const handleMouseUp = () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
      };
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
        document.body.style.cursor = handle.style.cursor;
        document.body.style.userSelect = 'none';
      });
    });
  },

  /**
   * Clear topics modal inputs
   */
  clearTopicsModalInputs() {
    console.log('[ButtonPanel] Clearing topics modal inputs');
    
    // Check if topics modal exists before trying to clear it
    if (!this.topicsModal.modal) {
      console.log('[ButtonPanel] Topics modal does not exist, skipping clearTopicsModalInputs');
      return;
    }
    
    // Clear topics array
    this.topicsModal.topics = [];
    this.topicsModal.wordCount = 100;
    this.topicsModal.difficulty = 'hard';
    
    // Clear UI elements
    const topicsContainer = this.topicsModal.modal?.querySelector('.vocab-topics-tags');
    const inputField = this.topicsModal.modal?.querySelector('.vocab-topics-input');
    const wordCountButtons = this.topicsModal.modal?.querySelectorAll('.vocab-topics-word-count-btn');
    const difficultyButtons = this.topicsModal.modal?.querySelectorAll('.vocab-topics-difficulty-btn');
    
    if (topicsContainer) {
      topicsContainer.innerHTML = '';
    }
    
    if (inputField) {
      inputField.value = '';
    }
    
    // Reset word count buttons
    if (wordCountButtons) {
      wordCountButtons.forEach(btn => {
        btn.classList.remove('selected');
        if (btn.getAttribute('data-count') === '100') {
          btn.classList.add('selected');
        }
      });
    }
    
    // Reset difficulty buttons
    if (difficultyButtons) {
      difficultyButtons.forEach(btn => {
        btn.classList.remove('selected');
        if (btn.getAttribute('data-difficulty') === 'hard') {
          btn.classList.add('selected');
        }
      });
    }
    
    this.updateTopicsUIState();
  },

  /**
   * Scroll tabs left or right
   * @param {string} direction - 'left' or 'right'
   */
  scrollTabs(direction) {
    const tabsContainer = this.topicsModal.customContentModal.tabsContainer;
    if (!tabsContainer) {
      console.warn('[ButtonPanel] tabsContainer not found, skipping scroll');
      return;
    }
    
    const scrollAmount = 200; // pixels to scroll
    
    if (direction === 'left') {
      tabsContainer.scrollLeft -= scrollAmount;
    } else {
      tabsContainer.scrollLeft += scrollAmount;
    }
    
    // Update arrow states after scrolling
    setTimeout(() => {
      this.updateTabArrowStates();
    }, 100);
  },

  /**
   * Update tab arrow states based on scroll position
   */
  updateTabArrowStates() {
    console.log('[ButtonPanel] updateTabArrowStates called');
    const tabsContainer = this.topicsModal.customContentModal.tabsContainer;
    const leftArrow = this.topicsModal.customContentModal.leftArrow;
    const rightArrow = this.topicsModal.customContentModal.rightArrow;
    
    console.log('[ButtonPanel] tabsContainer in updateTabArrowStates:', tabsContainer);
    console.log('[ButtonPanel] leftArrow:', leftArrow);
    console.log('[ButtonPanel] rightArrow:', rightArrow);
    
    if (!tabsContainer || !leftArrow || !rightArrow) {
      console.log('[ButtonPanel] Missing elements in updateTabArrowStates, returning early');
      return;
    }
    
    const isAtStart = tabsContainer.scrollLeft <= 0;
    const isAtEnd = tabsContainer.scrollLeft >= (tabsContainer.scrollWidth - tabsContainer.clientWidth);
    
    leftArrow.disabled = isAtStart;
    rightArrow.disabled = isAtEnd;
  },

  /**
   * Initialize drag functionality for modal
   * @param {HTMLElement} dragHandle - The drag handle element
   * @param {HTMLElement} modal - The modal element to drag
   */
  initModalDrag(dragHandle, modal) {
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let initialLeft = 0;
    let initialTop = 0;

    const handleMouseDown = (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      
      // Get current position
      const rect = modal.getBoundingClientRect();
      initialLeft = rect.left;
      initialTop = rect.top;
      
      // Change cursor
      dragHandle.style.cursor = 'grabbing';
      modal.style.cursor = 'grabbing';
      
      e.preventDefault();
    };

    const handleMouseMove = (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      const newLeft = initialLeft + deltaX;
      const newTop = initialTop + deltaY;
      
      // Apply constraints to keep modal within viewport
      const maxLeft = window.innerWidth - modal.offsetWidth;
      const maxTop = window.innerHeight - modal.offsetHeight;
      
      const constrainedLeft = Math.max(0, Math.min(maxLeft, newLeft));
      const constrainedTop = Math.max(0, Math.min(maxTop, newTop));
      
      modal.style.left = `${constrainedLeft}px`;
      modal.style.top = `${constrainedTop}px`;
      modal.style.right = 'auto';
      modal.style.transform = 'none';
    };

    const handleMouseUp = () => {
      if (isDragging) {
        isDragging = false;
        dragHandle.style.cursor = 'grab';
        modal.style.cursor = 'default';
      }
    };

    // Add event listeners
    dragHandle.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    // Touch events for mobile
    dragHandle.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      handleMouseDown({
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => e.preventDefault()
      });
    });
    
    document.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      handleMouseMove({
        clientX: touch.clientX,
        clientY: touch.clientY
      });
    });
    
    document.addEventListener('touchend', handleMouseUp);
  },

  /**
   * Update custom content heading based on content type
   * @param {string} contentType - The content type ('pdf', 'image', 'topic')
   */
  updateCustomContentHeading(contentType) {
    const title = this.topicsModal.customContentModal.modal?.querySelector('.vocab-custom-content-title');
    if (title) {
      const headingMap = {
        'pdf': 'PDF Content',
        'image': 'Image content', 
        'topic': 'Topic content',
        'text': 'Content',
        'default': 'Generated Content'
      };
      
      title.textContent = headingMap[contentType] || headingMap['default'];
    }
  },

  /**
   * Update custom content editor with content
   * @param {string} content - The content to display
   */
  updateCustomContentEditor(content) {
    console.log('[ButtonPanel] ===== UPDATING CUSTOM CONTENT EDITOR =====');
    
    const editorContent = this.topicsModal.customContentModal.editorContent;
    
    if (!editorContent) {
      console.error('[ButtonPanel] ===== EDITOR CONTENT ELEMENT NOT FOUND =====');
      return;
    }
    
    console.log('[ButtonPanel] Editor content element found:', !!editorContent);
    console.log('[ButtonPanel] Content to load:', content.substring(0, 100) + '...');
    
    // Enhanced markdown detection - check for various markdown patterns
    const hasMarkdownFormatting = /^#+\s|\*\*[^*]+\*\*|\*[^*]+\*|^```|^`|^\- |^\d+\. |^\+ |^● /m.test(content);
    
    console.log('[ButtonPanel] Markdown detection result:', hasMarkdownFormatting);
    console.log('[ButtonPanel] Content sample for detection:', content.substring(0, 200));
    
    let htmlContent;
    
    if (hasMarkdownFormatting) {
      console.log('[ButtonPanel] Content appears to have markdown formatting, converting to HTML');
      
      // Use a more robust markdown renderer
      htmlContent = this.renderMarkdownToHtml(content);
    } else {
      console.log('[ButtonPanel] Content appears to be plain text, displaying as-is');
      // For plain text, just escape HTML and preserve line breaks
      htmlContent = content
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/\n/g, '<br>');
      
      // Wrap in a single paragraph to maintain proper spacing
      htmlContent = '<p>' + htmlContent + '</p>';
    }
    
    console.log('[ButtonPanel] HTML content generated, length:', htmlContent.length);
    console.log('[ButtonPanel] HTML preview:', htmlContent.substring(0, 200) + '...');
    
    editorContent.innerHTML = htmlContent;
    
    console.log('[ButtonPanel] ===== EDITOR CONTENT UPDATED SUCCESSFULLY =====');
  },

  /**
   * Enhanced markdown to HTML renderer
   * @param {string} markdown - Markdown text to convert
   * @returns {string} HTML string
   */
  renderMarkdownToHtml(markdown) {
    if (!markdown) return '';
    
    console.log('[ButtonPanel] renderMarkdownToHtml called with:', markdown.substring(0, 200) + '...');
    
    let html = markdown;
    
    // Escape HTML first to prevent XSS
    html = html.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;');
    
    // Code blocks (```)
    html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
    
    // Inline code (`)
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Bold (**text** or __text__) - handle both patterns
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    
    console.log('[ButtonPanel] After bold processing:', html.substring(0, 300) + '...');
    
    // Debug bullet processing
    const bulletMatches = html.match(/^[\s]*[\*\-+●] (.+)$/gm);
    if (bulletMatches) {
      console.log('[ButtonPanel] Found bullet points:', bulletMatches);
    }
    
    // Italic (*text* or _text_) - but not if it's part of bold
    html = html.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
    html = html.replace(/(?<!_)_([^_]+)_(?!_)/g, '<em>$1</em>');
    
    // Links [text](url)
    html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    
    // Headings (process from largest to smallest to avoid conflicts)
    html = html.replace(/^###### (.+)$/gm, '<h6>$1</h6>');
    html = html.replace(/^##### (.+)$/gm, '<h5>$1</h5>');
    html = html.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
    html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
    
    // Lists - handle unordered lists (*, -, +, ●)
    html = html.replace(/^[\s]*[\*\-+●] (.+)$/gm, (match, content) => {
      // Clean up extra spaces in bullet content
      const cleanedContent = content.trim().replace(/\s+/g, ' ');
      return `<li>${cleanedContent}</li>`;
    });
    
    // Ordered lists (1., 2., etc.)
    html = html.replace(/^[\s]*\d+\. (.+)$/gm, (match, content) => {
      // Clean up extra spaces in ordered list content
      const cleanedContent = content.trim().replace(/\s+/g, ' ');
      return `<li>${cleanedContent}</li>`;
    });
    
    console.log('[ButtonPanel] After bullet processing:', html.substring(0, 400) + '...');
    
    // Debug ordered list detection
    const orderedMatches = markdown.match(/^\s*\d+\./gm);
    if (orderedMatches) {
      console.log('[ButtonPanel] Found ordered list items:', orderedMatches);
    }
    
    // Wrap consecutive <li> elements in <ul> or <ol>
    // First, identify ordered vs unordered lists by checking original markdown
    const originalLines = markdown.split('\n');
    const lines = html.split('\n');
    let processedLines = [];
    let inList = false;
    let listType = 'ul';
    let listItems = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isListItem = line.includes('<li>');
      
      // Check if this line was originally an ordered list item
      const originalLine = originalLines[i] || '';
      const isOrderedListItem = isListItem && /^\s*\d+\./.test(originalLine);
      
      if (isListItem) {
        if (!inList) {
          inList = true;
          listType = isOrderedListItem ? 'ol' : 'ul';
          console.log('[ButtonPanel] Starting list type:', listType, 'for line:', originalLine);
          listItems = [];
        }
        listItems.push(line);
      } else {
        if (inList) {
          // Close the current list
          processedLines.push(`<${listType}>`);
          processedLines.push(...listItems);
          processedLines.push(`</${listType}>`);
          inList = false;
          listItems = [];
        }
        processedLines.push(line);
      }
    }
    
    // Handle case where list is at the end
    if (inList) {
      processedLines.push(`<${listType}>`);
      processedLines.push(...listItems);
      processedLines.push(`</${listType}>`);
    }
    
    html = processedLines.join('\n');
    
    // Convert line breaks
    html = html.replace(/\n\n/g, '</p><p>');
    html = html.replace(/\n/g, '<br>');
    
    // Wrap in paragraphs
    html = '<p>' + html + '</p>';
    
    // Clean up empty paragraphs and fix paragraph structure
    html = html.replace(/<p><\/p>/g, '');
    html = html.replace(/<p><br><\/p>/g, '');
    html = html.replace(/<p>\s*<\/p>/g, '');
    
    // Fix paragraphs that contain only whitespace
    html = html.replace(/<p>\s*<br>\s*<\/p>/g, '');
    
    return html;
  },

  /**
   * Update custom content modal title based on content type
   * @param {string} contentType - The type of content (pdf, image, etc.)
   */
  updateCustomContentModalTitle(contentType) {
    console.log('[ButtonPanel] ===== UPDATING CUSTOM CONTENT MODAL TITLE =====');
    console.log('[ButtonPanel] Content type:', contentType);
    
    const titleElement = this.topicsModal.customContentModal.modal.querySelector('.vocab-custom-content-title');
    
    if (!titleElement) {
      console.error('[ButtonPanel] Title element not found');
      return;
    }
    
    // Set heading based on content type
    const headingMap = {
      'pdf': 'PDF Content',
      'image': 'Image content', 
      'topic': 'Topic content',
      'text': 'Content',
      'default': 'Generated Content'
    };
    
    titleElement.textContent = headingMap[contentType] || headingMap['default'];
    console.log('[ButtonPanel] Title updated to:', titleElement.textContent);
    
    console.log('[ButtonPanel] ===== MODAL TITLE UPDATED SUCCESSFULLY =====');
  },

  /**
   * Perform search in the content
   */
  performSearch() {
    console.log('[ButtonPanel] performSearch called');
    
    // Get search term from current active tab
    let searchTerm = '';
    if (this.topicsModal.customContentModal.activeTabId) {
      const tabId = parseInt(this.topicsModal.customContentModal.activeTabId);
      const activeContent = this.topicsModal.customContentModal.getContentByTabId(tabId);
      if (activeContent) {
        searchTerm = activeContent.searchTerm || '';
      }
    }
    
    const editorContent = this.topicsModal.customContentModal.editorContent;
    
    console.log('[ButtonPanel] Search term:', JSON.stringify(searchTerm));
    console.log('[ButtonPanel] Editor content element:', editorContent);
    console.log('[ButtonPanel] Active tab ID:', this.topicsModal.customContentModal.activeTabId);
    
    if (!editorContent) {
      console.error('[ButtonPanel] Editor content element not found!');
      return;
    }
    
    if (!searchTerm || !searchTerm.trim()) {
      console.log('[ButtonPanel] No search term, removing highlights');
      // Remove all highlights
      const highlights = editorContent.querySelectorAll('.vocab-search-highlight');
      highlights.forEach(highlight => {
        const parent = highlight.parentNode;
        parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
        parent.normalize();
      });
      return;
    }
    
    // Get the original content without highlights
    let content = editorContent.innerHTML;
    console.log('[ButtonPanel] Original content length:', content.length);
    console.log('[ButtonPanel] Content preview:', content.substring(0, 200));
    
    // Remove existing highlights
    content = content.replace(/<span class="vocab-search-highlight">(.*?)<\/span>/gim, '$1');
    
    // Add new highlights
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gim');
    const matches = content.match(regex);
    console.log('[ButtonPanel] Found matches:', matches ? matches.length : 0);
    
    content = content.replace(regex, '<span class="vocab-search-highlight">$1</span>');
    
    console.log('[ButtonPanel] Updated content with highlights');
    editorContent.innerHTML = content;
    
    // Auto-scroll to first match if it's outside visible area
    this.scrollToFirstMatch(editorContent, searchTerm);
  },

  /**
   * Scroll to the first search match if it's outside the visible area
   * @param {HTMLElement} editorContent - The editor content element
   * @param {string} searchTerm - The search term
   */
  scrollToFirstMatch(editorContent, searchTerm) {
    const firstHighlight = editorContent.querySelector('.vocab-search-highlight');
    if (!firstHighlight) {
      console.log('[ButtonPanel] No search highlights found');
      return;
    }
    
    // Get the editor container (the scrollable element)
    const editorContainer = editorContent.closest('.vocab-custom-content-editor');
    if (!editorContainer) {
      console.log('[ButtonPanel] Editor container not found');
      return;
    }
    
    // Get the bounding rectangles
    const highlightRect = firstHighlight.getBoundingClientRect();
    const containerRect = editorContainer.getBoundingClientRect();
    
    // Check if the highlight is outside the visible area
    const isAboveVisible = highlightRect.top < containerRect.top;
    const isBelowVisible = highlightRect.bottom > containerRect.bottom;
    
    if (isAboveVisible || isBelowVisible) {
      console.log('[ButtonPanel] First match is outside visible area, scrolling to it');
      
      // Calculate the scroll position to center the highlight
      const containerScrollTop = editorContainer.scrollTop;
      const highlightOffsetTop = firstHighlight.offsetTop;
      const containerHeight = editorContainer.clientHeight;
      const highlightHeight = firstHighlight.offsetHeight;
      
      // Center the highlight in the visible area
      const targetScrollTop = highlightOffsetTop - (containerHeight / 2) + (highlightHeight / 2);
      
      // Smooth scroll to the target position
      editorContainer.scrollTo({
        top: Math.max(0, targetScrollTop),
        behavior: 'smooth'
      });
    } else {
      console.log('[ButtonPanel] First match is already visible');
    }
  },

  /**
   * Initialize slider positions
   */
  initializeSliders() {
    // Initialize word count slider
    const wordCountSelected = this.topicsModal.modal.querySelector('.vocab-topics-word-count-btn.selected');
    if (wordCountSelected) {
      this.animateSlider('word-count-slider', wordCountSelected);
    }
    
    // Initialize difficulty slider
    const difficultySelected = this.topicsModal.modal.querySelector('.vocab-topics-difficulty-btn.selected');
    if (difficultySelected) {
      this.animateSlider('difficulty-slider', difficultySelected);
      this.updateDifficultySliderColor(difficultySelected);
    }
  },

  /**
   * Animate slider to selected tab
   * @param {string} sliderId - ID of the slider element
   * @param {HTMLElement} selectedButton - The selected button element
   */
  animateSlider(sliderId, selectedButton) {
    const slider = document.getElementById(sliderId);
    if (!slider || !selectedButton) return;
    
    // Use requestAnimationFrame to ensure smooth animation
    requestAnimationFrame(() => {
      const buttonRect = selectedButton.getBoundingClientRect();
      const containerRect = selectedButton.parentElement.getBoundingClientRect();
      
      const left = buttonRect.left - containerRect.left;
      const width = buttonRect.width;
      
      slider.style.left = `${left}px`;
      slider.style.width = `${width}px`;
    });
  },

  /**
   * Update difficulty slider color based on selected difficulty
   * @param {HTMLElement} selectedButton - The selected difficulty button
   */
  updateDifficultySliderColor(selectedButton) {
    const slider = document.getElementById('difficulty-slider');
    if (!slider) return;
    
    const difficulty = selectedButton.getAttribute('data-difficulty');
    switch (difficulty) {
      case 'easy':
        slider.style.background = '#36D86B';
        break;
      case 'medium':
        slider.style.background = '#F9D43F';
        break;
      case 'hard':
        slider.style.background = '#FF4D4D';
        break;
    }
  },

  /**
   * Create plus icon SVG
   * @returns {string} SVG markup
   */
  createPlusIcon() {
    return `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 3V13M3 8H13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  },

  /**
   * Initialize modal dragging functionality
   * @param {HTMLElement} modal - The modal element to make draggable
   */
  initModalDragging(modal) {
    let isDragging = false;
    let startX, startY, initialX, initialY;
    
    // Function to check if the clicked element should allow dragging
    const isDraggableElement = (element) => {
      // Explicitly allow dragging on the header (but not on its interactive children)
      if (element.classList && element.classList.contains('word-web-search-modal-header')) {
        return true;
      }
      
      // Check if the element is a child of the header (but not an interactive element)
      let currentElement = element;
      while (currentElement && currentElement !== modal) {
        if (currentElement.classList && currentElement.classList.contains('word-web-search-modal-header')) {
          // We're inside the header, check if the clicked element itself is interactive
          const tagName = element.tagName?.toLowerCase();
          if (tagName && ['input', 'button', 'textarea', 'a', 'select'].includes(tagName)) {
            return false;
          }
          // If it's the close button or other interactive elements, don't drag
          if (element.classList && (
            element.classList.contains('word-web-search-modal-close') ||
            element.classList.contains('word-web-search-send-btn') ||
            element.classList.contains('word-web-search-delete-btn')
          )) {
            return false;
          }
          // Otherwise, allow dragging from header
          return true;
        }
        currentElement = currentElement.parentElement;
      }
      
      // Don't drag if clicking on interactive elements
      const nonDraggableSelectors = [
        'input',
        'button',
        'textarea',
        'a',
        'select',
        '.vocab-custom-content-tab-arrow',
        '.vocab-custom-content-add-tab',
        '.vocab-custom-content-minimize',
        '.vocab-custom-content-chat-icon',
        '.vocab-custom-content-resize-handle',
        '.vocab-custom-content-editor-content',
        '.vocab-custom-content-tab',
        // Word ask AI modal specific non-draggable elements
        '.word-web-search-input',
        '.word-web-search-send-btn',
        '.word-web-search-delete-btn',
        '.word-web-search-modal-close',
        '.word-web-search-results', // Chat container - not draggable
        '.word-web-search-results-list', // Chat messages list - not draggable
        '.word-web-search-input-area', // Input area - not draggable
        '.word-web-search-chat-message', // Chat messages - not draggable
        '.word-web-search-chat-response-text' // Chat response text - not draggable
      ];
      
      // Check if the element or any of its parents match non-draggable selectors
      currentElement = element;
      while (currentElement && currentElement !== modal) {
        // Check if it's an interactive element by tag name
        const tagName = currentElement.tagName?.toLowerCase();
        if (tagName && ['input', 'button', 'textarea', 'a', 'select'].includes(tagName)) {
          return false;
        }
        
        // Check if it matches any non-draggable selectors
        for (const selector of nonDraggableSelectors) {
          if (currentElement.matches && currentElement.matches(selector)) {
            return false;
          }
        }
        currentElement = currentElement.parentElement;
      }
      
      return true;
    };
    
    // Mouse down event
    modal.addEventListener('mousedown', (e) => {
      console.log('[WordSelector] Mouse down on modal, target:', e.target, 'isDraggable:', isDraggableElement(e.target));
      
      if (!isDraggableElement(e.target)) {
        console.log('[WordSelector] Element is not draggable, returning');
        return;
      }
      
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      
      // Get current modal position - always use getBoundingClientRect for accuracy
      const rect = modal.getBoundingClientRect();
      // Convert viewport coordinates to document coordinates
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      initialX = rect.left;
      initialY = rect.top;
      
      console.log('[WordSelector] Drag started:', {
        startX,
        startY,
        initialX,
        initialY,
        scrollX,
        scrollY,
        rectLeft: rect.left,
        rectTop: rect.top
      });
      
      // Clear any transform and ensure we're using absolute positioning
      // Remove transition during drag for smooth movement
      modal.style.setProperty('transition', 'none', 'important');
      modal.style.setProperty('transform', 'none', 'important');
      
      // Ensure we have absolute positioning with document coordinates
      modal.style.setProperty('position', 'absolute', 'important');
      const docLeft = initialX + scrollX;
      const docTop = initialY + scrollY;
      modal.style.setProperty('left', `${docLeft}px`, 'important');
      modal.style.setProperty('top', `${docTop}px`, 'important');
      
      console.log('[WordSelector] Set initial position:', { docLeft, docTop });
      
      // Mark modal as being dragged to prevent repositionModal from interfering
      modal.setAttribute('data-is-dragging', 'true');
      
      // Add dragging class for visual feedback
      modal.classList.add('dragging');
      
      // Prevent text selection during drag
      e.preventDefault();
      e.stopPropagation();
    });
    
    // Mouse move event
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      const newX = initialX + deltaX;
      const newY = initialY + deltaY;
      
      // Constrain horizontal position to viewport, but allow vertical to go outside
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      
      // Constrain horizontal position to viewport bounds (viewport coordinates)
      const maxX = window.innerWidth - modal.offsetWidth;
      const constrainedX = Math.max(0, Math.min(newX, maxX));
      
      // Allow vertical position to go outside viewport (no constraint)
      const constrainedY = newY;
      
      // Convert to document coordinates
      const finalX = constrainedX + scrollX;
      const finalY = constrainedY + scrollY;
      
      console.log('[WordSelector] Dragging:', {
        deltaX,
        deltaY,
        newX,
        newY,
        constrainedX,
        constrainedY,
        finalX,
        finalY,
        scrollX,
        scrollY
      });
      
      // Remove transform and set absolute positioning (document coordinates)
      // Disable transition during drag for smooth movement
      modal.style.setProperty('transition', 'none', 'important');
      modal.style.setProperty('transform', 'none', 'important');
      modal.style.setProperty('position', 'absolute', 'important');
      modal.style.setProperty('left', `${finalX}px`, 'important');
      modal.style.setProperty('top', `${finalY}px`, 'important');
      
      // Verify the position was set
      const computedLeft = window.getComputedStyle(modal).left;
      const computedTop = window.getComputedStyle(modal).top;
      console.log('[WordSelector] Position set, computed:', { computedLeft, computedTop });
    });
    
    // Mouse up event
    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        modal.classList.remove('dragging');
        // Clear dragging flag to allow repositionModal to work again
        modal.removeAttribute('data-is-dragging');
        // Re-enable transition after dragging
        modal.style.setProperty('transition', 'opacity 0.2s ease, transform 0.2s ease', 'important');
      }
    });
    
    // Touch events for mobile support
    modal.addEventListener('touchstart', (e) => {
      if (!isDraggableElement(e.target)) {
        return;
      }
      
      isDragging = true;
      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
      
      // Get current modal position - always use getBoundingClientRect for accuracy
      const rect = modal.getBoundingClientRect();
      // Convert viewport coordinates to document coordinates
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      initialX = rect.left;
      initialY = rect.top;
      
      // Clear any transform and ensure we're using absolute positioning
      // Remove transition during drag for smooth movement
      modal.style.setProperty('transition', 'none', 'important');
      modal.style.setProperty('transform', 'none', 'important');
      
      // Ensure we have absolute positioning with document coordinates
      modal.style.setProperty('position', 'absolute', 'important');
      modal.style.setProperty('left', `${initialX + scrollX}px`, 'important');
      modal.style.setProperty('top', `${initialY + scrollY}px`, 'important');
      
      // Mark modal as being dragged to prevent repositionModal from interfering
      modal.setAttribute('data-is-dragging', 'true');
      
      modal.classList.add('dragging');
      e.preventDefault();
      e.stopPropagation();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      
      const touch = e.touches[0];
      const deltaX = touch.clientX - startX;
      const deltaY = touch.clientY - startY;
      
      const newX = initialX + deltaX;
      const newY = initialY + deltaY;
      
      // Constrain horizontal position to viewport, but allow vertical to go outside
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      
      // Constrain horizontal position to viewport bounds (viewport coordinates)
      const maxX = window.innerWidth - modal.offsetWidth;
      const constrainedX = Math.max(0, Math.min(newX, maxX));
      
      // Allow vertical position to go outside viewport (no constraint)
      const constrainedY = newY;
      
      // Convert to document coordinates
      const finalX = constrainedX + scrollX;
      const finalY = constrainedY + scrollY;
      
      // Disable transition during drag for smooth movement
      modal.style.setProperty('transition', 'none', 'important');
      modal.style.setProperty('transform', 'none', 'important');
      modal.style.setProperty('position', 'absolute', 'important');
      modal.style.setProperty('left', `${finalX}px`, 'important');
      modal.style.setProperty('top', `${finalY}px`, 'important');
      
      e.preventDefault();
    });
    
    document.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        modal.classList.remove('dragging');
        // Clear dragging flag to allow repositionModal to work again
        modal.removeAttribute('data-is-dragging');
        // Re-enable transition after dragging
        modal.style.setProperty('transition', 'opacity 0.2s ease, transform 0.2s ease', 'important');
      }
    });
  },

};

// ===================================
// Bookmark Words Dialog - Shows bookmarked words in a table
// ===================================
const BookmarkWordsDialog = {
  dialogContainer: null,
  isOpen: false,
  currentPage: 1,
  itemsPerPage: 10,
  sortBy: 'newest', // 'alphabetical', 'oldest', 'newest' (default: 'newest')
  searchQuery: '',
  allBookmarks: [],
  filteredBookmarks: [],
  wordChatHistories: new Map(), // Store chat history for each word (persist until page reload)
  
  /**
   * Initialize bookmark words dialog
   */
  init() {
    console.log('[BookmarkWordsDialog] Initializing...');
    this.injectStyles();
  },
  
  /**
   * Open bookmark words dialog
   */
  async open() {
    console.log('[BookmarkWordsDialog] Opening...');
    
    if (this.isOpen) {
      console.log('[BookmarkWordsDialog] Already open, closing first');
      this.close();
      return;
    }
    
    // Load bookmarks
    await this.loadBookmarks();
    
    // Create and show dialog
    this.createDialog();
    
    // Load saved width from storage
    await this.loadSavedDimensions();
    
    this.show();
    
    console.log('[BookmarkWordsDialog] Opened');
  },
  
  /**
   * Close bookmark words dialog
   */
  close() {
    console.log('[BookmarkWordsDialog] Closing...');
    
    if (!this.isOpen) {
      return;
    }
    
    if (this.dialogContainer && this.dialogContainer.classList.contains('visible')) {
      // Remove inline transform to allow CSS transition to work
      // The CSS will handle the slide-out animation when we remove the 'visible' class
      this.dialogContainer.style.removeProperty('transform');
      
      // Force reflow to ensure the style change is applied
      void this.dialogContainer.offsetHeight;
      
      // Remove visible class to trigger slide-out animation
      this.dialogContainer.classList.remove('visible');
      setTimeout(() => {
        this.hide();
      }, 300);
    } else {
      this.hide();
    }
    
    console.log('[BookmarkWordsDialog] Closed');
  },
  
  /**
   * Show dialog
   */
  show() {
    if (!this.dialogContainer) return;
    
    this.isOpen = true;
    
    // Force a reflow
    void this.dialogContainer.offsetHeight;
    
    // Add visible class to trigger animation
    this.dialogContainer.classList.add('visible');
  },
  
  /**
   * Hide dialog
   */
  hide() {
    if (!this.dialogContainer) return;
    
    this.dialogContainer.remove();
    this.dialogContainer = null;
    this.isOpen = false;
    this.currentPage = 1;
    this.searchQuery = '';
  },
  
  /**
   * Load bookmarks from storage
   */
  async loadBookmarks() {
    try {
      const bookmarks = await BookmarkWordsService.getAllBookmarks();
      
      // Convert to array format: [{word, meaning, dateTime, url}]
      this.allBookmarks = Object.entries(bookmarks).map(([word, data]) => ({
        word: word,
        meaning: data.meaning || '',
        dateTime: data.dateTime || new Date().toISOString(),
        url: data.url || ''
      }));
      
      console.log('[BookmarkWordsDialog] Loaded', this.allBookmarks.length, 'bookmarks');
      
      // Apply filtering and sorting
      this.applyFilters();
    } catch (error) {
      console.error('[BookmarkWordsDialog] Error loading bookmarks:', error);
      this.allBookmarks = [];
      this.filteredBookmarks = [];
    }
  },
  
  /**
   * Apply search filter and sorting
   */
  applyFilters() {
    // Apply search filter - only search in word, not meaning
    let filtered = this.allBookmarks;
    
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase().trim();
      filtered = filtered.filter(item => 
        item.word.toLowerCase().includes(query)
      );
    }
    
    // Apply sorting
    filtered = [...filtered]; // Create a copy to avoid mutating original
    
    switch (this.sortBy) {
      case 'alphabetical':
        filtered.sort((a, b) => a.word.localeCompare(b.word));
        break;
      case 'oldest':
        filtered.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));
        break;
      case 'newest':
        filtered.sort((a, b) => new Date(b.dateTime) - new Date(a.dateTime));
        break;
    }
    
    this.filteredBookmarks = filtered;
    this.currentPage = 1; // Reset to first page when filters change
    
    // Update display
    this.renderTable();
  },
  
  /**
   * Get paginated bookmarks
   */
  getPaginatedBookmarks() {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    return this.filteredBookmarks.slice(startIndex, endIndex);
  },
  
  /**
   * Get total pages
   */
  getTotalPages() {
    return Math.ceil(this.filteredBookmarks.length / this.itemsPerPage);
  },
  
  /**
   * Create dialog DOM structure
   */
  createDialog() {
    console.log('[BookmarkWordsDialog] Creating dialog...');
    
    // Create main container
    this.dialogContainer = document.createElement('div');
    this.dialogContainer.id = 'vocab-bookmark-words-dialog';
    this.dialogContainer.className = 'vocab-bookmark-words-dialog';
    
    // Create dialog content
    const dialogContent = document.createElement('div');
    dialogContent.className = 'vocab-bookmark-words-content';
    
    // Create left side button container
    const leftButtonContainer = document.createElement('div');
    leftButtonContainer.className = 'vocab-chat-left-buttons';
    
    // Create collapse button
    const collapseBtn = document.createElement('button');
    collapseBtn.className = 'vocab-chat-collapse-btn-small';
    collapseBtn.setAttribute('aria-label', 'Close');
    collapseBtn.innerHTML = ChatDialog.createCollapseIcon();
    collapseBtn.addEventListener('click', () => this.close());
    
    leftButtonContainer.appendChild(collapseBtn);
    
    // Create header
    const header = document.createElement('div');
    header.className = 'vocab-bookmark-words-header';
    header.textContent = 'Bookmarks';
    
    // Create action buttons container (right-aligned flex container)
    const actionButtonsContainer = document.createElement('div');
    actionButtonsContainer.className = 'vocab-bookmark-words-action-buttons';
    
    // Create refresh button
    const refreshButton = document.createElement('button');
    refreshButton.className = 'vocab-bookmark-words-refresh-btn';
    refreshButton.setAttribute('aria-label', 'Reload bookmarks');
    refreshButton.innerHTML = `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="vocab-bookmark-words-refresh-icon">
        <path d="M12 21C7.02944 21 3 16.9706 3 12C3 9.69494 3.86656 7.59227 5.29168 6L8 3M12 3C16.9706 3 21 7.02944 21 12C21 14.3051 20.1334 16.4077 18.7083 18L16 21M3 3H8M8 3V8M21 21H16M16 21V16" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    
    // Add tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'vocab-bookmark-words-refresh-tooltip';
    tooltip.textContent = 'Reload bookmarks';
    refreshButton.appendChild(tooltip);
    
    // Add click handler to reload bookmarks with animation
    refreshButton.addEventListener('click', async () => {
      const icon = refreshButton.querySelector('.vocab-bookmark-words-refresh-icon');
      if (!icon) return;
      
      // Start rotation animation
      refreshButton.classList.add('vocab-bookmark-words-refresh-loading');
      
      // Load bookmarks
      await this.loadBookmarks();
      this.renderTable();
      
      // Stop rotation and show green tick
      refreshButton.classList.remove('vocab-bookmark-words-refresh-loading');
      refreshButton.classList.add('vocab-bookmark-words-refresh-success');
      
      // Show green tick mark
      icon.innerHTML = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M20 6L9 17l-5-5" stroke="#16a34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      
      // After 1 second, show refresh icon again
      setTimeout(() => {
        refreshButton.classList.remove('vocab-bookmark-words-refresh-success');
        icon.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="vocab-bookmark-words-refresh-icon">
            <path d="M12 21C7.02944 21 3 16.9706 3 12C3 9.69494 3.86656 7.59227 5.29168 6L8 3M12 3C16.9706 3 21 7.02944 21 12C21 14.3051 20.1334 16.4077 18.7083 18L16 21M3 3H8M8 3V8M21 21H16M16 21V16" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        `;
      }, 1000);
    });
    
    actionButtonsContainer.appendChild(refreshButton);
    
    // Create controls container (search and sort)
    const controlsContainer = document.createElement('div');
    controlsContainer.className = 'vocab-bookmark-words-controls';
    
    // Create search input
    const searchContainer = document.createElement('div');
    searchContainer.className = 'vocab-bookmark-words-search-container';
    
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.className = 'vocab-bookmark-words-search-input';
    searchInput.placeholder = 'Search words...';
    searchInput.value = this.searchQuery;
    searchInput.addEventListener('input', (e) => {
      this.searchQuery = e.target.value;
      this.applyFilters();
    });
    
    searchContainer.appendChild(searchInput);
    
    controlsContainer.appendChild(searchContainer);
    
    // Create sort dropdown
    const sortDropdownContainer = document.createElement('div');
    sortDropdownContainer.className = 'vocab-bookmark-words-sort-container';
    sortDropdownContainer.style.cssText = `
      position: relative;
      min-width: 180px;
    `;
    
    const sortDropdownWrapper = document.createElement('div');
    sortDropdownWrapper.style.cssText = `
      position: relative;
      width: 100%;
    `;
    
    const sortDropdownInput = document.createElement('input');
    sortDropdownInput.type = 'text';
    sortDropdownInput.className = 'vocab-bookmark-words-sort-input';
    sortDropdownInput.id = 'vocab-bookmark-words-sort-input';
    sortDropdownInput.value = this.sortBy === 'newest' ? 'Newest first' : 
                              this.sortBy === 'oldest' ? 'Oldest first' : 
                              'Alphabetical order';
    sortDropdownInput.readOnly = true;
    sortDropdownInput.style.cssText = `
      width: 100%;
      padding: 10px 45px 10px 16px;
      border: 1.5px solid rgba(149, 39, 245, 0.4);
      border-radius: 13px;
      font-size: 14px;
      font-family: inherit;
      font-weight: 400;
      background-color: white;
      cursor: pointer;
      transition: border-color 0.2s ease;
      box-sizing: border-box;
    `;
    
    const sortDropdownIcon = document.createElement('div');
    sortDropdownIcon.className = 'vocab-bookmark-words-sort-icon';
    sortDropdownIcon.innerHTML = `
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M5 7.5L10 12.5L15 7.5" stroke="#666" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
    sortDropdownIcon.style.cssText = `
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      transition: transform 0.2s ease;
    `;
    
    const sortDropdownList = document.createElement('div');
    sortDropdownList.className = 'vocab-bookmark-words-sort-list';
    sortDropdownList.id = 'vocab-bookmark-words-sort-list';
    sortDropdownList.style.cssText = `
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: white;
      border: 1.5px solid rgba(149, 39, 245, 0.4);
      border-top: none;
      border-radius: 0 0 13px 13px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      margin-top: -1px;
    `;
    
    const sortOptions = [
      { value: 'newest', label: 'Newest first' },
      { value: 'oldest', label: 'Oldest first' },
      { value: 'alphabetical', label: 'Alphabetical order' }
    ];
    
    // Create dropdown items
    sortOptions.forEach((option) => {
      const item = document.createElement('div');
      item.textContent = option.label;
      item.setAttribute('data-value', option.value);
      item.style.cssText = `
        padding: 12px 16px;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        background-color: white;
        color: black;
        font-size: 14px;
        font-family: inherit;
        font-weight: 400;
      `;
      
      item.addEventListener('mouseenter', () => {
        item.style.backgroundColor = '#e9d5ff';
        item.style.color = '#9333ea';
      });
      
      item.addEventListener('mouseleave', () => {
        item.style.backgroundColor = 'white';
        item.style.color = 'black';
      });
      
      item.addEventListener('click', () => {
        this.sortBy = option.value;
        sortDropdownInput.value = option.label;
        sortDropdownList.style.display = 'none';
        sortDropdownIcon.style.transform = 'translateY(-50%) rotate(0deg)';
        this.applyFilters();
        this.renderTable();
      });
      
      sortDropdownList.appendChild(item);
    });
    
    // Toggle dropdown on input click
    sortDropdownInput.addEventListener('click', (e) => {
      e.stopPropagation();
      const isOpen = sortDropdownList.style.display === 'block';
      sortDropdownList.style.display = isOpen ? 'none' : 'block';
      sortDropdownIcon.style.transform = isOpen 
        ? 'translateY(-50%) rotate(0deg)' 
        : 'translateY(-50%) rotate(180deg)';
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!sortDropdownWrapper.contains(e.target)) {
        sortDropdownList.style.display = 'none';
        sortDropdownIcon.style.transform = 'translateY(-50%) rotate(0deg)';
      }
    });
    
    sortDropdownWrapper.appendChild(sortDropdownInput);
    sortDropdownWrapper.appendChild(sortDropdownIcon);
    sortDropdownWrapper.appendChild(sortDropdownList);
    sortDropdownContainer.appendChild(sortDropdownWrapper);
    
    controlsContainer.appendChild(sortDropdownContainer);
    
    // Create table container
    const tableContainer = document.createElement('div');
    tableContainer.className = 'vocab-bookmark-words-table-container';
    
    // Create table
    const table = document.createElement('table');
    table.className = 'vocab-bookmark-words-table';
    
    // Create table header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    const wordHeader = document.createElement('th');
    wordHeader.textContent = 'Word';
    wordHeader.className = 'vocab-bookmark-words-th-word';
    
    const meaningHeader = document.createElement('th');
    meaningHeader.textContent = 'Meaning';
    meaningHeader.className = 'vocab-bookmark-words-th-meaning';
    
    const sourceHeader = document.createElement('th');
    sourceHeader.textContent = 'Source';
    sourceHeader.className = 'vocab-bookmark-words-th-source';
    
    const actionsHeader = document.createElement('th');
    actionsHeader.textContent = 'Actions';
    actionsHeader.className = 'vocab-bookmark-words-th-actions';
    
    headerRow.appendChild(wordHeader);
    headerRow.appendChild(meaningHeader);
    headerRow.appendChild(sourceHeader);
    headerRow.appendChild(actionsHeader);
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Create table body
    const tbody = document.createElement('tbody');
    tbody.id = 'vocab-bookmark-words-tbody';
    table.appendChild(tbody);
    
    tableContainer.appendChild(table);
    
    // Create pagination container
    const paginationContainer = document.createElement('div');
    paginationContainer.className = 'vocab-bookmark-words-pagination';
    paginationContainer.id = 'vocab-bookmark-words-pagination';
    
    // Assemble dialog
    dialogContent.appendChild(leftButtonContainer);
    dialogContent.appendChild(header);
    dialogContent.appendChild(actionButtonsContainer);
    dialogContent.appendChild(controlsContainer);
    dialogContent.appendChild(tableContainer);
    dialogContent.appendChild(paginationContainer);
    
    this.dialogContainer.appendChild(dialogContent);
    
    // Create resize handle for left side
    const resizeHandle = this.createResizeHandle();
    this.dialogContainer.appendChild(resizeHandle);
    
    document.body.appendChild(this.dialogContainer);
    
    // Initialize resize functionality
    this.initResize();
    
    // Render initial table
    this.renderTable();
    
    console.log('[BookmarkWordsDialog] Dialog created');
  },
  
  /**
   * Create resize handle for left side
   */
  createResizeHandle() {
    const handle = document.createElement('div');
    handle.className = 'vocab-bookmark-words-resize-handle';
    return handle;
  },
  
  /**
   * Initialize resize functionality
   */
  initResize() {
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    const resizeHandle = this.dialogContainer.querySelector('.vocab-bookmark-words-resize-handle');
    if (!resizeHandle) return;
    
    const startResize = (e) => {
      isResizing = true;
      startX = e.clientX;
      
      const rect = this.dialogContainer.getBoundingClientRect();
      startWidth = rect.width;
      
      e.preventDefault();
      document.body.style.userSelect = 'none';
      resizeHandle.classList.add('resizing');
    };
    
    const resize = (e) => {
      if (!isResizing) return;
      
      // Calculate new width (inverted for right-side panel)
      const deltaX = startX - e.clientX;
      const newWidth = Math.max(300, Math.min(1000, startWidth + deltaX));
      
      this.dialogContainer.style.setProperty('width', `${newWidth}px`, 'important');
      // Keep dialog vertically centered during resize
      this.dialogContainer.style.setProperty('top', '50%', 'important');
      // Only set transform inline during resize, will be removed on close
      this.dialogContainer.style.setProperty('transform', 'translateY(-50%) translateX(0)', 'important');
    };
    
    const stopResize = async () => {
      if (!isResizing) return;
      
      isResizing = false;
      document.body.style.userSelect = '';
      resizeHandle.classList.remove('resizing');
      
      // Save the current width to storage
      const currentWidth = this.dialogContainer.style.width;
      if (currentWidth) {
        try {
          await chrome.storage.local.set({
            'vocab-bookmark-words-dialog-width': currentWidth
          });
          console.log('[BookmarkWordsDialog] Saved width to storage:', currentWidth);
        } catch (error) {
          console.error('[BookmarkWordsDialog] Error saving width to storage:', error);
        }
      }
    };
    
    resizeHandle.addEventListener('mousedown', startResize);
    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResize);
  },
  
  /**
   * Load saved dimensions from storage
   */
  async loadSavedDimensions() {
    if (!this.dialogContainer) return;
    
    try {
      const result = await chrome.storage.local.get(['vocab-bookmark-words-dialog-width']);
      if (result['vocab-bookmark-words-dialog-width']) {
        const savedWidth = result['vocab-bookmark-words-dialog-width'];
        this.dialogContainer.style.setProperty('width', savedWidth, 'important');
        console.log('[BookmarkWordsDialog] Loaded saved width from storage:', savedWidth);
      }
    } catch (error) {
      console.error('[BookmarkWordsDialog] Error loading saved dimensions:', error);
    }
  },
  
  /**
   * Highlight matched substring in text
   * @param {string} text - The text to highlight
   * @param {string} query - The search query
   * @returns {string} - HTML string with highlighted matches
   */
  highlightMatch(text, query) {
    if (!query || !query.trim()) {
      return text;
    }
    
    const queryLower = query.toLowerCase().trim();
    const textLower = text.toLowerCase();
    const matches = [];
    
    // Find all matches (case-insensitive)
    let startIndex = 0;
    while (startIndex < text.length) {
      const index = textLower.indexOf(queryLower, startIndex);
      if (index === -1) break;
      matches.push({ start: index, end: index + queryLower.length });
      startIndex = index + 1;
    }
    
    if (matches.length === 0) {
      return text;
    }
    
    // Build HTML with highlights
    let result = '';
    let lastIndex = 0;
    
    matches.forEach(match => {
      // Add text before match
      if (match.start > lastIndex) {
        result += this.escapeHtml(text.substring(lastIndex, match.start));
      }
      // Add highlighted match
      const matchedText = text.substring(match.start, match.end);
      result += `<span class="vocab-bookmark-words-search-highlight">${this.escapeHtml(matchedText)}</span>`;
      lastIndex = match.end;
    });
    
    // Add remaining text
    if (lastIndex < text.length) {
      result += this.escapeHtml(text.substring(lastIndex));
    }
    
    return result;
  },
  
  /**
   * Escape HTML to prevent XSS
   * @param {string} text - Text to escape
   * @returns {string} - Escaped text
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  },
  
  /**
   * Render table with paginated bookmarks
   */
  renderTable() {
    const tbody = document.getElementById('vocab-bookmark-words-tbody');
    const paginationContainer = document.getElementById('vocab-bookmark-words-pagination');
    
    if (!tbody || !paginationContainer) {
      console.warn('[BookmarkWordsDialog] Table elements not found');
      return;
    }
    
    // Clear existing content
    tbody.innerHTML = '';
    paginationContainer.innerHTML = '';
    
    // Get paginated bookmarks
    const paginatedBookmarks = this.getPaginatedBookmarks();
    const totalPages = this.getTotalPages();
    
    // Render table rows
    if (paginatedBookmarks.length === 0) {
      const emptyRow = document.createElement('tr');
      const emptyCell = document.createElement('td');
      emptyCell.colSpan = 4;
      emptyCell.className = 'vocab-bookmark-words-empty';
      emptyCell.textContent = this.searchQuery.trim() 
        ? 'No bookmarks found matching your search.' 
        : 'No bookmarks yet. Words you bookmark will appear here.';
      emptyRow.appendChild(emptyCell);
      tbody.appendChild(emptyRow);
    } else {
      paginatedBookmarks.forEach(bookmark => {
        const row = document.createElement('tr');
        
        const wordCell = document.createElement('td');
        wordCell.className = 'vocab-bookmark-words-td-word';
        
        // Create word container with word text and copy icon
        const wordContainer = document.createElement('div');
        wordContainer.className = 'vocab-bookmark-words-word-container';
        
        const wordText = document.createElement('span');
        wordText.className = 'vocab-bookmark-words-word-text';
        // Highlight matched substring if there's a search query
        if (this.searchQuery && this.searchQuery.trim()) {
          wordText.innerHTML = this.highlightMatch(bookmark.word, this.searchQuery);
        } else {
          wordText.textContent = bookmark.word;
        }
        wordText.style.cursor = 'pointer';
        
        // Create copy icon
        const copyIcon = document.createElement('button');
        copyIcon.className = 'vocab-bookmark-words-copy-icon';
        copyIcon.setAttribute('aria-label', 'Copy word');
        copyIcon.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        `;
        copyIcon.addEventListener('click', (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(bookmark.word).then(() => {
            // Show feedback
            const originalHTML = copyIcon.innerHTML;
            copyIcon.innerHTML = `
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 6L9 17l-5-5" stroke="#16a34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            `;
            setTimeout(() => {
              copyIcon.innerHTML = originalHTML;
            }, 1000);
          }).catch(err => {
            console.error('[BookmarkWordsDialog] Failed to copy word:', err);
          });
        });
        
        // Add copy icon first (left side), then word text
        wordContainer.appendChild(copyIcon);
        wordContainer.appendChild(wordText);
        wordCell.appendChild(wordContainer);
        
        // Make word cell clickable to open word-ask-ai modal
        wordCell.style.cursor = 'pointer';
        wordCell.addEventListener('click', (e) => {
          // Don't trigger if clicking on copy icon
          if (e.target.closest('.vocab-bookmark-words-copy-icon')) {
            return;
          }
          this.openWordAskAIModal(bookmark.word, bookmark.meaning, wordCell);
        });
        
        const meaningCell = document.createElement('td');
        meaningCell.className = 'vocab-bookmark-words-td-meaning';
        meaningCell.textContent = bookmark.meaning;
        meaningCell.style.cursor = 'pointer';
        // Make meaning cell clickable to open word-ask-ai modal
        meaningCell.addEventListener('click', (e) => {
          this.openWordAskAIModal(bookmark.word, bookmark.meaning, wordCell);
        });
        
        // Create source cell with link icon
        const sourceCell = document.createElement('td');
        sourceCell.className = 'vocab-bookmark-words-td-source';
        sourceCell.style.cursor = 'pointer';
        
        if (bookmark.url) {
          const linkButton = document.createElement('button');
          linkButton.className = 'vocab-bookmark-words-link-icon';
          linkButton.setAttribute('aria-label', 'Open source page');
          linkButton.title = bookmark.url;
          linkButton.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <polyline points="15 3 21 3 21 9" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <line x1="10" y1="14" x2="21" y2="3" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          `;
          linkButton.addEventListener('click', (e) => {
            e.stopPropagation();
            // Build URL with query params
            try {
              const url = new URL(bookmark.url);
              url.searchParams.set('xplaino_word', bookmark.word);
              console.log('[BookmarkWordsDialog] Opening URL with params:', url.toString());
              window.open(url.toString(), '_blank');
            } catch (error) {
              console.error('[BookmarkWordsDialog] Error building URL:', error, 'bookmark.url:', bookmark.url);
              // Fallback: try to append query params manually
              const separator = bookmark.url.includes('?') ? '&' : '?';
              const finalUrl = `${bookmark.url}${separator}xplaino_word=${encodeURIComponent(bookmark.word)}`;
              console.log('[BookmarkWordsDialog] Opening URL (fallback):', finalUrl);
              window.open(finalUrl, '_blank');
            }
          });
          sourceCell.appendChild(linkButton);
        } else {
          sourceCell.textContent = '-';
          sourceCell.style.color = '#9ca3af';
        }
        // Make source cell clickable to open word-ask-ai modal (but not when clicking link button)
        sourceCell.addEventListener('click', (e) => {
          // Don't trigger if clicking on link button
          if (e.target.closest('.vocab-bookmark-words-link-icon')) {
            return;
          }
          this.openWordAskAIModal(bookmark.word, bookmark.meaning, wordCell);
        });
        
        // Create actions cell with delete button
        const actionsCell = document.createElement('td');
        actionsCell.className = 'vocab-bookmark-words-td-actions';
        actionsCell.style.cursor = 'pointer';
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'vocab-bookmark-words-delete-icon';
        deleteButton.setAttribute('aria-label', 'Delete bookmark');
        deleteButton.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14z" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <line x1="10" y1="11" x2="10" y2="17" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <line x1="14" y1="11" x2="14" y2="17" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        `;
        deleteButton.addEventListener('click', async (e) => {
          e.stopPropagation();
          
          // Animate height to zero in 0.2 seconds
          const rowHeight = row.offsetHeight;
          const cells = row.querySelectorAll('td');
          
          // Set initial height and prepare for animation
          row.style.height = `${rowHeight}px`;
          row.style.opacity = '1';
          row.style.overflow = 'hidden';
          row.style.display = 'table-row';
          
          // Set transition
          row.style.transition = 'height 0.2s ease-out, opacity 0.2s ease-out';
          cells.forEach(cell => {
            cell.style.transition = 'padding 0.2s ease-out';
          });
          
          // Force reflow
          void row.offsetHeight;
          
          // Animate to zero
          row.style.height = '0';
          row.style.opacity = '0';
          cells.forEach(cell => {
            cell.style.paddingTop = '0';
            cell.style.paddingBottom = '0';
          });
          
          // Delete after animation
          setTimeout(async () => {
            const success = await BookmarkWordsService.removeBookmark(bookmark.word);
            if (success) {
              // Reload bookmarks and re-render table
              await this.loadBookmarks();
              this.renderTable();
            }
          }, 200);
        });
        actionsCell.appendChild(deleteButton);
        // Make actions cell clickable to open word-ask-ai modal (but not when clicking delete button)
        actionsCell.addEventListener('click', (e) => {
          // Don't trigger if clicking on delete button
          if (e.target.closest('.vocab-bookmark-words-delete-icon')) {
            return;
          }
          this.openWordAskAIModal(bookmark.word, bookmark.meaning, wordCell);
        });
        
        row.appendChild(wordCell);
        row.appendChild(meaningCell);
        row.appendChild(sourceCell);
        row.appendChild(actionsCell);
        tbody.appendChild(row);
      });
    }
    
    // Render pagination
    if (totalPages > 1) {
      const paginationInfo = document.createElement('div');
      paginationInfo.className = 'vocab-bookmark-words-pagination-info';
      paginationInfo.textContent = `Page ${this.currentPage} of ${totalPages} (${this.filteredBookmarks.length} total)`;
      
      const paginationButtons = document.createElement('div');
      paginationButtons.className = 'vocab-bookmark-words-pagination-buttons';
      
      // Previous button
      const prevButton = document.createElement('button');
      prevButton.className = 'vocab-bookmark-words-pagination-btn';
      prevButton.textContent = 'Previous';
      prevButton.disabled = this.currentPage === 1;
      prevButton.addEventListener('click', () => {
        if (this.currentPage > 1) {
          this.currentPage--;
          this.renderTable();
        }
      });
      
      // Next button
      const nextButton = document.createElement('button');
      nextButton.className = 'vocab-bookmark-words-pagination-btn';
      nextButton.textContent = 'Next';
      nextButton.disabled = this.currentPage === totalPages;
      nextButton.addEventListener('click', () => {
        if (this.currentPage < totalPages) {
          this.currentPage++;
          this.renderTable();
        }
      });
      
      paginationButtons.appendChild(prevButton);
      paginationButtons.appendChild(nextButton);
      
      paginationContainer.appendChild(paginationInfo);
      paginationContainer.appendChild(paginationButtons);
    } else if (this.filteredBookmarks.length > 0) {
      const paginationInfo = document.createElement('div');
      paginationInfo.className = 'vocab-bookmark-words-pagination-info';
      paginationInfo.textContent = `${this.filteredBookmarks.length} bookmark${this.filteredBookmarks.length === 1 ? '' : 's'}`;
      paginationContainer.appendChild(paginationInfo);
    }
  },
  
  /**
   * Open word-ask-ai modal for a bookmarked word
   * Creates a fresh modal for each word with conversation stored in memory
   * @param {string} word - The word
   * @param {string} meaning - The meaning
   * @param {HTMLElement} wordCell - The word cell element (for closing animation)
   */
  openWordAskAIModal(word, meaning, wordCell) {
    console.log('[BookmarkWordsDialog] Opening word-ask-ai modal for:', word);
    
    const normalizedWord = word.toLowerCase();
    const bookmarkDialog = this;
    
    // Check if modal is already open for this word - toggle behavior
    const existingModalForWord = document.querySelector(`.word-web-search-modal[data-word="${normalizedWord}"]`);
    if (existingModalForWord) {
      console.log('[BookmarkWordsDialog] Modal already open for this word, closing it (toggle)');
      // Close the modal
      if (existingModalForWord._rowElement) {
        existingModalForWord._rowElement.style.backgroundColor = '';
        existingModalForWord._rowElement.removeAttribute('data-has-active-modal');
      }
      this.closeWordAskAIModalWithAnimation(existingModalForWord, wordCell);
      return;
    }
    
    // First, close ALL other existing modals (not for this word)
    const allExistingModals = document.querySelectorAll('.word-web-search-modal');
    allExistingModals.forEach(existingModal => {
      if (existingModal.getAttribute('data-word') === normalizedWord) {
        return; // Skip the modal for this word (shouldn't exist, but just in case)
      }
      console.log('[BookmarkWordsDialog] Closing existing modal');
      // Clean up observers and handlers before removing
      if (existingModal._chatHistoryObserver) {
        existingModal._chatHistoryObserver.disconnect();
      }
      if (existingModal._clickOutsideHandler) {
        document.removeEventListener('click', existingModal._clickOutsideHandler, true);
      }
      if (existingModal._resizeObserver) {
        existingModal._resizeObserver.disconnect();
      }
      if (existingModal._resizeHandler) {
        window.removeEventListener('resize', existingModal._resizeHandler);
      }
      if (existingModal._scrollHandler) {
        window.removeEventListener('scroll', existingModal._scrollHandler);
      }
      // Remove row highlight if exists
      if (existingModal._rowElement) {
        existingModal._rowElement.style.backgroundColor = '';
        existingModal._rowElement.removeAttribute('data-has-active-modal');
      }
      existingModal.remove();
    });
    
    // Remove highlights from all rows
    const allRows = this.dialogContainer.querySelectorAll('tr');
    allRows.forEach(row => {
      row.style.backgroundColor = '';
    });
    
    // Add light green background to the current row
    const row = wordCell.closest('tr');
    if (row) {
      row.style.backgroundColor = '#f0fdf4'; // Very light green
      row.style.transition = 'background-color 0.2s ease';
      // Add hover effect for darker green - only for rows with green background
      // Mark this row as having an active modal
      row.setAttribute('data-has-active-modal', 'true');
      row.addEventListener('mouseenter', function() {
        // Only apply darker green if this row has the active modal (green background)
        if (this.getAttribute('data-has-active-modal') === 'true') {
          const currentBg = this.style.backgroundColor;
          const rgbGreen = 'rgb(240, 253, 244)';
          const hexGreen = '#f0fdf4';
          if (currentBg === rgbGreen || currentBg === hexGreen) {
            this.style.setProperty('background-color', '#dcfce7', 'important'); // Darker green
          }
        }
      });
      row.addEventListener('mouseleave', function() {
        // Only restore if this row has the active modal
        if (this.getAttribute('data-has-active-modal') === 'true') {
          const currentBg = this.style.backgroundColor;
          const darkerGreen = 'rgb(220, 252, 231)';
          const darkerGreenHex = '#dcfce7';
          if (currentBg === darkerGreen || currentBg === darkerGreenHex) {
            this.style.setProperty('background-color', '#f0fdf4', 'important'); // Back to light green
          }
        }
      });
    }
    
    // Check if there's existing chat history for this word (stored in memory)
    let existingChatHistory = this.wordChatHistories.get(normalizedWord) || [];
    
    // Format initial context as: word: <word> and contextual meaning: <meaning>
    const initialContext = `word: ${word}\n\ncontextual meaning: ${meaning}`;
    
    // Get vocab-bookmark-words-content element for positioning
    const contentElement = this.dialogContainer.querySelector('.vocab-bookmark-words-content');
    if (!contentElement) {
      console.error('[BookmarkWordsDialog] vocab-bookmark-words-content not found');
      return;
    }
    
    // Function to position modal relative to vocab-bookmark-words-content with 10px gap
    // Sequence: 1) Detect left border of content, 2) Position modal's right edge 10px left of content's left, 3) Set width
    const positionModal = () => {
      if (!contentElement || !modal) return;
      
      const contentRect = contentElement.getBoundingClientRect();
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      
      // Step 1: Detect the left border of bookmark content element
      const contentLeftEdge = contentRect.left;
      
      // Step 2: Calculate where modal's RIGHT edge should be: 10px left of content's left edge
      const modalRightEdge = contentLeftEdge - 10;
      
      // Step 3: Calculate available space for modal (from viewport left to modal right edge)
      const viewportPadding = 10;
      const availableWidth = modalRightEdge - viewportPadding;
      
      // Step 4: Set modal width (use 600px as desired, but respect available space)
      const desiredWidth = 600;
      const modalWidth = Math.min(desiredWidth, availableWidth);
      
      // Step 5: Calculate modal's left position so its right edge is at modalRightEdge
      const modalLeft = modalRightEdge - modalWidth;
      const modalTop = contentRect.top + scrollY;
      
      // Apply width and position
      modal.style.setProperty('width', `${modalWidth}px`, 'important');
      modal.style.setProperty('max-width', `${modalWidth}px`, 'important');
      modal.style.setProperty('left', `${modalLeft + scrollX}px`, 'important');
      modal.style.setProperty('top', `${modalTop}px`, 'important');
    };
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'word-web-search-modal';
    modal.setAttribute('data-word', normalizedWord);
    modal.setAttribute('data-initial-context', initialContext);
    if (existingChatHistory.length > 0) {
      modal.setAttribute('data-chat-history', JSON.stringify(existingChatHistory));
    }
    modal._bookmarkWordCell = wordCell;
    modal._bookmarkWord = word;
    modal._contentElement = contentElement;
    modal._rowElement = row; // Store row reference for cleanup
    
    // Create modal header with minimize button
    const modalHeader = document.createElement('div');
    modalHeader.className = 'word-web-search-modal-header';
    modalHeader.style.display = 'flex';
    modalHeader.style.justifyContent = 'flex-end';
    modalHeader.style.padding = '12px 16px';
    modalHeader.style.borderBottom = '1px solid rgba(149, 39, 245, 0.1)';
    // Prevent dragging on header - set cursor to default
    modalHeader.style.cursor = 'default';
    modalHeader.setAttribute('data-no-drag', 'true');
    
    const minimizeBtn = document.createElement('button');
    minimizeBtn.className = 'word-web-search-modal-minimize';
    minimizeBtn.setAttribute('aria-label', 'Minimize');
    minimizeBtn.title = 'Minimize';
    minimizeBtn.innerHTML = `
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="5" y1="12" x2="19" y2="12" stroke="#9527F5" stroke-width="2" stroke-linecap="round"/>
      </svg>
    `;
    minimizeBtn.style.cssText = `
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    `;
    minimizeBtn.addEventListener('mouseenter', () => {
      minimizeBtn.style.backgroundColor = 'rgba(149, 39, 245, 0.1)';
    });
    minimizeBtn.addEventListener('mouseleave', () => {
      minimizeBtn.style.backgroundColor = 'transparent';
    });
    minimizeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      bookmarkDialog.closeWordAskAIModalWithAnimation(modal, wordCell);
    });
    
    modalHeader.appendChild(minimizeBtn);
    
    // Create modal content container
    const modalContent = document.createElement('div');
    modalContent.className = 'word-ask-ai-modal-content';
    
    // Create search results container
    const resultsContainer = document.createElement('div');
    resultsContainer.className = 'word-web-search-results';
    
    // Create results list
    const resultsList = document.createElement('div');
    resultsList.className = 'word-web-search-results-list';
    
    // Restore chat history if exists
    if (existingChatHistory.length > 0) {
      resultsContainer.style.display = '';
      existingChatHistory.forEach(msg => {
        if (msg.role === 'user') {
          const userMessageDiv = document.createElement('div');
          userMessageDiv.className = 'word-web-search-chat-message user-message';
          // Remove prefix from user message for display
          const displayText = msg.content.replace(/^Here the word of interest is '[^']+'. Based on the context given can you answer my question. Here is my question :- /, '');
          userMessageDiv.textContent = displayText;
          resultsList.appendChild(userMessageDiv);
        } else if (msg.role === 'assistant') {
          const aiMessageDiv = document.createElement('div');
          aiMessageDiv.className = 'word-web-search-chat-message ai-message';
          const aiResponseText = document.createElement('div');
          aiResponseText.className = 'word-web-search-chat-response-text';
          // Use bookmark dialog's markdown renderer
          aiResponseText.innerHTML = bookmarkDialog.renderBookmarkMarkdown(msg.content);
          aiMessageDiv.appendChild(aiResponseText);
          resultsList.appendChild(aiMessageDiv);
        }
      });
    }
    
    resultsContainer.appendChild(resultsList);
    
    // Create chat input area
    const inputArea = document.createElement('div');
    inputArea.className = 'word-web-search-input-area';
    
    const inputField = document.createElement('textarea');
    inputField.className = 'word-web-search-input';
    inputField.placeholder = 'Ask AI anything about the word';
    inputField.rows = 1;
    
    // Auto-resize textarea
    inputField.addEventListener('input', (e) => {
      e.target.style.height = 'auto';
      const maxHeight = 120;
      const newHeight = Math.min(e.target.scrollHeight, maxHeight);
      e.target.style.height = newHeight + 'px';
      
      if (e.target.scrollHeight > maxHeight) {
        e.target.style.overflowY = 'auto';
      } else {
        e.target.style.overflowY = 'hidden';
      }
      
      if (modal._updateExplainButtonVisibility) {
        modal._updateExplainButtonVisibility();
      }
    });
    
    // Handle Enter key
    inputField.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        e.stopPropagation();
        bookmarkDialog.sendBookmarkWordChatMessage(modal, word, inputField);
      }
    });
    
    inputField.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Create send button
    const sendBtn = document.createElement('button');
    sendBtn.className = 'word-web-search-send-btn';
    sendBtn.setAttribute('aria-label', 'Send message');
    const createSendIconFn = typeof TextSelector !== 'undefined' && TextSelector.createSendIcon 
      ? TextSelector.createSendIcon 
      : () => `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 15V5M10 5L5 10M10 5L15 10" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    const createStopIconFn = typeof TextSelector !== 'undefined' && TextSelector.createStopIcon 
      ? TextSelector.createStopIcon 
      : () => `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block !important; visibility: visible !important;"><rect x="4" y="4" width="12" height="12" fill="#9527F5" stroke="none" style="display: block !important; visibility: visible !important;"/></svg>`;
    sendBtn.innerHTML = createSendIconFn();
    sendBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Check if API call is in progress (stop icon is shown)
      const isStopIcon = sendBtn.querySelector('rect[fill="#9527F5"]');
      if (isStopIcon) {
        // Abort the API call
        const abortFn = modal._currentAbortFn;
        if (abortFn && typeof abortFn === 'function') {
          console.log('[BookmarkWordsDialog] Aborting API call');
          abortFn();
          // Store current chat in memory before aborting
          const resultsList = modal.querySelector('.word-web-search-results-list');
          const chatMessages = resultsList.querySelectorAll('.word-web-search-chat-message');
          if (chatMessages.length > 0) {
            // Build chat history from current messages
            const chatHistory = [];
            chatMessages.forEach((msg) => {
              if (msg.classList.contains('user-message')) {
                chatHistory.push({
                  role: 'user',
                  content: msg.textContent.trim()
                });
              } else if (msg.classList.contains('ai-message')) {
                const responseText = msg.querySelector('.word-web-search-chat-response-text');
                if (responseText) {
                  chatHistory.push({
                    role: 'assistant',
                    content: responseText.textContent.trim()
                  });
                }
              }
            });
            // Store in modal
            modal.setAttribute('data-chat-history', JSON.stringify(chatHistory));
            // Store in memory
            bookmarkDialog.wordChatHistories.set(normalizedWord, chatHistory);
            console.log('[BookmarkWordsDialog] Saved chat history after abort');
          }
          // Clear abort function
          modal._currentAbortFn = null;
          // Restore send icon
          sendBtn.innerHTML = createSendIconFn();
          sendBtn.setAttribute('aria-label', 'Send message');
        }
      } else {
        // Normal send action
        bookmarkDialog.sendBookmarkWordChatMessage(modal, word, inputField);
      }
    });
    
    // Create delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'word-web-search-delete-btn';
    deleteBtn.setAttribute('aria-label', 'Clear chat history');
    deleteBtn.title = 'Clear chat history';
    deleteBtn.innerHTML = typeof TextSelector !== 'undefined' && TextSelector.createTrashIcon
      ? TextSelector.createTrashIcon()
      : `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 5h14M6.5 5V3.5a1.5 1.5 0 0 1 1.5-1.5h4a1.5 1.5 0 0 1 1.5 1.5V5M15 5v10.5a1.5 1.5 0 0 1-1.5 1.5h-7a1.5 1.5 0 0 1-1.5-1.5V5h10Z" stroke="#ef4444" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 9v5M12 9v5" stroke="#ef4444" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    deleteBtn.style.display = existingChatHistory.length > 0 ? 'flex' : 'none';
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      bookmarkDialog.clearBookmarkWordChatHistory(modal, normalizedWord);
    });
    
    // Create "Explain" button
    const explainBtn = document.createElement('button');
    explainBtn.className = 'word-web-search-explain-btn';
    explainBtn.textContent = 'Explain';
    explainBtn.setAttribute('aria-label', 'Explain word');
    explainBtn.style.setProperty('display', existingChatHistory.length === 0 ? 'flex' : 'none', 'important');
    explainBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      inputField.value = 'Please explain the selected word in detail';
      bookmarkDialog.sendBookmarkWordChatMessage(modal, word, inputField);
      explainBtn.style.setProperty('display', 'none', 'important');
    });
    
    inputField.style.paddingRight = '90px';
    
    inputArea.appendChild(inputField);
    inputArea.appendChild(explainBtn);
    inputArea.appendChild(sendBtn);
    inputArea.appendChild(deleteBtn);
    
    // Function to update explain button visibility
    const updateExplainButtonVisibility = () => {
      const inputValue = inputField.value.trim();
      const resultsList = modal.querySelector('.word-web-search-results-list');
      
      // Check if input area has content (input field has text)
      const isInputEmpty = !inputValue;
      
      // Check if results container has content (results list has children)
      const isResultsEmpty = !resultsList || resultsList.children.length === 0;
      
      // Show explain button only if BOTH input and results are empty
      // Use setProperty with !important to override CSS rules
      if (isInputEmpty && isResultsEmpty) {
        explainBtn.style.setProperty('display', 'flex', 'important');
      } else {
        explainBtn.style.setProperty('display', 'none', 'important');
      }
    };
    
    modal._updateExplainButtonVisibility = updateExplainButtonVisibility;
    
    // Assemble modal
    modal.appendChild(modalHeader);
    modalContent.appendChild(resultsContainer);
    modalContent.appendChild(inputArea);
    modal.appendChild(modalContent);
    
    // Append to body
    document.body.appendChild(modal);
    
    // Set modal styles (basic styles first, width will be set in positionModal)
    modal.style.setProperty('position', 'absolute', 'important');
    // Set z-index higher than vocab-bookmark-words-content (which is 2147483647)
    // Using max safe z-index value to ensure modal appears above content
    modal.style.setProperty('z-index', '2147483647', 'important');
    modal.style.setProperty('display', 'flex', 'important');
    modal.style.setProperty('visibility', 'visible', 'important');
    modal.style.setProperty('opacity', '1', 'important');
    modal.style.setProperty('background', 'white', 'important');
    modal.style.setProperty('pointer-events', 'all', 'important');
    modal.style.setProperty('min-width', '500px', 'important');
    modal.style.setProperty('min-height', '200px', 'important');
    // Width will be set by positionModal() based on available space
    
    // Position modal immediately - this will also set the width
    positionModal();
    
    // Also position after layout is complete (for any edge cases)
    requestAnimationFrame(() => {
      positionModal();
      // One more time after a small delay to catch any late layout changes
      setTimeout(() => {
        positionModal();
      }, 0);
    });
    
    // Add opening animation class for smooth opening
    modal.classList.add('ask-ai-opening');
    requestAnimationFrame(() => {
      modal.style.setProperty('opacity', '0', 'important');
      modal.style.setProperty('transform', 'scale(0.9)', 'important');
      requestAnimationFrame(() => {
        modal.style.setProperty('transition', 'opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)', 'important');
        modal.style.setProperty('opacity', '1', 'important');
        modal.style.setProperty('transform', 'scale(1)', 'important');
        setTimeout(() => {
          modal.classList.remove('ask-ai-opening');
          modal.style.setProperty('transition', '', 'important');
        }, 300);
      });
    });
    
    // Set up ResizeObserver to update modal position when content width changes
    const resizeObserver = new ResizeObserver(() => {
      positionModal();
    });
    resizeObserver.observe(contentElement);
    modal._resizeObserver = resizeObserver;
    
    // Also update position on window resize and scroll
    const handleResize = () => {
      positionModal();
    };
    const handleScroll = () => {
      positionModal();
    };
    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleScroll, { passive: true });
    modal._resizeHandler = handleResize;
    modal._scrollHandler = handleScroll;
    
    // Prevent clicks inside modal from closing word popup
    modal.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Set up click outside handler
    const clickOutsideHandler = (e) => {
      if (!modal.contains(e.target) && !wordCell.contains(e.target)) {
        if (this.dialogContainer && this.dialogContainer.contains(e.target)) {
          return;
        }
        console.log('[BookmarkWordsDialog] Clicking outside modal - closing with animation');
        this.closeWordAskAIModalWithAnimation(modal, wordCell);
        document.removeEventListener('click', clickOutsideHandler, true);
      }
    };
    document.addEventListener('click', clickOutsideHandler, true);
    modal._clickOutsideHandler = clickOutsideHandler;
    
    // Set up chat history observer to update memory storage
    const observer = new MutationObserver(() => {
      const chatHistoryJson = modal.getAttribute('data-chat-history') || '[]';
      let chatHistory = [];
      try {
        chatHistory = JSON.parse(chatHistoryJson);
      } catch (e) {
        console.error('[BookmarkWordsDialog] Error parsing chat history:', e);
      }
      // Store chat history in memory (not chrome storage)
      this.wordChatHistories.set(normalizedWord, chatHistory);
      console.log('[BookmarkWordsDialog] Updated chat history for word:', normalizedWord, chatHistory.length, 'messages');
    });
    
    observer.observe(resultsList, { childList: true, subtree: true });
    observer.observe(modal, { attributes: true, attributeFilter: ['data-chat-history'] });
    modal._chatHistoryObserver = observer;
    
    // Don't make modal draggable - user requested to remove panning functionality
    // Modal should remain fixed in position relative to content
  },
  
  /**
   * Send chat message for bookmarked word
   * @param {HTMLElement} modal - The modal element
   * @param {string} word - The word
   * @param {HTMLElement} inputField - The input field
   */
  async sendBookmarkWordChatMessage(modal, word, inputField) {
    const bookmarkDialog = this;
    const question = inputField.value.trim();
    if (!question) return;
    
    console.log('[BookmarkWordsDialog] Sending chat message:', question);
    
    const normalizedWord = word.toLowerCase();
    
    // Clear input
    inputField.value = '';
    inputField.style.height = 'auto';
    
    // Get chat history from modal
    const chatHistoryJson = modal.getAttribute('data-chat-history') || '[]';
    let chatHistory = [];
    try {
      chatHistory = JSON.parse(chatHistoryJson);
    } catch (e) {
      console.error('[BookmarkWordsDialog] Error parsing chat history:', e);
      chatHistory = [];
    }
    
    // Get initial context
    let initialContext = modal.getAttribute('data-initial-context') || '';
    if (!initialContext || initialContext.trim() === '') {
      initialContext = `Word: ${word}`;
    }
    
    // Add prefix to user question
    const prefixedQuestion = `Here the word of interest is '${word}'. Based on the context given can you answer my question. Here is my question :- ${question}`;
    
    // Display user message
    const resultsList = modal.querySelector('.word-web-search-results-list');
    const resultsContainer = modal.querySelector('.word-web-search-results');
    if (resultsContainer) {
      resultsContainer.style.display = '';
    }
    
    const userMessageDiv = document.createElement('div');
    userMessageDiv.className = 'word-web-search-chat-message user-message';
    userMessageDiv.textContent = question;
    resultsList.appendChild(userMessageDiv);
    
    // Hide explain button
    const explainBtn = modal.querySelector('.word-web-search-explain-btn');
    if (explainBtn) {
      explainBtn.style.setProperty('display', 'none', 'important');
    }
    
    // Create AI response container
    const aiMessageDiv = document.createElement('div');
    aiMessageDiv.className = 'word-web-search-chat-message ai-message';
    const aiResponseText = document.createElement('div');
    aiResponseText.className = 'word-web-search-chat-response-text';
    aiMessageDiv.appendChild(aiResponseText);
    resultsList.appendChild(aiMessageDiv);
    
    // Scroll to bottom
    const scrollToBottom = (element) => {
      if (!element) return;
      const scrollableContent = element.closest('.word-web-search-results') || element;
      scrollableContent.scrollTop = scrollableContent.scrollHeight;
    };
    scrollToBottom(resultsList);
    
    // Keep input enabled (always enabled)
    // inputField.disabled = true; // REMOVED - input should always be enabled
    const sendBtn = modal.querySelector('.word-web-search-send-btn');
    // Change icon to stop icon and update aria-label
    const createStopIconFn = typeof TextSelector !== 'undefined' && TextSelector.createStopIcon 
      ? TextSelector.createStopIcon 
      : () => `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block !important; visibility: visible !important;"><rect x="4" y="4" width="12" height="12" fill="#9527F5" stroke="none" style="display: block !important; visibility: visible !important;"/></svg>`;
    sendBtn.innerHTML = createStopIconFn();
    sendBtn.setAttribute('aria-label', 'Stop request');
    
    // Show delete button
    const deleteBtn = modal.querySelector('.word-web-search-delete-btn');
    if (deleteBtn) {
      deleteBtn.style.display = 'flex';
    }
    
    // Call API
    let accumulatedText = '';
    const abortAsk = await ApiService.ask({
      initial_context: initialContext,
      chat_history: chatHistory,
      question: prefixedQuestion,
      context_type: 'TEXT',
      onChunk: (chunk, accumulated) => {
        accumulatedText = accumulated || accumulatedText + chunk;
        // Use bookmark dialog's markdown renderer
        aiResponseText.innerHTML = bookmarkDialog.renderBookmarkMarkdown(accumulatedText);
        scrollToBottom(resultsList);
      },
      onComplete: (updatedChatHistory) => {
        console.log('[BookmarkWordsDialog] Chat response completed');
        
        let finalChatHistory = chatHistory;
        if (updatedChatHistory && Array.isArray(updatedChatHistory)) {
          finalChatHistory = updatedChatHistory;
          modal.setAttribute('data-chat-history', JSON.stringify(updatedChatHistory));
        } else {
          chatHistory.push({
            role: 'user',
            content: prefixedQuestion
          });
          chatHistory.push({
            role: 'assistant',
            content: accumulatedText
          });
          finalChatHistory = chatHistory;
          modal.setAttribute('data-chat-history', JSON.stringify(chatHistory));
        }
        
        // Store in memory (not chrome storage)
        bookmarkDialog.wordChatHistories.set(normalizedWord, finalChatHistory);
        
        scrollToBottom(resultsList);
        
        // Input is always enabled, just restore send button icon
        // inputField.disabled = false; // REMOVED - input is always enabled
        // Clear abort function
        modal._currentAbortFn = null;
        // Restore send button icon
        const createSendIconFn = typeof TextSelector !== 'undefined' && TextSelector.createSendIcon 
          ? TextSelector.createSendIcon 
          : () => `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 15V5M10 5L5 10M10 5L15 10" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        sendBtn.innerHTML = createSendIconFn();
        sendBtn.setAttribute('aria-label', 'Send message');
        sendBtn.disabled = false;
        inputField.focus();
      },
      onError: (error) => {
        console.error('[BookmarkWordsDialog] Chat error:', error);
        aiResponseText.textContent = `Error: ${error.message || 'Failed to get response'}`;
        // Input is always enabled, just restore send button icon
        // inputField.disabled = false; // REMOVED - input is always enabled
        // Clear abort function
        modal._currentAbortFn = null;
        // Restore send button icon
        const createSendIconFn = typeof TextSelector !== 'undefined' && TextSelector.createSendIcon 
          ? TextSelector.createSendIcon 
          : () => `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 15V5M10 5L5 10M10 5L15 10" stroke="#9527F5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        sendBtn.innerHTML = createSendIconFn();
        sendBtn.setAttribute('aria-label', 'Send message');
        sendBtn.disabled = false;
        inputField.focus();
      }
    });
    
    // Store abort function on modal object (not as string attribute)
    modal._currentAbortFn = abortAsk;
  },
  
  /**
   * Clear chat history for bookmarked word
   * @param {HTMLElement} modal - The modal element
   * @param {string} normalizedWord - The normalized word
   */
  clearBookmarkWordChatHistory(modal, normalizedWord) {
    console.log('[BookmarkWordsDialog] Clearing chat history for word:', normalizedWord);
    
    // Clear from memory
    this.wordChatHistories.set(normalizedWord, []);
    
    // Reset chat history in modal
    modal.setAttribute('data-chat-history', JSON.stringify([]));
    
    // Remove chat messages from results list
    const resultsList = modal.querySelector('.word-web-search-results-list');
    const chatMessages = resultsList.querySelectorAll('.word-web-search-chat-message');
    chatMessages.forEach(msg => msg.remove());
    
    // Hide delete button
    const deleteBtn = modal.querySelector('.word-web-search-delete-btn');
    if (deleteBtn) {
      deleteBtn.style.display = 'none';
    }
    
    // Update explain button visibility
    if (modal._updateExplainButtonVisibility) {
      modal._updateExplainButtonVisibility();
    }
  },
  
  /**
   * Render markdown text to HTML (properly handles bold, italic, etc.)
   * @param {string} text - Markdown text
   * @returns {string} HTML string
   */
  renderBookmarkMarkdown(text) {
    if (!text) return '';
    
    let html = String(text);
    
    // Process markdown patterns first (don't escape yet)
    // Code blocks (```) - process first
    html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
    
    // Inline code (`)
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Bold (**text** or __text__) - must come before italic
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    
    // Italic (*text* or _text_) - but avoid conflicts with bold
    html = html.replace(/(?<!\*)\*([^*\n]+?)\*(?!\*)/g, '<em>$1</em>');
    html = html.replace(/(?<!_)_([^_\n]+?)_(?!_)/g, '<em>$1</em>');
    
    // Links [text](url)
    html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    
    // Headings
    html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
    
    // Now escape all HTML (this will escape both tags and content)
    html = html
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    
    // Unescape ONLY the HTML tags we created from markdown (not the content inside)
    html = html
      .replace(/&lt;strong&gt;/g, '<strong>')
      .replace(/&lt;\/strong&gt;/g, '</strong>')
      .replace(/&lt;em&gt;/g, '<em>')
      .replace(/&lt;\/em&gt;/g, '</em>')
      .replace(/&lt;code&gt;/g, '<code>')
      .replace(/&lt;\/code&gt;/g, '</code>')
      .replace(/&lt;pre&gt;/g, '<pre>')
      .replace(/&lt;\/pre&gt;/g, '</pre>')
      .replace(/&lt;h1&gt;/g, '<h1>')
      .replace(/&lt;\/h1&gt;/g, '</h1>')
      .replace(/&lt;h2&gt;/g, '<h2>')
      .replace(/&lt;\/h2&gt;/g, '</h2>')
      .replace(/&lt;h3&gt;/g, '<h3>')
      .replace(/&lt;\/h3&gt;/g, '</h3>')
      .replace(/&lt;a href="([^"]+)" target="_blank" rel="noopener noreferrer"&gt;/g, '<a href="$1" target="_blank" rel="noopener noreferrer">')
      .replace(/&lt;\/a&gt;/g, '</a>');
    
    // Line breaks
    html = html.replace(/\n\n/g, '<br><br>');
    html = html.replace(/\n/g, '<br>');
    
    // Lists
    html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
    html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
    html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
    
    // Wrap consecutive <li> in <ul>
    html = html.replace(/(<li>.*?<\/li>)/gs, '<ul>$1</ul>');
    
    return html;
  },
  
  /**
   * Close word-ask-ai modal with animation (move to word cell and scale down)
   * @param {HTMLElement} modal - The modal element
   * @param {HTMLElement} wordCell - The word cell element to animate to
   */
  closeWordAskAIModalWithAnimation(modal, wordCell) {
    console.log('[BookmarkWordsDialog] Closing word-ask-ai modal with animation');
    
    // Check if already closing
    if (modal.classList.contains('ask-ai-closing')) {
      return;
    }
    
    // Remove row highlight and data attribute
    if (modal._rowElement) {
      modal._rowElement.style.backgroundColor = '';
      modal._rowElement.removeAttribute('data-has-active-modal');
    }
    
    // Clean up observers and handlers
    if (modal._chatHistoryObserver) {
      modal._chatHistoryObserver.disconnect();
    }
    if (modal._clickOutsideHandler) {
      document.removeEventListener('click', modal._clickOutsideHandler, true);
    }
    if (modal._resizeObserver) {
      modal._resizeObserver.disconnect();
    }
    if (modal._resizeHandler) {
      window.removeEventListener('resize', modal._resizeHandler);
    }
    if (modal._scrollHandler) {
      window.removeEventListener('scroll', modal._scrollHandler);
    }
    
    // Get current modal position and dimensions
    const modalRect = modal.getBoundingClientRect();
    const currentWidth = modalRect.width;
    const currentHeight = modalRect.height;
    
    const scrollX = window.scrollX || window.pageXOffset || 0;
    const scrollY = window.scrollY || window.pageYOffset || 0;
    
    // Get word cell center position
    const wordCellRect = wordCell.getBoundingClientRect();
    const wordCellCenterX = wordCellRect.left + wordCellRect.width / 2;
    const wordCellCenterY = wordCellRect.top + wordCellRect.height / 2;
    
    // Convert to document coordinates
    const finalLeft = wordCellCenterX + scrollX;
    const finalTop = wordCellCenterY + scrollY;
    
    // Get current modal position
    let currentTop = parseFloat(modal.style.top);
    let currentLeft = parseFloat(modal.style.left);
    
    if (isNaN(currentTop)) {
      currentTop = modalRect.top + scrollY;
    }
    if (isNaN(currentLeft)) {
      currentLeft = modalRect.left + scrollX;
    }
    
    // Set initial state - no fade out, just scale and move
    modal.style.setProperty('opacity', '1', 'important');
    modal.style.setProperty('top', `${currentTop}px`, 'important');
    modal.style.setProperty('left', `${currentLeft}px`, 'important');
    modal.style.setProperty('width', `${currentWidth}px`, 'important');
    modal.style.setProperty('height', `${currentHeight}px`, 'important');
    modal.style.setProperty('overflow', 'hidden', 'important');
    
    // Force reflow
    void modal.offsetHeight;
    
    // Remove constraints
    modal.style.setProperty('min-width', '0px', 'important');
    modal.style.setProperty('min-height', '0px', 'important');
    modal.style.setProperty('max-width', 'none', 'important');
    modal.style.setProperty('max-height', 'none', 'important');
    
    // Set transition for closing animation - no opacity fade, just transform and position
    modal.style.setProperty('transition', 'top 0.2s ease-out, left 0.2s ease-out, width 0.2s ease-out, height 0.2s ease-out, transform 0.2s ease-out', 'important');
    modal.style.setProperty('opacity', '1', 'important'); // Keep opacity at 1, no fade
    
    // Add closing class
    modal.classList.add('ask-ai-closing');
    
    // Force reflow
    void modal.offsetHeight;
    
    // Animate to word cell center and scale down to 0 (no opacity fade)
    modal.style.setProperty('top', `${finalTop}px`, 'important');
    modal.style.setProperty('left', `${finalLeft}px`, 'important');
    modal.style.setProperty('width', '0px', 'important');
    modal.style.setProperty('height', '0px', 'important');
    // Keep opacity at 1 - no fade out
    modal.style.setProperty('opacity', '1', 'important');
    
    // Remove modal after animation
    setTimeout(() => {
      modal.remove();
      console.log('[BookmarkWordsDialog] Modal removed after animation');
    }, 200);
  },
  
  /**
   * Inject styles for bookmark words dialog
   */
  injectStyles() {
    const styleId = 'vocab-bookmark-words-dialog-styles';
    
    if (document.getElementById(styleId)) {
      return;
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      /* Bookmark Words Dialog Container */
      .vocab-bookmark-words-dialog {
        position: fixed;
        right: 0;
        top: 50%;
        transform: translateY(-50%) translateX(100%);
        width: 600px !important;
        max-width: 90vw;
        height: 800px !important;
        max-height: 80vh;
        z-index: 2147483647 !important;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0s;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        user-select: none;
        background: white !important;
        border-radius: 30px 0 0 30px;
        overflow: visible;
      }
      
      .vocab-bookmark-words-dialog.visible {
        transform: translateY(-50%) translateX(0);
      }
      
      /* Resize Handle - Left Side (Purple Strip) */
      .vocab-bookmark-words-resize-handle {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        cursor: ew-resize;
        background: transparent;
        transition: all 0.2s ease;
        z-index: 1000001;
      }
      
      .vocab-bookmark-words-resize-handle::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 4px;
        height: 40px;
        border-radius: 2px;
        background: #9527F5;
        box-shadow: 0 0 8px rgba(149, 39, 245, 0.3);
        transition: all 0.2s ease;
      }
      
      .vocab-bookmark-words-resize-handle:hover::before {
        background: #9527F5;
        box-shadow: 0 0 12px rgba(149, 39, 245, 0.5);
        width: 6px;
        height: 60px;
      }
      
      .vocab-bookmark-words-resize-handle.resizing::before {
        background: #7a1fd9;
        box-shadow: 0 0 16px rgba(149, 39, 245, 0.7);
        width: 6px;
        height: 80px;
      }
      
      /* Dialog Content */
      .vocab-bookmark-words-content {
        background: white !important;
        height: 100%;
        border-radius: 30px 0 0 30px;
        box-shadow: -4px 0 24px rgba(149, 39, 245, 0.2), -2px 0 12px rgba(149, 39, 245, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
        padding: 20px;
        padding-top: 60px;
      }
      
      /* Header */
      .vocab-bookmark-words-header {
        font-size: 20px;
        font-weight: 600;
        color: #9527F5;
        margin-bottom: 20px;
        text-align: center;
        padding-top: 10px;
      }
      
      /* Action Buttons Container */
      .vocab-bookmark-words-action-buttons {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
        padding: 0 20px;
      }
      
      /* Refresh Button */
      .vocab-bookmark-words-refresh-btn {
        position: relative;
        background: none;
        border: none;
        border-radius: 8px;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 0;
      }
      
      .vocab-bookmark-words-refresh-btn:hover {
        transform: scale(1.05);
      }
      
      .vocab-bookmark-words-refresh-btn:active {
        transform: scale(0.95);
      }
      
      .vocab-bookmark-words-refresh-btn svg {
        width: 24px;
        height: 24px;
      }
      
      /* Rotation animation for loading state */
      .vocab-bookmark-words-refresh-btn.vocab-bookmark-words-refresh-loading .vocab-bookmark-words-refresh-icon {
        animation: vocab-bookmark-words-refresh-rotate 1s linear infinite;
      }
      
      @keyframes vocab-bookmark-words-refresh-rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      
      /* Success state (green tick) */
      .vocab-bookmark-words-refresh-btn.vocab-bookmark-words-refresh-success svg {
        width: 24px;
        height: 24px;
      }
      
      /* Tooltip */
      .vocab-bookmark-words-refresh-tooltip {
        position: absolute;
        bottom: calc(100% + 8px);
        right: 0;
        background: #333;
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 1000;
      }
      
      .vocab-bookmark-words-refresh-tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        right: 12px;
        border: 5px solid transparent;
        border-top-color: #333;
      }
      
      .vocab-bookmark-words-refresh-btn:hover .vocab-bookmark-words-refresh-tooltip {
        opacity: 1;
      }
      
      /* Controls Container */
      .vocab-bookmark-words-controls {
        display: flex;
        gap: 16px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      
      /* Search Container */
      .vocab-bookmark-words-search-container {
        flex: 1;
        min-width: 200px;
      }
      
      .vocab-bookmark-words-search-input {
        width: 100%;
        padding: 10px 16px;
        border: 1.5px solid rgba(149, 39, 245, 0.4);
        border-radius: 13px;
        font-size: 14px;
        font-family: inherit;
        transition: border-color 0.2s ease;
        box-sizing: border-box;
      }
      
      .vocab-bookmark-words-search-input:focus {
        outline: none;
        border-color: #9527F5;
      }
      
      /* Sort Dropdown Container */
      .vocab-bookmark-words-sort-container {
        position: relative;
        min-width: 180px;
      }
      
      .vocab-bookmark-words-sort-input {
        width: 100%;
        padding: 10px 45px 10px 16px;
        border: 1.5px solid rgba(149, 39, 245, 0.4);
        border-radius: 13px;
        font-size: 14px;
        font-family: inherit;
        font-weight: 400;
        background-color: white;
        cursor: pointer;
        transition: border-color 0.2s ease;
        box-sizing: border-box;
      }
      
      .vocab-bookmark-words-sort-input:focus {
        outline: none;
        border-color: #9527F5;
      }
      
      .vocab-bookmark-words-sort-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background-color: white;
        border: 1.5px solid rgba(149, 39, 245, 0.4);
        border-top: none;
        border-radius: 0 0 13px 13px;
        max-height: 200px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        margin-top: -1px;
      }
      
      .vocab-bookmark-words-sort-list div {
        padding: 12px 16px;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        background-color: white;
        color: black;
        font-size: 14px;
        font-family: inherit;
        font-weight: 400;
      }
      
      .vocab-bookmark-words-sort-list div:hover {
        background-color: #e9d5ff !important;
        color: #9333ea !important;
      }
      
      /* Table Container */
      .vocab-bookmark-words-table-container {
        flex: 1;
        overflow-y: auto;
        border: 1px solid rgba(149, 39, 245, 0.4);
        border-radius: 20px;
        margin-bottom: 16px;
      }
      
      /* Table */
      .vocab-bookmark-words-table {
        width: 100%;
        border-collapse: collapse;
        background: white;
      }
      
      /* Table Header */
      .vocab-bookmark-words-th-word,
      .vocab-bookmark-words-th-meaning,
      .vocab-bookmark-words-th-source,
      .vocab-bookmark-words-th-actions {
        padding: 12px 16px;
        text-align: left;
        font-weight: 600;
        font-size: 13px;
        color: #374151;
        background: rgba(223, 199, 255, 1);
        border-bottom: 2px solid #e5e7eb;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      
      .vocab-bookmark-words-th-word {
        width: 25%;
      }
      
      .vocab-bookmark-words-th-meaning {
        width: 45%;
      }
      
      .vocab-bookmark-words-th-source {
        width: 15%;
      }
      
      .vocab-bookmark-words-th-actions {
        width: 15%;
      }
      
      /* Table Body */
      .vocab-bookmark-words-td-word,
      .vocab-bookmark-words-td-meaning,
      .vocab-bookmark-words-td-source,
      .vocab-bookmark-words-td-actions {
        padding: 12px 16px;
        font-size: 14px;
        color: #374151;
        border-bottom: 1px solid rgba(149, 39, 245, 0.2);
        vertical-align: middle;
      }
      
      /* Hover effect for rows with green background (active modal) */
      .vocab-bookmark-words-table tbody tr[style*="background-color: rgb(240, 253, 244)"],
      .vocab-bookmark-words-table tbody tr[style*="background-color: #f0fdf4"] {
        transition: background-color 0.2s ease;
      }
      
      /* Note: Hover is handled via JavaScript event listeners for better control */
      
      .vocab-bookmark-words-td-source,
      .vocab-bookmark-words-td-actions {
        text-align: center;
      }
      
      .vocab-bookmark-words-td-word {
        font-weight: 500;
        color: #9527F5;
        position: relative;
      }
      
      /* Word Container */
      .vocab-bookmark-words-word-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .vocab-bookmark-words-word-text {
        flex: 1;
        cursor: pointer;
        transition: color 0.2s ease;
      }
      
      .vocab-bookmark-words-word-text:hover {
        color: #7a1fd9;
        text-decoration: underline;
      }
      
      /* Search highlight styling */
      .vocab-bookmark-words-search-highlight {
        background-color: transparent;
        border: none;
        border-bottom: 3px solid #22c55e;
        border-radius: 0;
        padding: 0;
        color: inherit;
        text-decoration: none;
      }
      
      /* Copy Icon */
      .vocab-bookmark-words-copy-icon {
        width: 24px;
        height: 24px;
        padding: 4px;
        border: none;
        background: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background-color 0.2s ease;
        opacity: 0.6;
        flex-shrink: 0;
      }
      
      .vocab-bookmark-words-copy-icon:hover {
        background: #f3f4f6;
        opacity: 1;
      }
      
      .vocab-bookmark-words-copy-icon:active {
        background: #e5e7eb;
      }
      
      .vocab-bookmark-words-copy-icon svg {
        width: 100%;
        height: 100%;
      }
      
      .vocab-bookmark-words-td-meaning {
        line-height: 1.5;
      }
      
      /* Link Icon Button */
      .vocab-bookmark-words-link-icon {
        width: 32px;
        height: 32px;
        padding: 6px;
        border: none;
        background: transparent;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background-color 0.2s ease;
        opacity: 0.7;
      }
      
      .vocab-bookmark-words-link-icon:hover {
        background: #f3e8ff;
        opacity: 1;
      }
      
      .vocab-bookmark-words-link-icon:active {
        background: #e9d5ff;
      }
      
      .vocab-bookmark-words-link-icon svg {
        width: 100%;
        height: 100%;
      }
      
      /* Delete Icon Button */
      .vocab-bookmark-words-delete-icon {
        width: 32px;
        height: 32px;
        padding: 6px;
        border: none;
        background: transparent;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background-color 0.2s ease;
        opacity: 0.7;
      }
      
      .vocab-bookmark-words-delete-icon:hover {
        background: #fef2f2;
        opacity: 1;
      }
      
      .vocab-bookmark-words-delete-icon:active {
        background: #fee2e2;
      }
      
      .vocab-bookmark-words-delete-icon svg {
        width: 100%;
        height: 100%;
      }
      
      /* Table row with smooth transition */
      .vocab-bookmark-words-table tbody tr {
        transition: background-color 0.3s ease;
      }
      
      /* Light purple hover effect for table rows (very very light) */
      .vocab-bookmark-words-table tbody tr:hover {
        background: rgba(149, 39, 245, 0.05) !important;
      }
      
      /* Override hover for green rows (active modal) - use darker green instead of purple */
      /* Only rows with data-has-active-modal attribute should show darker green */
      .vocab-bookmark-words-table tbody tr[data-has-active-modal="true"]:hover {
        background-color: #dcfce7 !important; /* Darker green, not purple */
      }
      
      /* Ensure rows without active modal still show purple on hover */
      .vocab-bookmark-words-table tbody tr:not([data-has-active-modal="true"]):hover {
        background: rgba(149, 39, 245, 0.05) !important; /* Light purple */
      }
      
      .vocab-bookmark-words-table tbody tr:last-child td {
        border-bottom: none;
      }
      
      /* Empty State */
      .vocab-bookmark-words-empty {
        text-align: center;
        padding: 40px 20px !important;
        color: #6b7280;
        font-size: 14px;
      }
      
      /* Pagination */
      .vocab-bookmark-words-pagination {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding-top: 16px;
        border-top: None;
      }
      
      .vocab-bookmark-words-pagination-info {
        font-size: 13px;
        color: rgba(149, 39, 245, 0.7);
      }
      
      .vocab-bookmark-words-pagination-buttons {
        display: flex;
        gap: 8px;
      }
      
      .vocab-bookmark-words-pagination-btn {
        padding: 8px 16px;
        border: 1.5px solid #d1d5db;
        border-radius: 8px;
        background: white;
        color: #374151;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      
      .vocab-bookmark-words-pagination-btn:hover:not(:disabled) {
        background: #f9fafb;
        border-color: #9527F5;
        color: #9527F5;
      }
      
      .vocab-bookmark-words-pagination-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      /* Scrollbar styling */
      .vocab-bookmark-words-table-container::-webkit-scrollbar {
        width: 6px;
      }
      
      .vocab-bookmark-words-table-container::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 3px;
      }
      
      .vocab-bookmark-words-table-container::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }
      
      .vocab-bookmark-words-table-container::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
    `;
    
    document.head.appendChild(style);
    console.log('[BookmarkWordsDialog] Styles injected');
  }
};

